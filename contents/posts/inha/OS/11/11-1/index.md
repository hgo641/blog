---
title: "os 11-1"
date: 2022-05-09
tags:
  - OS
---

## Dining-Philosophers Problem

> 원형 테이블에서 식사하는 철학자
>
> * 철학자는 thinking하거나 eating 두 가지 상태 존재
>
> * 각 철학자들은 밥을 먹어야할 때만 소통
>
> 두 명이 젓가락 한 개씩 공유
>
> * 옆에 있는 젓가락만 사용가능 ( i번째 사람은 i또는 i+1만)
>
> 공유데이터
>
> * 밥 (data set)
> * Semaphore chapstic [5]

- semaphore chapstic[5]; # binary semaphore(=mutex lock) 1or0

- signal() # release 밥을 다 먹음

- 데드락 문제 발생 가능!!

## Deadlock

내가 원하는 자원을 상대방이 점유하고있어서 다음으로 넘어갈 수 없음

ex. 모든 사람들이 다 자신의 왼쪽에 있는 젓가락 한 짝을 소유중

모두가 계속 기다림... 

* wait( chopstic[ (i+1) % 5] ) <- 여기서 다들 기다리게됨

<br/>

### 해결방안 1

다섯명의 철학자가 있지만 책상에 앉을 수 있는 사람을 4명으로 제한

- 적어도 한 명은 젓가락 한 쌍을 얻을 수 있다

<br/>

### 해결방안 2

젓가락 두 개가 동시에 사용 가능할때만 젓가락을 집게한다

- 두 줄의 코드가 atomic하게
- 크리티컬 섹션으로. 내가 젓가락을 집을 때 다른 사람이 집을 수 없음

-> 모니터를 사용해서 구현

state hungry 추가

* thinking

* hungry

* eating : 두 이웃이 젓가락을 안쓰고있을때만 eating 가능
* 모니터 안에는 condition self가 존재
  * condition == semaphore + waiting queue + wait(), signal() 함수를 제공하는 하나의 자료형
  * 여기서의 Semaphore는 자원이라기보단 스케줄링을 위한 수단이라고 보는게 좋음 



#### 코드

pickup() : 젓가락 획득 시도

* self[i].wait - i번째 사람이 밥을 먹을 수 없는 상태라면 대기
* 양쪽 사람들 중 누군가가 밥을 다 먹고 젓가락을 내려놓을때 먹을 수 있음

test() :  양쪽 사람이 안먹고있는지 체크

* 내가 배고픈데 & 왼쪽 사람이 밥 안먹고있고 & 오른쪽 사람이 밥을 안먹고있는가
* self[i].signal() - i번째 사람 밥먹으라고 신호

putdown() : 젓가락 반환

* test : i번째는 밥을 다 먹었으니 양 옆에 사람들이 밥 먹을 수 있는지 테스트
* test했는데 hungry면 기다리고 있었던 것. 걔 self[i].signal()로 밥먹게함

initialization_code() : state 초기화 

> No deadlock, but starvation is possible
>
> 데드락은 해결됐지만 누가 계속 밥을 먹으면 누군가는 굶주려야함

<br/>

### 해결방안 3

asymmetric한 구조를 만든다 (i -> i+1순으로 잡는데 만약 전체 인원의 반이 i+1->i순으로 젓가락을 집는다면?)

wait(i+1)

wait(i)

순으로 하게 변경

모두가 동시에 왼쪽 젓가락을 집지않는다



## Deadlock

어떤 프로세스가 다른 프로세스가 지닌 무언가를 얻기 위해 기다리고있는데 상대 프로세스도 무언가를 기다리는 중이라서 관련된 모든 프로세스들이 전부 기다려야하는 상황



### System Model

m개의 리소스 종류, R

* 리소스는 꼭 공유변수여야하는건 아니고 cpu 사이클일수도있고 메모리 공간일수도 있고 i/o 디바이스...
* 각각의 프로세스는 세 가지 경우가 있다
  * request
  * use
  * release
* 각각의 리소스 R은 리소스 총량 W가 있다
  * 리소스 R이 W개 있다



### 데드락 친구들

* Deadlock - 서로가 상대방의 자원을 요구하면서 기다리는 상태
* Livelock - 락의 획득/해제가 무한히 반복되는 상태 : 데드락을 방지하는 코드에서 발생할수도있음

* Indefinite Postponement - 일어나지 않을 일을 기다리는 중이라 무한하게 대기중인 상태



### 데드락의 조건

- Mutual exclusion
  - 한 명이 리소스를 차지하고있으면 다른 사람이 리소스를 동시에 차지할 수 없다
- No preemption
  - 한 번 자원을 얻으면 할 일이 끝날 때까지 자원을 양보하지않는다
- Hold and wait
  - 한 프로세스가 적어도 하나 이상의 리소스를 가지고 있고 다른 리소스를 원하는 상태, 그러나 그 다른 리소스는 또 다른 프로세스가 가지고있음

- Circular wait
  - 원을 그리면서 서로가 서로의 것을 원하는... 상태



### 데드락 방지

위 조건 중 하나라도 만족하지않으면 문제가 생기지않음



* no mutual exclusion
  * 여러명이 동시에 같은 자원 사용이 가능하게
  * 현실적으로 불가능 ㅎㅎ;
  * 리소스의 특성 자체를 바꾸는 일
* no preemption
  * 양보 가능한
  * 라이브락 가능성 존재
  * 그러나 새로운 것도 획득 가능 할때 다시 기존 것도 얻게하면 라이브락 방지가 가능할 것!
* no hold and wait
  * 리소스를 순차적을 얻지 않고 한 번에 얻거나 한 번에 기다린다
  * 프로세스가 어느 시점에 어떤 리소스를 원할지 예측하는게 어려움, 구현 복잡;;
  * 리소스 낭비가 심해질수있음 (쓸지안쓸진 모르지만 일단 다 받아놓자~ )
  * starvation 가능 - 한 명이 리소스 독식
* no circular wait
  * 서큘러가 될 거 같으면 연결 고리가 끊어질때까지 대기



## Resource-Allocation Graph

각 프로세스가 자원을 어떻게 활용하고 있는지 나타낸 그래프

4개 - 최대 4개의 프로세스가 사용가능



* circular wait이 있다면 데드락 가능성 존재
  * 완전히 닫힌 싸이클
* 예시1은 데드락
* 예시 2는 싸이클이지만 데드락 아님
  * p2 p4는 개별적을 동작 가능
  * 뭘 기다리고있지않음
