---
title: "수행시간이 O(n)인 정렬이 있다?"
date: 2022-09-24
tags:
  - cote
  - cpp
---

## 계수 정렬(Counting-sort)

카우링 스타~~ 밤 하늘의 펴허얼~<br/>

대부분의 정렬 알고리즘들은 O(nlogn)의 수행시간을 갖는다. 그렇지만 여기 O(n)의 수행시간을 보여주는 정렬이 있으니... 그 이름은 계수 정렬이렸다.<br/>
계수 정렬의 핵심은 배열 인덱스의 활용과 누적합 계산이다.<br/>

이후 자세히 설명하지만 배열의 사이즈만큼 탐색을 수행하고, array공간이 추가적으로 필요하다. 그렇기에 정렬해야할 value들의 사이즈 폭이 정해져있고 그 사이즈폭이 적을수록 유리한 정렬이다. <br/>

또한 value를 index값으로 사용하기때문에 value가 0이상이어야한다.

ex)  <br/>

1. oo고등학교 여학생들의 키를 정렬하라. 키는 140부터 190까지 존재한다.
   * 정렬할 value들의 사이즈가 140~190의 작은 사이즈폭이므로 계수정렬에 유리하다.

<br/>

### 📌 카운팅 value

여기 정렬되지 않은 배열 `A`가 있다.

```
[5, 4, 3, 2, 3, 1, 1, 1, 100, 100]
```

<br/>

위 `A`에서 등장하는 원소들을 인덱스로 두고 개수를 카운팅한 배열  `Count`가 있다.

| index | 1    | 2    | 3    | 4    | 5    | ...  | 100  |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 3    | 1    | 3    | 1    | 1    | ...  | 2    |

* 1은 3번 등장하니 3, 2는 1번등장하니 1 ...

> 이제 index 1부터 차례대로 value개수만큼 출력하면 정렬된 `A`의 원소들을 얻을 수 있다. 그러나 A의 경우 value 100과 다른 value들간의 크기 차이가 상대적으로 크다. <br/>
>
> 그렇기에 index1부터 차례대로 출력하면 정렬된 값을 얻을 수 있지만 6부터 99까지 탐색하지않아도 되는 index를 탐색해야만 한다. 이를 해결하기 위해 누적합을 구하는 방법이 있다. (물론 모든 0부터 n까지 모든 인덱스의 값이 존재하는 경우라면 이대로 정렬을 수행해도 차이가 없다.)

<br/>



### 📌 누적합 

`Count`의 첫 번째 인덱스 값부터 차례대로 누적합을 만든다.

| index | 1    | 2      | 3      | 4      | 5      | ...  | 100      |
| ----- | ---- | ------ | ------ | ------ | ------ | ---- | -------- |
| value | 3    | 4(3+1) | 7(4+3) | 8(7+1) | 9(8+1) | ...  | 11(10+2) |

> 위 배열로 각 원소들이 몇 번째 인덱스에 등장하는지 알 수 있다.<br/>
>
> * 1의 경우 1~3 번째 인덱스에 등장한다. (1 based index라고 가정)
> * 3의 경우 앞의 4 다음인 5~7번째 인덱스에 등장한다.
> * 100의 경우 10~11번째 인덱스에 등장한다.

위에서 구한 누적합을 가지고 정렬을 수행해보자!

<br/>

### 📌 정렬 수행

```
[5, 4, 3, 2, 3, 1, 1, 1, 100, 100]
```

자, 여기 정렬되기 전인 `A`를 다시 가져왔다.<br/>

정렬한 원소들을 담을 배열 `SortArray`를 생성했다고 가정하고 `SortArray`안에 하나씩 값을 넣어주겠다.  <br/>

// SortArray

| index | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value |      |      |      |      |      |      |      |      |      |      |

<br/>

// 11

* 가장 뒤에 있는 11번째 원소 100부터 올바른 자리를 배정해주자. 위 누적합을 계산했던 배열을 보면 index 100의 값은 11이다. 11번째 인덱스에 100이 위치한다는 말이므로 일단 11에 100을 넣어준다.

| index | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value |      |      |      |      |      |      |      |      |      |      | 100  |

* 100을 하나 넣었으면 `Count`의 100번 째 index의 value도 하나 줄여준다.

| index | 1    | 2    | 3    | 4    | 5    | ...  | 100    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ------ |
| value | 3    | 4    | 7    | 8    | 9    | ...  | **10** |

<br/>

// 10

* 11번째 원소를 넣었으니 앞으로 한 칸 당겨 이제 10번째 원소를 넣어준다. 10번째 원소도 100이므로 `Count`의 100번째 인덱스의 value를 찾는다. 현재 Count[100] = 10이므로 SortArray의 10번째 인덱스에 100을 넣는다.

| index | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value |      |      |      |      |      |      |      |      |      | 100  | 100  |

* 마찬가지로 Count[100]--를 해준다.

| index | 1    | 2    | 3    | 4    | 5    | ...  | 100   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
| value | 3    | 4    | 7    | 8    | 9    | ...  | **9** |

<br/>

// 9

* 이제 A의 9 번째 인덱스를 SortArray에 넣어준다.
* A[9] = 1이므로 Count[1]의 value를 찾는다.
* Count[1]의 값은 3이므로 SortArray의 3번째 인덱스에 1을 넣어준다.

| index | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value |      |      | 1    |      |      |      |      |      |      | 100  | 100  |

* Count[1]--를 해준다.

| index | 1    | 2    | 3    | 4    | 5    | ...  | 100   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
| value | 2    | 4    | 7    | 8    | 9    | ...  | **9** |

<br/>

이 과정을 A의 1번째 원소까지 반복하면 정렬된 SortArray를 얻을 수 있다!

| index | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| value | 1    | 1    | 1    | 2    | 3    | 3    | 3    | 4    | 5    | 100  | 100  |



### 🤔 꼭 뒤에서부터 탐색할 필요가 있을까?

앞서 A의 가장 뒤에 있는 원소부터 올바른 자리를 찾아 배정해줬다. 그러나 이 방식은 A의 가장 앞에 있는 원소부터 탐색해도 정렬을 수행할 수 있다. <br/>

그러나 뒤에서부터 탐색을 하면 `stable 정렬`을 수행할 수 있다. `stable` 하다는 것은 중복되는 값을 순서대로 정렬한다는 것을 의미한다. 예시를 봐보자.<br/>

아직 정렬되지 않은 배열 `B`가 있다.

| index | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| value | 1    | 2    | 1    | 3    | 1    |

* 이 배열에는 1이라는 값이 세 번 등장한다. 각각 인덱스 1번, 3번, 5번으로 순서가 존재한다. (1-based index입니다^^)<br/>

이 배열을 정렬했다고 가정해보자.

| index | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| value | 1    | 1    | 1    | 2    | 3    |

* 이 때 1은 가장 작은 값이므로 인덱스 1번 ~ 3번을 차지한다.
* 이 때, 1번째에 위치한 1이 A[1]에 있었던 1이고, 2번째에 위치한 1이 A[3]에 있었던 1이고, 3번째에 위치한 1이 A[5]이라면, 이 정렬은 stable하다고 본다.
* 즉, 기존 배열에서의 순서가 정렬된 이후에도 유지되어야하는 것이다.

<br/>

여기서 계수 정렬을 뒤에서 부터 탐색한 이유가 나온다. 원소의 정렬된 인덱스를 찾아줄 때, 누적합을 이용해서 해당 원소가 배치될 수 있는 인덱스 중, 제일 끝에 있는 인덱스를 먼저 반환해주기 때문에 먼저 탐색당한 원소가 중복되는 원소들중 가장 뒤에 배치되게 된다. 그렇기에 statble sort를 원한다면 계수 정렬을 사용할 때 가장 뒤의 원소부터 탐색하면 된다. (물론 stable하지않아도 된다면 상관없음 ㅎㅎ)
