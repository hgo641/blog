---
title: "cpp로 비트마스킹 & 백준 1285 동전 뒤집기 풀이"
date: 2022-10-09
tags:
  - cpp
---

## 사전 지식

### 1. 이진수를 사용해서 bool 배열을 표현할 수 있다.

- `0001`의 경우 0번째 value가 true이고 1, 2, 3번째 value는 false라고 볼 수 있다.
- `1010`의 경우 1, 3번째 value가 true이고, 0, 2번째 value는 false라고 볼 수 있다.

이처럼 이진수를 사용해서 불리언 배열을 표현할 수 있다.

### 2. 비트연산자

시프트 연산자 `<<`는 수의 자릿수를 왼쪽으로 이동시킨다는 의미이다. 이진수를 활용하는 비트마스킹에서 (1<<n)의 의미는 2^n승을 하겠다는 의미가 된다.

| 설명                           | 코드                |
| ------------------------------ | ------------------- |
| idx번째 비트끄기 (false)       | S &= ~(1 << idx)    |
| idx번째 비트를 켜기 (true)     | S \|= (1 << idx)    |
| idx번째에 대한 XOR연산         | S ^= (1 << idx)     |
| n인 집합의 모든 비트를 켜기    | (1 << n) - 1        |
| 최하위에 켜져있는 idx 찾기     | idx = (S & -S)      |
| idx번째 비트가 있는지 확인하기 | if (S & (1 << idx)) |

#### 📌 n인 집합의 모든 비트를 켜기

0, 1, 2, 3의 idx를 가지는 4개의 집합의 모든 비트를 켜고 싶다고 해보자. <br/>

- ex) `00001111`

(1 << 4) 를 하면 00010000이 된다. 여기서 1을 빼면 00001111이 되므로 0~3번째 idx의 비트를 한 번에 켤 수 있다.

#### 📌 최하위에 켜져있는 idx 찾기

-S는 ~S + 1과 동일하다. (1의 보수를 취하고 1을 더함)

- S가 0110일 때, 1의 보수는 비트를 모두 뒤집은 1001이다.
- 1001에 1을 더하면 1010이 되고 이게 -S를 나타내는 비트이다.

S(0110)과 -S(1010)을 &연산하게 되면 가장 끝에 켜져있는 비트를 뽑아낼 수 있다. (0010)

## 비트마스킹

어떠한 특정원소를 찾을 때 시간복잡도는 다음과 같다.

- 배열의 어떤 요소를 찾을 때 선형적인 시간 : O(N)이 걸린다.
- sorted array에서 이분탐색으로 찾을 때는 O(logN)이 걸린다.
- 해싱테이블에서는 O(1)이 걸린다.

<br/>

그렇다면 불리언 배열에서 무언가를 찾는 등의 연산은 어떻게 될까? 마찬가지로 배열이므로 어떤 요소를 찾으려면 O(N)이 걸린다. 그러나 불리언배열의 역할을 하는 "하나의 숫자"를 만들어서 "비트 연산자"를 통해 탐색, 수정 등의 작업을 하면 불리언 배열을 만드는 것보다 더 빠른 시간내에 연산을 수행할 수 있다. 이를 비트마스킹이라고 한다.

- 101은 1과 4의 합집합이며 이는 {0, 2}로 표현이 가능함.
- 111은? {0, 1, 2}로 표현이 가능함.

<br/>

즉, 불리언배열을 만들어서 {0, 1, 0, 1} 이렇게 만들지 않고 **0101 이라는 하나의 수, 5** 등을 이용해 **하나의 숫자로 불리언 배열같은 역할**을 할 수 있다. 또한 앞서 배운 비트연산자를 통해 해당 요소가 포함되어있는지 안되어있는지 등을 쉽게 알 수 있다.

### 비트마스킹을 이용한 경우의 수

{사과, 딸기, 포도, 배}라는 문자열 배열이 있을 때 모든 경우의 수를 출력해보자.

```cpp
#include <bits/stdc++.h>
using namespace std;

const int n = 4;

int main() {
	ios::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);
	string arr[n] = { "사과", "포도", "딸기", "귤" };
	for (int i = 0; i < (1<<n); i++) { // 1 << n 은 16가지의 경우의 수
		string ret = "";
		for (int j = 0; j < n; j++) { // j번째 bit가 true인지 확인
			if (i & (1 << j)) {
				ret += arr[j];
			}
		}
		cout << ret << "\n";
	}
}

/*
사과
포도
사과포도
딸기
사과딸기
포도딸기
사과포도딸기
귤
사과귤
포도귤
사과포도귤
딸기귤
사과딸기귤
포도딸기귤
사과포도딸기귤
*/

```

### 비트마스킹을 이용한 매개변수 전달

{사과, 딸기, 포도, 배}에서 사과는 무조건 선택되어 있고 나머지중 하나를 선택해야 할 때

```cpp
#include <bits/stdc++.h>
using namespace std;

const int n = 4;
string arr[n] = { "사과", "포도", "딸기", "귤" };

void go(int num) {
	string ret = "";
	for (int j = 0; j < n; j++) {
		if (num & (1 << j)) {
			ret += arr[j];
		}
	}
	cout << ret << "\n";
	return;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);

	for (int i = 0; i < n; i++) {
		go(1 | (1<<i));
	}
}

/*
사과
사과포도
사과딸기
사과귤
*/
```

## 비트마스킹 문제 예시

[백준 1285 동전 뒤집기](https://www.acmicpc.net/problem/1285)

- 앞면인 H를 0, 뒷면인 T를 1이라고 본다.
- 한 행을 하나의 int형으로 저장한다.
  - ex) HHT -> 001 -> 4
  - ex) THH -> 100 -> 1
  - ex) THT -> 101 -> 5
- 동전의 모든 경우의 수는 어떤 행과 어떤 열을 뒤집거나 뒤집지 않은 모든 경우의 수이므로, 2^40인것처럼 보인다. (행과 열이 최대 20)
- 그러나 행을 뒤집는 모든 경우의 수를 구한다면, 열은 최소의 T개를 가지는 루트가 명백해지기에 시간복잡도는 2^20 \* 20이 된다. (물론 열을 먼저 뒤집어도 마찬가지이다.)

```cpp
#include <bits/stdc++.h>
using namespace std;

int arr[21];
int n, v;
int minValue = INT_MAX;
string str;

void go(int depth) {
	if (depth == n) { // 마지막 depth까지 행 뒤집기가 완료
		int sum = 0;
		for (int i = 0; i < n; i++) {
			int cnt = 0;
			for (int j = 0; j < n; j++) {
				if (arr[j] & (1 << i)) { // 해당 자릿수가 T이면 카운트
					cnt++;
				}
			}
			sum += min(cnt, n - cnt); // 만약 T가 더 많다면 해당 열을 뒤집게 된다. 열을 뒤집으면 T의 개수는 n-cnt가 된다. cnt와 n-cnt중 최솟값이 해당 열에 있을 수 있는 T의 최소 개수가 된다.
		}
		minValue = min(minValue, sum);
		return;
	}
    // 행을 뒤집는 모든 경우의 수를 구함
    // 해당 depth의 행을 뒤집지 않은 경우
	go(depth + 1);

    // 해당 depth의 행을 뒤집은 경우
	arr[depth] = ~arr[depth];
	go(depth + 1);
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> str; // HTT
		v = 1;
		for (int j = 0; j < n; j++) {
			if (str[j] == 'T') { // T를 1이라고 가정
				arr[i] |= v; // T의 자릿수를 1로 변환
			}
			v *= 2; // 자릿수 증가
		}
	}
	go(0);
	cout << minValue;

}
```

## 비트마스킹의 한계

비트마스킹은 31번 idx까지 가능하다는 한계가 있다. int형 숫자의 한계이다. long long은 어떠냐 하는 의견도 있는데 보통 2^ 30승정도만 해도... 10억이 되기 때문에 그 이후의 경우의 수를 센다는 것 자체가 이미 시간복잡도를 많이 초과하기 때문에 보통은 30 ~ 31 까지의 경우의 수만을 표현할 수 있다고 볼 수 있다.

## 참고

- [[알고리즘 강의\] 4주차. 비트마스킹](https://blog.naver.com/jhc9639/222310927725)|**작성자** [큰돌](https://blog.naver.com/jhc9639)
