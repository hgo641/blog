---
title: "c++ : 백준 9251 LCS"
date: 2022-10-21
tags:
  - cote
---

## LCS

[백준 9251 LCS](https://www.acmicpc.net/problem/9251)에서 LCS를 구하는 문제가 나왔다! LCS(Longest Common Subsequence, 최장 공통 부분 수열)란...

- `abcde`라는 문자열(수열)이 주어졌을 때 이 수열을 가지고 만들 수 있는 부분 수열들은 `a`, `ab`, `abc`, `abe`,`abde`등이 있다.
- 부분 수열들은 기존 수열에서 나타난 원소 순서가 일치해야한다. (`bca`는 `abcde`의 부분 수열이 될 수 없다.)

<br/>

LCS는 위와 같은 수열들이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 의미한다.

- `abcde`와 `cdeabcde`의 LCS는 `abcde`이다.
- `acaktzz`와 `cakcazz`의 LCS는 `cakzz`와 `acazz`이다.

<br/>

그럼 이 LCS라는 것은 어떻게 구할 수 있을까?<br/>

처음 생각나는 방법은 첫 번째 수열의 모든 부분 수열들을 생성해서 두 번째 수열의 부분 수열이 될 수 있는지 검사하는 방법이다. 하지만 이 방법의 경우 시간복잡도가 매우 커진다. O( 2^n \* 2^m ) <br/>

다행히도 dp를 사용하면 더 빠르게 LCS를 구할 수 있다. 아래 로직을 봐보자.

## 로직

LCS는 dp를 사용해서 구할 수 있다. 코드를 보기전 로직을 자세히 봐보자<br/>

<br/>

- 아래와 같이 첫 번째 row와 column이 0으로 초기화된 표를 생성한다. (수열은 표에 포함된게 아니라 편의상 표시된 것)

|     |     | c   | a   | k   | c   | a   | z   | z   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
|     | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| a   | 0   |     |     |     |     |     |     |     |
| c   | 0   |     |     |     |     |     |     |     |
| a   | 0   |     |     |     |     |     |     |     |
| k   | 0   |     |     |     |     |     |     |     |
| t   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |

<br/>

- 세로에 있는 문자열을 `fst` , 가로에 있는 문자열을 `sec`이라고 해보자.
- `fst`의 첫 번째 문자부터 차례대로 `sec`의 모든 문자들과 비교한다.
- **만약 `fst`의 문자와 비교중인 `sec`의 문자가 같다면 해당 칸의 값은 `왼쪽 대각선 위의 값 + 1`로 갱신한다.**
- **같지 않다면, 위에 칸과 왼쪽의 칸 중 더 큰 값으로 갱신한다.**

|     | 0   | c   | a   | k   | c   | a   | z   | z   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| a   | 0   | 0   | 1   |     |     |     |     |     |
| c   | 0   |     |     |     |     |     |     |     |
| a   | 0   |     |     |     |     |     |     |     |
| k   | 0   |     |     |     |     |     |     |     |
| t   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |

```
// 예시
fst의 a를 sec의 문자들과 차례대로 비교할 때,  sec의 두 번째 문자와 a가 같으므로 해당 칸의 값을 왼쪽 대각선 위의 칸 값 + 1로 변경한다.
```

<br/>

- 이어서 a와 sec의 모든 문자들을 전부 비교한 결과이다.

|     | 0   | c   | a   | k   | c   | a   | z   | z   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| a   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
| c   | 0   |     |     |     |     |     |     |     |
| a   | 0   |     |     |     |     |     |     |     |
| k   | 0   |     |     |     |     |     |     |     |
| t   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |
| z   | 0   |     |     |     |     |     |     |     |

```
k, c는 a와 같지 않으므로 왼쪽과 위의 값 중 더 큰 값으로 갱신한다. (왼쪽이 1로, 더 크므로 1로 갱신)
5번째 문자인 a는 a와 같으므로 왼쪽 대각선 위의 값 + 1로 갱신한다. (마찬가지로 0 + 1로 1)
마지막 z, z도 a와 같지 않으므로 왼쪽과 위의 값 중 더 큰 값으로 갱신한다. (왼쪽이 1로, 더 크므로 1로 갱신)
```

<br/>

- 이 방법을 `fst`의 마지막 문자까지 반복하면 표가 아래와 같이 된다.

|     | 0   | c   | a   | k   | c   | a   | z   | z   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |
| a   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
| c   | 0   | 1   | 1   | 1   | 2   | 2   | 2   | 2   |
| a   | 0   | 1   | 2   | 2   | 2   | 3   | 3   | 3   |
| k   | 0   | 1   | 2   | 3   | 3   | 3   | 3   | 3   |
| t   | 0   | 1   | 2   | 3   | 3   | 3   | 3   | 3   |
| z   | 0   | 1   | 2   | 3   | 3   | 3   | 4   | 4   |
| z   | 0   | 1   | 2   | 3   | 3   | 3   | 4   | 5   |

<br/>

가장 마지막의 5가 LCS의 길이가 된다. 무슨 원리로 이렇게 되는걸까?<br/>

왼쪽 대각선 위의 값은 `fst`의 현재 문자이전에 앞에서 계산한 LCS를 의미한다. 이전 LCS를 대각선 값으로 넣어 축적해나가는 것이다. LCS의 길이뿐만 아니라 LCS의 수열도 구할 수 있다. 수열을 구하는 방법을 보면 LCS가 누적되는 로직을 이해하기 더 쉬울 것이다.

### 📌 표에서 LCS 수열 읽기

아까 구한 `acaktzz`(fst)와 `cakcazz`(sec)의 LCS 표이다.

|     | 0   | c   | a       | k   | c       | a       | z       | z       |
| --- | --- | --- | ------- | --- | ------- | ------- | ------- | ------- |
| 0   | 0   | 0   | 0       | 0   | 0       | 0       | 0       | 0       |
| a   | 0   | 0   | **_1_** | 1   | 1       | 1       | 1       | 1       |
| c   | 0   | 1   | 1       | 1   | **_2_** | 2       | 2       | 2       |
| a   | 0   | 1   | 2       | 2   | 2       | **_3_** | 3       | 3       |
| k   | 0   | 1   | 2       | 3   | 3       | 3       | 3       | 3       |
| t   | 0   | 1   | 2       | 3   | 3       | 3       | 3       | 3       |
| z   | 0   | 1   | 2       | 3   | 3       | 3       | **_4_** | 4       |
| z   | 0   | 1   | 2       | 3   | 3       | 3       | 4       | **_5_** |

LCS 수열을 읽는 방법은 어렵지 않다! 계단을 한 칸씩 내려가듯이 **왼쪽과 위와 비교해서 큰 숫자로 제일 먼저 변한 지점의 문자**를 찾으면 된다. 말이 어려운데 아래 예시를 보자!

- a와 a가 만나는 (2,3)지점을 보자 (맨 왼쪽 위가 (1,1), 맨 오른쪽 아래가 (n,m))
- (2,3)은 위와 왼쪽부분의 값이 모두 0으로 제일 먼저 **숫자가 커진 지점**이다.
- 이는 현재까지 지나쳐온 수열 (fst의) `a`와 (sec의 `ca`에서 LCS는 `a`((2,3)에 해당하는 문자)이며, 길이가 1이라는 의미이다.

---

- 이제 (2,3)을 기준으로 계단을 내려가듯이 내려가보자. 그 다음으로 숫자가 제일 먼저 커지는 지점은 (3,5)로 제일 먼저 숫자가 2로 커진다.
- 이는 현재까지 지나쳐온 수열 (fst의) `ac`와 (sec의) `cakc`에서 LCS는 ac이며, 길이가 2이라는 의미이다.
  - LCS `ac`에서 앞의 a는 이전 (1,1)에서 누적된 문자이며, c는 현재 추가된 문자이다.

---

- 위와 같이 마지막 5까지 계산하면,
- 수열 `acaktzz`와 `cakcazz`의 LCS는 `acazz`이며, 길이는 5가 된다.

---

- 수열 `acaktzz`와 `cakcazz`의 LCS는 `acazz`외에 하나가 더 있다.
- (2,3)과 같이 왼쪽 칸들, 위쪽 칸들과 비교해서 가장 먼저 숫자가 커진 지점이 하나 더 존재하며, 이는 (3,2)칸이다.
- (3,2)에서 시작해 마지막까지 LCS를 체크하면 `cakzz`인 것을 알 수 있다.

|     | 0   | c       | a       | k       | c   | a   | z       | z       |
| --- | --- | ------- | ------- | ------- | --- | --- | ------- | ------- |
| 0   | 0   | 0       | 0       | 0       | 0   | 0   | 0       | 0       |
| a   | 0   | 0       | 1       | 1       | 1   | 1   | 1       | 1       |
| c   | 0   | **_1_** | 1       | 1       | 2   | 2   | 2       | 2       |
| a   | 0   | 1       | **_2_** | 2       | 2   | 3   | 3       | 3       |
| k   | 0   | 1       | 2       | **_3_** | 3   | 3   | 3       | 3       |
| t   | 0   | 1       | 2       | 3       | 3   | 3   | 3       | 3       |
| z   | 0   | 1       | 2       | 3       | 3   | 3   | **_4_** | 4       |
| z   | 0   | 1       | 2       | 3       | 3   | 3   | 4       | **_5_** |

## 코드

위 로직을 구현한 코드는 다음과 같다.

```cpp
#include <bits/stdc++.h>
using namespace std;

string fst, sec;

int dp[1002][1002];

int main() {
	cin >> fst >> sec;
	for (int i = 0; i < fst.size(); i++) {
		for (int j = 0; j < sec.size(); j++) {
			if (fst[i] == sec[j]) { // 같으면 "왼쪽 대각선 위 + 1" 로 갱신
				dp[i + 1][j + 1] = dp[i][j] + 1;
			}
			else { // 다르면 max(왼쪽, 위쪽)으로 갱신
				dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
			}
		}
	}
	cout << dp[fst.size()][sec.size()] << "\n";
}

```
