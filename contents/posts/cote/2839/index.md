---
title: "백준 2839 설탕배달"
date: 2022-07-13
tags:
  - cote
---

## 문제

상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.
<br/>
상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.
<br/>
상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.
<br/>

## 풀이

- greedy 방식으로 바로 풀 수 있는 문제였다!

### 첫 번째 방법 - 그리디 알고리즘

```cpp
int n, cnt;
int main() {
	cin >> n;
	int quo = n / 5;
	int flag = 0; // 봉지에 정확하게 나눠 담을 수 있는지 확인
	for (int i = quo; i >= 0; i--) { // 5kg 봉지를 최대한 많이 사용할 수 있는 경우의 수 부터 체크
		int sub = i * 5;
		if ((n - sub) % 3 == 0) { // 5kg봉지로 담고 남은 양을 3kg봉지로 전부 담을 수 있는지 확인
			cnt = i + ((n - sub) / 3);
			flag = 1;
			break;
		}
	}
	if (flag) cout << cnt;
	else cout << -1;
}
```

### 두 번째 방법 - 다이나믹 프로그래밍

- 다른 분의 풀이를 보니 다이나믹 프로그래밍으로도 풀 수 있었다.

```c++
int dp[5001]; //global 변수이기때문에 0으로 초기화된 배열

int main() {
	int n;
	cin >> n;
	dp[3] = dp[5] = 1;	//3kg와 5kg는 봉지 1개로 만들 수 있으므로 초기화 하고 시작

	for (int i = 6; i <= n; i++) { // 1,2,4는 봉지 0개이므로 6부터 시작
		if (dp[i - 5]) dp[i] = dp[i - 5] + 1;
		if (dp[i - 3]) dp[i] = dp[i] ? dp[i] : dp[i - 3] + 1; // 5kg봉지를 많이 쓸수록 봉지수가 줄어드므로 위에서 이미 dp[i]를 채웠다면 그대로 dp[i]를 적용하고, dp[i]가 없다면 dp[i-3]+1을 적용
	}
	cout << (dp[n] == 0 ? -1 : dp[n]) << endl;
	return 0;
}
```
