---
title: "백준 18111 마인크래프트"
date: 2022-07-13
tags:
  - C++
  - cote
series: "코테준비"
---

## 문제

팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.
<br/><br/>
목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.
<br/><br/>
lvalue는 세로 N, 가로 M 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.
<br/><br/>

1. 좌표 (i, j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
2. 인벤토리에서 블록 하나를 꺼내어 좌표 (i, j)의 가장 위에 있는 블록 위에 놓는다.
   <br/><br/>
   1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.
   <br/><br/>
   단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.
   <br/><br/>

## 풀이

이번 문제는 특별한 자료구조를 사용하진않고, 로직을 짜서 바로 구현했다...<br/><br/>

```c++
int cnt[257]; // 높이가 idx인 블럭들을 카운트한다.
int n, m, b, e;
int sum, cur, need, extra, depth;
int ans = INT_MAX;

void count_time(int i) {
	for (int j = 0; j < 257; j++) {
		if (i < j) {
			sum += cnt[j] * (j - i) * 2; // 높이가 i가 될 때까지 블럭을 제거하는데 걸리는 시간
			extra += cnt[j] * (j - i); // 위 에서 블럭을 제거하고 추가적으로 획득하는 블럭
		}
		else if (i > j) {
			sum += cnt[j] * (i - j); // 높이가 i가 될 때까지 블럭을 쌓는데 걸리는 시간
			need += cnt[j] * (i - j); // 위에서 블럭을 쌓는데 필요한 블럭
		}
	}

	if (b + extra - need >= 0) { // 쌓을 블럭이 부족한지 확인
		if (sum <= ans) { // 가장 빠른 소요시간을 찾기위해 비교
			ans = sum;
			depth = i;
		}
	}
}

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> n >> m >> b;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> e;
			cnt[e]++; // 높이가 e인 블럭들을 카운트
		}
	}

	for (int i = 0; i < 257; i++) { // 모든 블럭들의 높이를 i로 만드는데 걸리는 시간을 체크한다.
		sum = 0; // 걸리는 시간
		need = 0; // 높이를 i로 만드는데 필요한 블럭의 수
		extra = 0; // 높이를 i를 만들면서 추가적으로 획득하는 블럭의 수
		count_time(i);
	}

	cout << ans <<" "<< depth;
}
```
