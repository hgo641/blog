---
title: "Minimax 알고리즘 & alpha-beta 가지치기"
date: 2022-04-04
tags:
  - ai
  - inha
---

### Minimax Algorithm

---

max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다.

max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다.

<img src ="http://thumbnail.egloos.net/600x0/http://pds26.egloos.com/pds/201212/11/23/d0091423_50c73a317c0ed.png"/>

위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때

max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다

min(파란색)단인 1 depth에서는 8과 7중 최소값인 7이 올란간다

이것을 Minimax Algorithm이라고 하며, 가장 아래 depth부터 올라간다.(depth-first searching)

### alpha-beta 가지치기

---

Minimax Algorithm을 할 때, searching할 필요가 없는 루트는 제거하는 방법이다.

**Alpha**는 max단에서 정해지는 값이고, **Beta**는 min단에서 정해지는 변수이다.

**Alpha** 는 이전(상위) 상태들 중에서 AI에게 가장 유리한 상태의 점수, **Beta** 는 이전(상위) 상태들 중에서 상대방에게 가장 유리한 상태의 점수이다.

**Alpha cut-off** 는 자신이 상대방보다 불리하여, 자신이 그 경우를 선택하지 않을 때 불필요한 연산을 잘라내는 것이고, **Beta cut-off** 는 자신이 상대방보다 유리하여, 상대방이 그 경우를 선택하지 않을 확률이 높을 때 불필요한 연산을 잘라내는 것이다.

#### 1. Alpha cut-off

<hr>

(1)

<img src ="http://pds25.egloos.com/pds/201212/12/23/d0091423_50c74f11d7ffe.png"/>

각각의 노드에 써있는 순서쌍이 (Alpha, Beta)라고 할 때

재 1번으로 표시된 노드의 왼쪽 자식의 탐색을 끝냈고, 이제 2번 방향으로 진행해서 1번 -> 2번 -> 3번 -> 4번 노드 순으로 함수를 진행하고 있다고 생각해보자. 알파-베타 함수의 정의에 따라 부모 노드의 alpha, beta 값이 그대로 내려온다.

위의 예에 대해 설명을 더 하자면, 1번 노드의 왼쪽 자식의 탐색을 끝내고 1번 노드의 알파 값이 5로 변경이 되었다. 이는, 1번 노드에서 현재까지 탐색된 경로들 중 최선의 경로를 선택해서 얻을 수 있는 최대값은 5라는 의미이다. 이제 2번 노드로 함수를 진행할 때, 1번 노드의 왼쪽자식으로부터 얻은 alpha 값을 넘겨주어 진행한다.
3번, 4번 노드로 갈 때도 마찬가지.

(2)

<img src ="http://pds27.egloos.com/pds/201212/12/23/d0091423_50c7501f5a0f1.png"/>

이제 5, 6, 7, 8번 노드 순으로 계속 진행한다.
우선, 5번 노드의 하위 두 노드의 상태함수 값의 최소값은 4이므로 5번 노드의 베타값이 갱신이 되었다. 6번 노드의 알파값은 5이고, 5번 노드로부터 얻은 값 4와 비교해봤을 때 5가 더 크므로 6번 노드의 알파값은 변함없다. 7번 노드의 베타값은 6번 노드의 알파값인 5로 갱신되고, 이 때 alpha >= beta 가 되므로 alpha cut-off가 일어난다.

alpha cut-off는 쉽게 말해서 **"현재의 경로는 우리가 이미 아까 구해논 최적의 경로 값과 비교했을 때 상대방에게 더 유리한 경로이다. 그렇다면 현재의 경로를 애초에 택하지 않고 다른 경로를 택하면 되므로, 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다"** 라는 논리이다.

그림에서는 빨간색 플레이어가 8번 노드에서 왼쪽 자식으로 수를 두게 되면 최소 5의 상태함수값을 얻고, 오른쪽 자식으로 수를 두게 되면 상대방이 최선의 수를 둘 경우 4(혹은 그 이하 - 아직 나머지 자식들에 대한 탐색이 끝나지 않았으므로 모르는 것이다)의 상태함수값을 얻게 되어, 왼쪽 자식으로 수를 두는 것이 더 낫다. 따라서 더이상 오른쪽 자식의 남은 자식들에 대해 탐색할 필요가 없는 것이다.

#### 2. beta cut-off

---

(1)

<img src="http://pds27.egloos.com/pds/201212/12/23/d0091423_50c753d3207e2.png"/>

1 -> 2 -> 3번 노드 순으로 진행한다.
1번에서 13, 16 중에 작은걸 베타 값으로 갱신하여 13을 리턴하였고,
2번 노드에서 알파 값을 13으로 바꾼다. 여기서 alpha >= beta가 되므로 beta cut-off가 일어난다.

beta cut-off는 쉽게 말하면 **"현재의 경로는 우리가 아까 구해논 상대방 입장에서의 최적의 경로 값과 비교했을 때 내가 더 유리한 경로이다. 따라서 만일 상대가 항상 최선의 수를 택한다면, 현재의 경로를 택하진 않을 것이다(만약 상대가 현재의 경로를 택해 준다면 내가 유리해지니까 땡큐고). 따라서 우리도 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다"** 라는 논리이다.

파란색 플레이어가 그림의 3번 노드에서 왼쪽 자식으로 진행하게 되면 7 이하의 상태함수값을 얻게 되고, 오른쪽 자식으로 진행하게 되면 최악의 경우 적어도 13의 상태함수 값을 얻게 된다. 따라서 파란색 플레이어 입장에서는 왼쪽으로 진행하는 편이 더 나은 것이고, 더 이상 나머지를 탐색할 필요성이 없어지는 것이다.

#### + 예제

<img src ="https://t1.daumcdn.net/cfile/tistory/998EA7425AB214BD16"/>

searching은 아래부터 시작한다. i부터 차례대로 depth-first searching을 한다고 가정한다.

j가 4이므로 max단의 e에는 4이상의 숫자가 들어가게된다.

1. 만약 k가 4보다 작다면?

   max단에서 k보다 큰 j를 선택하므로 k를 선택하지않는다.

2) 만약 k가 4이상이라면?

   max단의 e가 k를 선택하게된다. 그러나 d의 값이 e(=k)의 값보다 작은 2이므로 상위단인 b에서 e가 아닌 d를 선택하게되므로 똑같이 k로 갈 일이 없다.

**따라서 e -> k는 가지치기를 하게된다**

(참고 - http://musicdiary.egloos.com/v/4274653)
