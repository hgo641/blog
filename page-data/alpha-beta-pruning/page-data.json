{"componentChunkName":"component---src-templates-post-jsx","path":"/alpha-beta-pruning/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","excerpt":"Minimax Algorithm max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다. max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다. 위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때 max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다 min(파란색)단인 1 depth…","html":"<h3>Minimax Algorithm</h3>\n<hr>\n<p>max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다.</p>\n<p>max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다.</p>\n<img src='http://thumbnail.egloos.net/600x0/http://pds26.egloos.com/pds/201212/11/23/d0091423_50c73a317c0ed.png'>\n<p>위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때</p>\n<p>max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다</p>\n<p>min(파란색)단인 1 depth에서는 8과 7중 최소값인 7이 올란간다</p>\n<p>이것을 Minimax Algorithm이라고 하며, 가장 아래 depth부터 올라간다.(depth-first searching)</p>\n<h3>alpha-beta 가지치기</h3>\n<hr>\n<p>Minimax Algorithm을 할 때, searching할 필요가 없는 루트는 제거하는 방법이다.</p>\n<p><strong>Alpha</strong>는 max단에서 정해지는 값이고, <strong>Beta</strong>는 min단에서 정해지는 변수이다.</p>\n<p><strong>Alpha</strong> 는 이전(상위) 상태들 중에서 AI에게 가장 유리한 상태의 점수, <strong>Beta</strong> 는 이전(상위) 상태들 중에서 상대방에게 가장 유리한 상태의 점수이다.</p>\n<p><strong>Alpha cut-off</strong> 는 자신이 상대방보다 불리하여, 자신이 그 경우를 선택하지 않을 때 불필요한 연산을 잘라내는 것이고, <strong>Beta cut-off</strong> 는 자신이 상대방보다 유리하여, 상대방이 그 경우를 선택하지 않을 확률이 높을 때 불필요한 연산을 잘라내는 것이다.</p>\n<h4>1. Alpha cut-off</h4>\n<hr>\n<p>(1)</p>\n<img src='http://pds25.egloos.com/pds/201212/12/23/d0091423_50c74f11d7ffe.png'>\n<p>각각의 노드에 써있는 순서쌍이 (Alpha, Beta)라고 할 때</p>\n<p>재 1번으로 표시된 노드의 왼쪽 자식의 탐색을 끝냈고, 이제 2번 방향으로 진행해서 1번 -> 2번 -> 3번 -> 4번 노드 순으로 함수를 진행하고 있다고 생각해보자. 알파-베타 함수의 정의에 따라 부모 노드의 alpha, beta 값이 그대로 내려온다.</p>\n<p>위의 예에 대해 설명을 더 하자면, 1번 노드의 왼쪽 자식의 탐색을 끝내고 1번 노드의 알파 값이 5로 변경이 되었다. 이는, 1번 노드에서 현재까지 탐색된 경로들 중 최선의 경로를 선택해서 얻을 수 있는 최대값은 5라는 의미이다. 이제 2번 노드로 함수를 진행할 때, 1번 노드의 왼쪽자식으로부터 얻은 alpha 값을 넘겨주어 진행한다.\n3번, 4번 노드로 갈 때도 마찬가지.</p>\n<p>(2)</p>\n<img src='http://pds27.egloos.com/pds/201212/12/23/d0091423_50c7501f5a0f1.png'>\n<p>이제 5, 6, 7, 8번 노드 순으로 계속 진행한다.\n우선, 5번 노드의 하위 두 노드의 상태함수 값의 최소값은 4이므로 5번 노드의 베타값이 갱신이 되었다. 6번 노드의 알파값은 5이고, 5번 노드로부터 얻은 값 4와 비교해봤을 때 5가 더 크므로 6번 노드의 알파값은 변함없다. 7번 노드의 베타값은 6번 노드의 알파값인 5로 갱신되고, 이 때 alpha >= beta 가 되므로 alpha cut-off가 일어난다.</p>\n<p>alpha cut-off는 쉽게 말해서 <strong>\"현재의 경로는 우리가 이미 아까 구해논 최적의 경로 값과 비교했을 때 상대방에게 더 유리한 경로이다. 그렇다면 현재의 경로를 애초에 택하지 않고 다른 경로를 택하면 되므로, 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"</strong> 라는 논리이다.</p>\n<p>그림에서는 빨간색 플레이어가 8번 노드에서 왼쪽 자식으로 수를 두게 되면 최소 5의 상태함수값을 얻고, 오른쪽 자식으로 수를 두게 되면 상대방이 최선의 수를 둘 경우 4(혹은 그 이하 - 아직 나머지 자식들에 대한 탐색이 끝나지 않았으므로 모르는 것이다)의 상태함수값을 얻게 되어, 왼쪽 자식으로 수를 두는 것이 더 낫다. 따라서 더이상 오른쪽 자식의 남은 자식들에 대해 탐색할 필요가 없는 것이다.</p>\n<h4>2. beta cut-off</h4>\n<hr>\n<p>(1)</p>\n<img src='http://pds27.egloos.com/pds/201212/12/23/d0091423_50c753d3207e2.png'>\n<p>1 -> 2 -> 3번 노드 순으로 진행한다.\n1번에서 13, 16 중에 작은걸 베타 값으로 갱신하여 13을 리턴하였고,\n2번 노드에서 알파 값을 13으로 바꾼다. 여기서 alpha >= beta가 되므로 beta cut-off가 일어난다.</p>\n<p>beta cut-off는 쉽게 말하면 <strong>\"현재의 경로는 우리가 아까 구해논 상대방 입장에서의 최적의 경로 값과 비교했을 때 내가 더 유리한 경로이다. 따라서 만일 상대가 항상 최선의 수를 택한다면, 현재의 경로를 택하진 않을 것이다(만약 상대가 현재의 경로를 택해 준다면 내가 유리해지니까 땡큐고). 따라서 우리도 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"</strong> 라는 논리이다.</p>\n<p>파란색 플레이어가 그림의 3번 노드에서 왼쪽 자식으로 진행하게 되면 7 이하의 상태함수값을 얻게 되고, 오른쪽 자식으로 진행하게 되면 최악의 경우 적어도 13의 상태함수 값을 얻게 된다. 따라서 파란색 플레이어 입장에서는 왼쪽으로 진행하는 편이 더 나은 것이고, 더 이상 나머지를 탐색할 필요성이 없어지는 것이다.</p>\n<h4>+ 예제</h4>\n<img src='https://t1.daumcdn.net/cfile/tistory/998EA7425AB214BD16'>\n<p>searching은 아래부터 시작한다. i부터 차례대로 depth-first searching을 한다고 가정한다.</p>\n<p>j가 4이므로 max단의 e에는 4이상의 숫자가 들어가게된다.</p>\n<ol>\n<li>\n<p>만약 k가 4보다 작다면?</p>\n<p>max단에서 k보다 큰 j를 선택하므로 k를 선택하지않는다.</p>\n</li>\n<li>\n<p>만약 k가 4이상이라면?</p>\n<p>max단의 e가 k를 선택하게된다. 그러나 d의 값이 e(=k)의 값보다 작은 2이므로 상위단인 b에서 e가 아닌 d를 선택하게되므로 똑같이 k로 갈 일이 없다.</p>\n</li>\n</ol>\n<p><strong>따라서 e -> k는 가지치기를 하게된다</strong></p>\n<p>(참고 - <a href=\"http://musicdiary.egloos.com/v/4274653\">http://musicdiary.egloos.com/v/4274653</a>)</p>","frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기","date":"April 04, 2022","update":null,"tags":["ai","inha"],"series":null},"fields":{"slug":"/alpha-beta-pruning/","readingTime":{"minutes":7.865}}},"seriesList":{"edges":[{"node":{"id":"1c0ade67-50d9-566d-8cdf-505bc94e9e30","fields":{"slug":"/1/"},"frontmatter":{"title":"git pull 오류 : fatal: refusing to merge unrelated histories"}}},{"node":{"id":"a18a1199-15b8-567b-b381-9877cb7e1482","fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},{"node":{"id":"dcd66e70-19bb-529a-93eb-a40dcda3967d","fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}}},{"node":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기"}}},{"node":{"id":"7f18986d-bd27-5ec2-9316-919595eca11b","fields":{"slug":"/6-2/"},"frontmatter":{"title":"os 6-2"}}},{"node":{"id":"3dfd35bf-9f06-57e0-8aae-bbe57bac7616","fields":{"slug":"/grid/"},"frontmatter":{"title":"그리드를 어떻게 그리드라"}}},{"node":{"id":"3e388686-2418-5776-a4f4-7d485967ad50","fields":{"slug":"/instance-flex/"},"frontmatter":{"title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때"}}},{"node":{"id":"35cb486b-c0aa-5492-bf01-368334b4e4d5","fields":{"slug":"/datamining/"},"frontmatter":{"title":"작성중"}}},{"node":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},{"node":{"id":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},{"node":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","fields":{"slug":"/8-1/"},"frontmatter":{"title":"os 8-1"}}},{"node":{"id":"3b144405-2ae5-5814-a3eb-f3db08d57801","fields":{"slug":"/auth-user/"},"frontmatter":{"title":"AUTH_USER_MODEL 사용"}}},{"node":{"id":"987ed322-774d-5a43-8f42-1899db096cad","fields":{"slug":"/10-1/"},"frontmatter":{"title":"os 10-1"}}},{"node":{"id":"a8468bab-91a9-5069-bc3f-049d1a5aceb9","fields":{"slug":"/env/"},"frontmatter":{"title":"SECRET KEY 환경변수에 숨기기"}}},{"node":{"id":"7eb19461-ddc3-5b03-ac5a-4fce46553994","fields":{"slug":"/11-1/"},"frontmatter":{"title":"os 11-1"}}},{"node":{"id":"2cebb9b3-24d4-5a97-9261-d7a2757ee845","fields":{"slug":"/11-2/"},"frontmatter":{"title":"os 11-2"}}},{"node":{"id":"641a26c1-7a3f-591a-9294-2b8a329ef9a6","fields":{"slug":"/list-comprehension/"},"frontmatter":{"title":"list comprehension"}}},{"node":{"id":"8e10d9c5-ccdf-5fb1-9389-4a7d2618115c","fields":{"slug":"/zip/"},"frontmatter":{"title":"zip"}}},{"node":{"id":"232934ea-695b-59c3-9933-f70434f65675","fields":{"slug":"/access-token/"},"frontmatter":{"title":"git access token ¹ß±Þ"}}},{"node":{"id":"4692c2dc-2ae0-58ba-92be-fc345d912b43","fields":{"slug":"/requests/"},"frontmatter":{"title":"python 라이브러리 requests"}}},{"node":{"id":"a49c908d-fe72-5ab8-aeca-835d60f50497","fields":{"slug":"/docker-concept/"},"frontmatter":{"title":"docker 개념"}}}]},"previous":{"fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}},"next":{"fields":{"slug":"/rest/"},"frontmatter":{"title":"REST"}}},"pageContext":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","series":null,"previousPostId":"dcd66e70-19bb-529a-93eb-a40dcda3967d","nextPostId":"86119087-6333-5ffe-a5f6-f42ab50e217e"}},"staticQueryHashes":[]}