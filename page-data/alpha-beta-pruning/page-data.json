{"componentChunkName":"component---src-templates-post-jsx","path":"/alpha-beta-pruning/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","excerpt":"Minimax Algorithm max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다. max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다. 위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때 max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다 min(파란색)단인 1 depth…","html":"<h3>Minimax Algorithm</h3>\n<hr>\n<p>max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다.</p>\n<p>max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다.</p>\n<img src='http://thumbnail.egloos.net/600x0/http://pds26.egloos.com/pds/201212/11/23/d0091423_50c73a317c0ed.png'>\n<p>위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때</p>\n<p>max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다</p>\n<p>min(파란색)단인 1 depth에서는 8과 7중 최소값인 7이 올란간다</p>\n<p>이것을 Minimax Algorithm이라고 하며, 가장 아래 depth부터 올라간다.(depth-first searching)</p>\n<h3>alpha-beta 가지치기</h3>\n<hr>\n<p>Minimax Algorithm을 할 때, searching할 필요가 없는 루트는 제거하는 방법이다.</p>\n<p><strong>Alpha</strong>는 max단에서 정해지는 값이고, <strong>Beta</strong>는 min단에서 정해지는 변수이다.</p>\n<p><strong>Alpha</strong> 는 이전(상위) 상태들 중에서 AI에게 가장 유리한 상태의 점수, <strong>Beta</strong> 는 이전(상위) 상태들 중에서 상대방에게 가장 유리한 상태의 점수이다.</p>\n<p><strong>Alpha cut-off</strong> 는 자신이 상대방보다 불리하여, 자신이 그 경우를 선택하지 않을 때 불필요한 연산을 잘라내는 것이고, <strong>Beta cut-off</strong> 는 자신이 상대방보다 유리하여, 상대방이 그 경우를 선택하지 않을 확률이 높을 때 불필요한 연산을 잘라내는 것이다.</p>\n<h4>1. Alpha cut-off</h4>\n<hr>\n<p>(1)</p>\n<img src='http://pds25.egloos.com/pds/201212/12/23/d0091423_50c74f11d7ffe.png'>\n<p>각각의 노드에 써있는 순서쌍이 (Alpha, Beta)라고 할 때</p>\n<p>재 1번으로 표시된 노드의 왼쪽 자식의 탐색을 끝냈고, 이제 2번 방향으로 진행해서 1번 -> 2번 -> 3번 -> 4번 노드 순으로 함수를 진행하고 있다고 생각해보자. 알파-베타 함수의 정의에 따라 부모 노드의 alpha, beta 값이 그대로 내려온다.</p>\n<p>위의 예에 대해 설명을 더 하자면, 1번 노드의 왼쪽 자식의 탐색을 끝내고 1번 노드의 알파 값이 5로 변경이 되었다. 이는, 1번 노드에서 현재까지 탐색된 경로들 중 최선의 경로를 선택해서 얻을 수 있는 최대값은 5라는 의미이다. 이제 2번 노드로 함수를 진행할 때, 1번 노드의 왼쪽자식으로부터 얻은 alpha 값을 넘겨주어 진행한다.\n3번, 4번 노드로 갈 때도 마찬가지.</p>\n<p>(2)</p>\n<img src='http://pds27.egloos.com/pds/201212/12/23/d0091423_50c7501f5a0f1.png'>\n<p>이제 5, 6, 7, 8번 노드 순으로 계속 진행한다.\n우선, 5번 노드의 하위 두 노드의 상태함수 값의 최소값은 4이므로 5번 노드의 베타값이 갱신이 되었다. 6번 노드의 알파값은 5이고, 5번 노드로부터 얻은 값 4와 비교해봤을 때 5가 더 크므로 6번 노드의 알파값은 변함없다. 7번 노드의 베타값은 6번 노드의 알파값인 5로 갱신되고, 이 때 alpha >= beta 가 되므로 alpha cut-off가 일어난다.</p>\n<p>alpha cut-off는 쉽게 말해서 <strong>\"현재의 경로는 우리가 이미 아까 구해논 최적의 경로 값과 비교했을 때 상대방에게 더 유리한 경로이다. 그렇다면 현재의 경로를 애초에 택하지 않고 다른 경로를 택하면 되므로, 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"</strong> 라는 논리이다.</p>\n<p>그림에서는 빨간색 플레이어가 8번 노드에서 왼쪽 자식으로 수를 두게 되면 최소 5의 상태함수값을 얻고, 오른쪽 자식으로 수를 두게 되면 상대방이 최선의 수를 둘 경우 4(혹은 그 이하 - 아직 나머지 자식들에 대한 탐색이 끝나지 않았으므로 모르는 것이다)의 상태함수값을 얻게 되어, 왼쪽 자식으로 수를 두는 것이 더 낫다. 따라서 더이상 오른쪽 자식의 남은 자식들에 대해 탐색할 필요가 없는 것이다.</p>\n<h4>2. beta cut-off</h4>\n<hr>\n<p>(1)</p>\n<img src='http://pds27.egloos.com/pds/201212/12/23/d0091423_50c753d3207e2.png'>\n<p>1 -> 2 -> 3번 노드 순으로 진행한다.\n1번에서 13, 16 중에 작은걸 베타 값으로 갱신하여 13을 리턴하였고,\n2번 노드에서 알파 값을 13으로 바꾼다. 여기서 alpha >= beta가 되므로 beta cut-off가 일어난다.</p>\n<p>beta cut-off는 쉽게 말하면 <strong>\"현재의 경로는 우리가 아까 구해논 상대방 입장에서의 최적의 경로 값과 비교했을 때 내가 더 유리한 경로이다. 따라서 만일 상대가 항상 최선의 수를 택한다면, 현재의 경로를 택하진 않을 것이다(만약 상대가 현재의 경로를 택해 준다면 내가 유리해지니까 땡큐고). 따라서 우리도 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"</strong> 라는 논리이다.</p>\n<p>파란색 플레이어가 그림의 3번 노드에서 왼쪽 자식으로 진행하게 되면 7 이하의 상태함수값을 얻게 되고, 오른쪽 자식으로 진행하게 되면 최악의 경우 적어도 13의 상태함수 값을 얻게 된다. 따라서 파란색 플레이어 입장에서는 왼쪽으로 진행하는 편이 더 나은 것이고, 더 이상 나머지를 탐색할 필요성이 없어지는 것이다.</p>\n<h4>+ 예제</h4>\n<img src='https://t1.daumcdn.net/cfile/tistory/998EA7425AB214BD16'>\n<p>searching은 아래부터 시작한다. i부터 차례대로 depth-first searching을 한다고 가정한다.</p>\n<p>j가 4이므로 max단의 e에는 4이상의 숫자가 들어가게된다.</p>\n<ol>\n<li>\n<p>만약 k가 4보다 작다면?</p>\n<p>max단에서 k보다 큰 j를 선택하므로 k를 선택하지않는다.</p>\n</li>\n<li>\n<p>만약 k가 4이상이라면?</p>\n<p>max단의 e가 k를 선택하게된다. 그러나 d의 값이 e(=k)의 값보다 작은 2이므로 상위단인 b에서 e가 아닌 d를 선택하게되므로 똑같이 k로 갈 일이 없다.</p>\n</li>\n</ol>\n<p><strong>따라서 e -> k는 가지치기를 하게된다</strong></p>\n<p>(참고 - <a href=\"http://musicdiary.egloos.com/v/4274653\">http://musicdiary.egloos.com/v/4274653</a>)</p>","frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기","date":"April 04, 2022","update":null,"tags":["ai","inha"],"series":null},"fields":{"slug":"/alpha-beta-pruning/","readingTime":{"minutes":7.865}}},"seriesList":{"edges":[{"node":{"id":"1f4e5238-73be-5807-a94c-f4de69b70d29","fields":{"slug":"/git1/"},"frontmatter":{"title":"git pull 오류 : fatal: refusing to merge unrelated histories"}}},{"node":{"id":"a18a1199-15b8-567b-b381-9877cb7e1482","fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},{"node":{"id":"dcd66e70-19bb-529a-93eb-a40dcda3967d","fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}}},{"node":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기"}}},{"node":{"id":"7f18986d-bd27-5ec2-9316-919595eca11b","fields":{"slug":"/6-2/"},"frontmatter":{"title":"os 6-2"}}},{"node":{"id":"3e388686-2418-5776-a4f4-7d485967ad50","fields":{"slug":"/instance-flex/"},"frontmatter":{"title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때"}}},{"node":{"id":"3dfd35bf-9f06-57e0-8aae-bbe57bac7616","fields":{"slug":"/grid/"},"frontmatter":{"title":"그리드를 어떻게 그리드라"}}},{"node":{"id":"35cb486b-c0aa-5492-bf01-368334b4e4d5","fields":{"slug":"/datamining/"},"frontmatter":{"title":"작성중"}}},{"node":{"id":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},{"node":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},{"node":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","fields":{"slug":"/8-1/"},"frontmatter":{"title":"os 8-1"}}},{"node":{"id":"3b144405-2ae5-5814-a3eb-f3db08d57801","fields":{"slug":"/auth-user/"},"frontmatter":{"title":"AUTH_USER_MODEL 사용"}}},{"node":{"id":"a1a1c386-4e12-55c0-b88e-b1ab29cfc979","fields":{"slug":"/sync-tools/"},"frontmatter":{"title":"os 10-1 Synchronization Tools"}}},{"node":{"id":"a8468bab-91a9-5069-bc3f-049d1a5aceb9","fields":{"slug":"/env/"},"frontmatter":{"title":"SECRET KEY 환경변수에 숨기기"}}},{"node":{"id":"85ca9819-7740-5d19-bde1-f1825944fb23","fields":{"slug":"/11-1/"},"frontmatter":{"title":"os 11-1"}}},{"node":{"id":"fe1864b8-839f-505a-8647-10db01ebd21a","fields":{"slug":"/11-2/"},"frontmatter":{"title":"os 11-2"}}},{"node":{"id":"641a26c1-7a3f-591a-9294-2b8a329ef9a6","fields":{"slug":"/list-comprehension/"},"frontmatter":{"title":"list comprehension"}}},{"node":{"id":"8e10d9c5-ccdf-5fb1-9389-4a7d2618115c","fields":{"slug":"/zip/"},"frontmatter":{"title":"zip"}}},{"node":{"id":"232934ea-695b-59c3-9933-f70434f65675","fields":{"slug":"/access-token/"},"frontmatter":{"title":"git access token 발급 잔디 테스트"}}},{"node":{"id":"4692c2dc-2ae0-58ba-92be-fc345d912b43","fields":{"slug":"/requests/"},"frontmatter":{"title":"python 라이브러리 requests"}}},{"node":{"id":"a49c908d-fe72-5ab8-aeca-835d60f50497","fields":{"slug":"/docker-concept/"},"frontmatter":{"title":"docker 개념"}}},{"node":{"id":"756b4f22-d300-58fe-8d33-fafc6ff511f6","fields":{"slug":"/docker-env/"},"frontmatter":{"title":"docker env설정(작성중ㅎㅎ)"}}},{"node":{"id":"254cabc8-767a-509a-8ac6-1b7c1fee5877","fields":{"slug":"/install-openssl/"},"frontmatter":{"title":"ubuntu에서 openssl 설치하기"}}},{"node":{"id":"7b7a0020-f454-5945-885b-8972512e0d8e","fields":{"slug":"/ssl-concept/"},"frontmatter":{"title":"ssl 인증서란?"}}},{"node":{"id":"d6ccffc2-7b03-5581-b29a-ac306dc06194","fields":{"slug":"/jupyter-setting/"},"frontmatter":{"title":"장고 shell 명령 주피터에서 할 때 초기세팅"}}},{"node":{"id":"9bf2c6c3-9f60-5a55-98d1-e060211c8163","fields":{"slug":"/sync-exam/"},"frontmatter":{"title":"os 10-2 Synchronization Examples"}}},{"node":{"id":"910aa000-d355-501d-a941-b234944b4fec","fields":{"slug":"/bash/"},"frontmatter":{"title":"bash: vi: command not found"}}},{"node":{"id":"4bec6f60-3a0e-5050-b6c4-1a9d7a232ba4","fields":{"slug":"/1/"},"frontmatter":{"title":"os 13-1"}}},{"node":{"id":"02483ae7-ba0a-5e03-aa72-19a907837984","fields":{"slug":"/2/"},"frontmatter":{"title":"os 13-2"}}},{"node":{"id":"ce978a60-290f-5fbb-b75d-f9ec9e6f57e2","fields":{"slug":"/1/"},"frontmatter":{"title":"os 12-1"}}},{"node":{"id":"bfc80393-1cd7-5fc8-bc04-e744783e77de","fields":{"slug":"/2/"},"frontmatter":{"title":"os 12-2"}}},{"node":{"id":"e41df5b8-30c6-54fe-88c9-1d212c70c9f4","fields":{"slug":"/15/"},"frontmatter":{"title":"os 14-2"}}},{"node":{"id":"d86a8175-8ed2-572f-9679-d8d2a48d0697","fields":{"slug":"/2/"},"frontmatter":{"title":"os 14-2"}}},{"node":{"id":"a8eb5fd5-89bd-592a-bbbd-81ff257715b2","fields":{"slug":"/1/"},"frontmatter":{"title":"os 14-1"}}},{"node":{"id":"b2e15c0a-3e85-5d09-bb9a-930a3af8456a","fields":{"slug":"/kr-str/"},"frontmatter":{"title":"[c++] 한글을 한 글자씩 출력하기"}}},{"node":{"id":"ad012487-5365-57df-8a83-b70be15aa316","fields":{"slug":"/arr-addr/"},"frontmatter":{"title":"arr과 &arr의 차이"}}},{"node":{"id":"5063006c-e0ec-58ad-bbd0-0e5f2ab7ad99","fields":{"slug":"/git2/"},"frontmatter":{"title":"git error: cannot lock ref 'refs/remotes/origin/main': unable to resolve reference 'refs/remotes/origin/main': reference broken 문제 해결"}}}]},"previous":{"fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}},"next":{"fields":{"slug":"/rest/"},"frontmatter":{"title":"REST"}}},"pageContext":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","series":null,"previousPostId":"dcd66e70-19bb-529a-93eb-a40dcda3967d","nextPostId":"86119087-6333-5ffe-a5f6-f42ab50e217e"}},"staticQueryHashes":[]}