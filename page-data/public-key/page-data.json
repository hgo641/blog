{"componentChunkName":"component---src-templates-post-jsx","path":"/public-key/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"540db76b-63f4-546a-bab2-98f6dc615676","excerpt":"Symmetric Encryption의 문제 어떻게 secure채널을 통해서 안전한 키를 전달하지? 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation - 자신이 보낸걸 부인할 수 없는 CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 - 나랑 이전에 키를 공유했던 그 사람이 맞…","html":"<h2>Symmetric Encryption의 문제</h2>\n<ul>\n<li>어떻게 secure채널을 통해서 안전한 키를 전달하지?</li>\n<li>전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation - 자신이 보낸걸 부인할 수 없는</li>\n<li>\n<p>CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 - 나랑 이전에 키를 공유했던 그 사람이 맞구나!</p>\n<blockquote>\n<p>만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : </p>\n<p>B가 CBC-MAC을 통해 받은 Ciphertext를 key로 복호화해서 A로부터받았음을 확인</p>\n<p>B가 법정에서 증거를 제출하려면 받은 Plaintext와 key와 MAC(Message Authentication)을 제공</p>\n<p>key는 secure하게 보관되어야하므로 A와 B만 가지고있다</p>\n<p>그러나 이 Plaintext가 정말 A가 보낸건지 B가 key를 사용해서 임의로 만든건지 구분할 수 없다</p>\n<p>즉, key가 최소 두 명이상한테 공유되었기때문에 누가 쓴건지 구별이 불가능하다.</p>\n<p>key는 single claimed sender를 가져야한다. 보낸이한테만 유일한 키</p>\n</blockquote>\n</li>\n</ul>\n<h2>Public-Key Cryptosystems</h2>\n<p><code class=\"language-text\">Plaintext</code> -> <code class=\"language-text\">Public key</code> -> <code class=\"language-text\">Encryption algorithm</code></p>\n<p><code class=\"language-text\">Ciphertext</code> -> <code class=\"language-text\">Private key</code> -> <code class=\"language-text\">Decryption algorithm</code></p>\n<ul>\n<li>키 분배 문제 해결</li>\n<li>전자서명 구현</li>\n</ul>\n<h3>Encryption with public key : 메세지를 숨기고 싶을 때</h3>\n<ul>\n<li>누구의 퍼블릭 키, 누구의 프라이빗 키인지가 중요하다</li>\n<li>Bob이 Alice에게 암호문을 보낼 때, Alice의 퍼블릭키를 사용해서 암호화</li>\n<li>Alice는 받은 암호문을 Alice의 프라이빗키를 사용해 복호화한다 </li>\n</ul>\n<blockquote>\n<p>키 분배 문제 해결 </p>\n<ul>\n<li>키 분배 문제 : 어떻게 key를 안전하게 교환할 것인가</li>\n<li>Public-Key는 A가 Key pair를 생성하면 공개키를 모두에게 공개</li>\n<li>굳이 안전하게 전달할 필요가 없음</li>\n</ul>\n</blockquote>\n<h3>Encryption with private key : 전자서명</h3>\n<ul>\n<li>Private key를 가지고 Encryption : 전자서명에 해당</li>\n<li>Encryption algorithm == Signature Generation</li>\n<li>Decryption algorithm == Signature Verification</li>\n<li>Bob이 Alice에게 암호문을 보낼 때, Bob의 Private key를 사용해서 암호화</li>\n<li>Alice는 받은 암호문을 Bob의 Public key를 사용해서 복호화</li>\n<li>서명을 해서 보냄. 받아서 복호화한 Plaintext와 서명이 잘 맞아 떨어진다면 중간에 오류나 변조없이 도착한 것임 : Integrity 보장</li>\n<li>Bob의 Privae key를 통해서 온 것이므로 nonrepudiation 해결</li>\n</ul>\n<h3>Conventional and Public-Key Encryption</h3>\n<ul>\n<li>conventional : 전통적인 (= Symmetric)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Conventional Encryption</th>\n<th align=\"center\">Publick-Key Encryption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">같은 알고리즘이 <strong>같은 키</strong>와 사용된다 (AES같은 경우엔 완전히 같진않고 역연산)</td>\n<td align=\"center\">두 개의 키가 존재한다 하나는 Encryption에 다른 하나는 Decryption에 사용</td>\n</tr>\n<tr>\n<td align=\"center\">보내는 사람과 받는 사람이 알고리즘과 키를 공유한다</td>\n<td align=\"center\">알고리즘은 서로 공유하나 보내는 사람과 받는 사람이 같은 키가 아닌 키 pair를 사용한다</td>\n</tr>\n<tr>\n<td align=\"center\">대칭 암호에서는 키가 안전하게 유지되어야한다</td>\n<td align=\"center\">공개키는 안전하게 전달 될 필요가 없다</td>\n</tr>\n<tr>\n<td align=\"center\">키가 안전하게 유지되고 있다면 메세지를 키 없이 복호화하는게 어렵다</td>\n<td align=\"center\">키 중에 하나가 (Private Key)가 안전하게 유지되고 있다면 메세지를 복호화하는게 어렵다</td>\n</tr>\n<tr>\n<td align=\"center\">알고리즘을 알고 Cipher text를 몇개를 알아도(암호문쌍) 어떤 키가 사용됐는지 알아내는게 어렵다</td>\n<td align=\"center\">알고리즘을 알고 공개키하나도 알고 Ciphertext(암호문쌍)을 알아도 private key를 알아내긴 어렵다</td>\n</tr>\n</tbody>\n</table>\n<h3>Public-Key Cryptosystem</h3>\n<ul>\n<li>Authentication and Confidentiality</li>\n<li>Source A, Destination B 일 때</li>\n<li>\n<ol>\n<li>A가 자신의 Private key를 가지고 서명</li>\n<li>A가 B의 Public key를 가지고 암호화</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>B가 자신의 Private key를 가지고 복호화</li>\n<li>B가 A의 Public key를 가지고 A가 맞는지 확인</li>\n</ol>\n</li>\n</ul>\n<h4>Public-key cryptosystems can be classified into three catagories:</h4>\n<ul>\n<li>Encryption/Decryption</li>\n<li>Digital Signature</li>\n<li>\n<p>Key exchange</p>\n<ul>\n<li>공개키 쓴다고 symmetric 암호 안쓰는 건 아님</li>\n<li>공개키암호는 속도가 느림</li>\n<li>대용량 암호를 공유할 때 불편. 공개키암호와 대칭암호를 함께 사용</li>\n</ul>\n</li>\n</ul>\n<h4>Public-Key Requirements</h4>\n<p>공개키 암호의 요구사항</p>\n<ul>\n<li>수신자가 키 페어를 만들기 쉬워야함</li>\n<li>퍼블릭 키와 메세지를 사용해서 ciphertext를 만드는 일이 쉬워야함</li>\n<li>프라이빗 키와 cipher text를 사용해서 plaintext로 만드는 일도 쉬워야함</li>\n<li>퍼블릭 키를 알고있어도 프라이빗 키를 추측하는건 어려워야함</li>\n<li>퍼블릭 키와 ciphertext를 알아도 private key없이 plain text를 추측하는건 어려워야함</li>\n</ul>\n<h2>RSA(Rivest-Shamir-Adleman) Algorithm</h2>\n<blockquote>\n<p>글을 숫자 형태로 표현하는게 전제</p>\n<p>어떤 정수 n을 모듈러로 사용해서</p>\n<p>0 to n-1까지의 정수들을 plaintext의 메시지라고 간주한다.</p>\n</blockquote>\n<br/>\n<ul>\n<li>PU = {e, n}</li>\n<li>PR = {d, n}</li>\n<li>암호화는 e를 사용해서, 복호화는 d를 사용해서 함</li>\n<li>두 개다 mod n을 사용해야함. n은 권장사항이 2048 bit이상이며 보통 3072, 4096사용</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/c04c8/rsa-enc-dec.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 21.764705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAx0lEQVQY0zVP2QKCMAzj/z/NA0HlchMYGwhMBl7PsZ34kC1tk3QLKtEh2gkcNgXSY4VTKHGOSkTbCw6EeC98PyZ+DK8EiYxq7mVnBZFpyMIgO9UwyiKo5c2LkvgXFnFAXCJfxXmivEHmBpe0QafveMwf2H7BZJ9w9rXehPsLAQ8f7kMGDZFqH8rb+3aCrkcf0DYWQ+eg1ehfYaheyLNM7x/cCuLBTAdvMWS+tQ6q7H0Q19eiRVMOqOgXHFrTjDlr2Dyv+Acz/wIN6SPMmISt9gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='rsa enc dec' title='rsa enc dec' src='/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/ca1dc/rsa-enc-dec.png' srcset='/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/e7570/rsa-enc-dec.png 170w,\n/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/f46e7/rsa-enc-dec.png 340w,\n/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/ca1dc/rsa-enc-dec.png 680w,\n/blog/static/3c2c3aa1930ad8c820c0ed4dad5ed4ea/c04c8/rsa-enc-dec.png 726w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>지수연산 사용</p>\n<ul>\n<li>plaintext는 M이라는 숫자로보고</li>\n<li>ciphertext는 C라는 숫자로 본다</li>\n</ul>\n</blockquote>\n<h3>Algorithm Requirements</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/e2cf83e641ac0b009b3836d29192c8be/d7258/algorithm-req.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 56.470588235294116%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACM0lEQVQoz1WT2ZLaMBBF5/+/KKmaJAUhw4ABm0XG2MayvMorNtgzydNNSyYPeehSa6kj3dutl64eUWQ3ZHGDJKymUVSIeIGURpm0yGlNnYl5SWdK5EkDmbZIo0qvB16m5/fbB15uBGT7AIedD3PjYrM6Y/7dxHZ1wfr9gp3hYblgMGl/MTvAWLlYLc/YrB3KHbz/YjiYV7qkRa+AimppkAPTuBDI0TD1usxPKFJERw/JmYNbLmLmI2QBIjdGQnsxKemaEUP/W48E/ESZdyjSSZbKK9nr5w/lDfesxhBlGHyOMRB4OB5GHmFwXAyuj0GS1CesbxWw+8TQPFBHhfbNPoRkAYf5doKzc8FYBPuS4UhrzPThMAGb1uJAoidYVz8I9PGMcZKsJg8Ci6uE5yRwjiH8pQWxMODNDfAtQzhbwl3u4fsS9puFaMdQyw5KoQL9B1Rxqx6oip6kt1TZBil5VJ4DSPKsPF9RUEieIyPzH1WPMc61svH+R/unCtIpoEqUbHWba7qwDRvbrwtYr28w5ybsn1scZhscvr3D+rGGMbOoTXKIqEEc1RDUSjn537XDBPwnWd1SugLSDZE4AmWQ6p6rvEjPcyeEvKZIg1x3gFBV9hLEXqp7sGufRZle+KGrm4QFriwEZxyO6SGgkdvk596Dd+QQ1gXxl1f465Nuo1DtU7RxqW2bJD/JTXlHldQoQ4lSkAx6SUF5IaT2rqDLKsoL84Sc05mEfgmfztyyRjO6ZsBfDcIjZzdPLB4AAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='algorithm req' title='algorithm req' src='/blog/static/e2cf83e641ac0b009b3836d29192c8be/ca1dc/algorithm-req.png' srcset='/blog/static/e2cf83e641ac0b009b3836d29192c8be/e7570/algorithm-req.png 170w,\n/blog/static/e2cf83e641ac0b009b3836d29192c8be/f46e7/algorithm-req.png 340w,\n/blog/static/e2cf83e641ac0b009b3836d29192c8be/ca1dc/algorithm-req.png 680w,\n/blog/static/e2cf83e641ac0b009b3836d29192c8be/d7258/algorithm-req.png 966w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ol>\n<li>M은 평문의 글을 나타내며, n보다 작은 모든 M에 대해 위 수식을 만족해야한다</li>\n<li>복호화, 암호화 계산이 어렵지않아야한다</li>\n<li>e와 n이 주어졌을때 d를 추측하기 어려워야한다</li>\n</ol>\n<br/>\n<h3>예시</h3>\n<p> ex ) Bob -> Alice에게 암호문을 보낼 때</p>\n<h4>Key Generation by Alice</h4>\n<ul>\n<li>소수인 p와 q를 임의로 뽑는다 (p와 q는 다른 수)</li>\n<li>n을 구한다 : n = p x q</li>\n<li>\n<p>오일러 n을 구한다. </p>\n<ul>\n<li>n은 p x q이므로 오일러 n은 (p-1)(q-1)이다.</li>\n</ul>\n</li>\n<li>임의로 e를 뽑는다. (e는 오일러(n)과 서로소여야함, e는 오일러 n보다 작고 1보다 큼)</li>\n<li>이후 구할 d때문. (d는 모듈러 오일러n일때 e의 곱셈의 역원임) </li>\n<li>즉, e x d = 1 mod 오일러(n)</li>\n<li>\n<p>Extended Euclid를 사용해서 d까지 구하면 퍼블릭키와 프라이빗키 생성 완료!!</p>\n<ul>\n<li>PU = {e, n}, PR = {d, n}</li>\n</ul>\n</li>\n</ul>\n<h4>Encryption by Bob with Alice's Public Key</h4>\n<blockquote>\n<p>Plain text = m, m은 n보다 작은 숫자의 범위</p>\n</blockquote>\n<ul>\n<li>C = M^e mod n</li>\n</ul>\n<h4>Decryption by Alice with Alice's Private Key</h4>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/3ee8a281b7266d96e0200c9a71c4f474/994d6/enc_dec.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.35294117647058%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAADAUlEQVQ4yy1T2W7TQBTN//8CEhISEjwgxKJCFyduktoT24m38XiPszUQ2jSx2wASQjocmz6MruVrHZ9tenk2h+/78F0XiechEibs8QjW8BpGX4O4OMdsOoXLnZSyO2GgIP0It9UG2+UW29UWO85dnKNX5guE7gyedolC11AZI5TVAvOyQJrECFsA24J0bKRxjDRNEUcpxGiCkTaEpd9gdKVjeHWNjUzQK1qGYYCZaUJ9/gApDERRhCRJkBUFivbkOXLO9iRZBtcQEJ/OMLvsIzy/gBIOtpt7nB7/EDCvOsm2bUNeXSAbXSMxb5ApgjoW1HiIzBKI+U3kuYhjhYhyPU2H7OtwCarGArvtvjsdYBCGBLSQ6n2sWtkTE8vRAOnZRwQf38PjT1owxZNQtu9FcAwHglLNSx1lWtGGHJvV7pkhTbfGY5SUuxxcYaGdY2mOkV5+RTDQEHCfUnY5n5NhjBXD+H36izvadV8sGcg3bLIFHu4a9NqUPceBfXODKAg6BjE9zchaXXyBRxs6ZmnW7dqUl+UKTzMPj7sDnn4c0YQRHvePqA8/0avKNQJ6IqVCGCrKZ7JBhNAPId0AcuYj9MLuneTe8yU2ZHgiSM1Zsy41VdaHX6gfTv9TbhNNycBlMIauYzLow9YHsM8+Y8pj9PuQ7GFO2cnMYT1iPBGkma/RrHdoKLXZn54BuVBM1KHshLNgijm7VrKD1asXqF6/xHw2RcFd5VM67VgtyHD9HTVlN2TcrPhMBcft/XOxgxCmKRBwplmOOElZ4gTl2SdEb14je/cWFf2M6WsgIwLe4rR/Qk0L6mKB+vYOzcNPHFuGZb5kDwOWWcGxpxAsrSUsWBMLEz7bYgJb0+ANR/Q5hktWa6Z6YiBH+l4zoI7h9g5H/uS/h2lCdgFcynZ5Y3xOL/Dh8l5L00DIu6149coshWpr0zJsfaPMpqKPtz9Qb3Zk2AFWkJGEEKL7uCjLzvz2uhXXfSQMKDfGnY8Z3ymlsJiT1fE39t8POLA2x92xmwdK/gfyE9GAGSrJ9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='enc dec' title='enc dec' src='/blog/static/3ee8a281b7266d96e0200c9a71c4f474/ca1dc/enc_dec.png' srcset='/blog/static/3ee8a281b7266d96e0200c9a71c4f474/e7570/enc_dec.png 170w,\n/blog/static/3ee8a281b7266d96e0200c9a71c4f474/f46e7/enc_dec.png 340w,\n/blog/static/3ee8a281b7266d96e0200c9a71c4f474/ca1dc/enc_dec.png 680w,\n/blog/static/3ee8a281b7266d96e0200c9a71c4f474/02d09/enc_dec.png 1020w,\n/blog/static/3ee8a281b7266d96e0200c9a71c4f474/994d6/enc_dec.png 1093w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>\n<p>C^d mod n == (M^e mod n)^d mod n</p>\n<ul>\n<li>M^ed mod n</li>\n<li>e x d = 1 mod 오일러n이었음</li>\n<li>즉, (ed = k x 오일러(n) + 1) : d는 e의 곱셈의 역원</li>\n</ul>\n</li>\n<li>(  (M^오일러(n))^k  x  M )mod n</li>\n</ul>\n<blockquote>\n<p>오일러 이론에 의해 (M^오일러(n))^k 는 1이 된다</p>\n</blockquote>\n<ul>\n<li>\n<p>M mod n = M </p>\n<ul>\n<li>M이 n보다 작으므로 </li>\n</ul>\n</li>\n</ul>\n<h4>Example of RSA Algorithm</h4>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/0c139/example.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 70%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGklEQVQ4y0WT2W/bRhCH+bf3sWjRpgngJE6i3AHahzjw7cSyrcOkeFkkJVEndVL3LcWukaJfh0zRPvzA4czut3PsKkd/BLzftUQmbx+bvHykknh4zbunFh92bd481mPfi9+ysub//zc7Bs/F9/xBhtc7OX5POBwLS9n/0BCQzbNfswLSePJTip0fL8XOCUTj3ZOb2P/05zSJR7r4VH754UTWXImdi/9fPPi+LmIpeirESPcxMkN0UWRb2QFWZoD5r6zskBt1hH39/RvHRTfqkLw2Eo3jmJkOUWaTOdVajZZfpHJj43oeXqFAtV6n2QzodXvU61V8iXueS6Hg4roO5bJP0GwwCAds13dsll9Zi5ThcIJpGHhXlzSOD6ioWYqOg6/nqPhlgQXouo7juAL1BVjAtm2KxWJsN4M268Udy9lXFtMtyng4xbQsCqfHtE4OqegaXk6jJMCyAJrNdrzZcz3JzI2Vz+clW4+SX6LbDiU7Ac4FOBPgSIC6bC4JKDB12ehiyAFFgZUrFRqNAMsy46yiUiOYaRox2Bdgq9n5L8NI0sMlQaNFp9sn7I/odnpyao+wG9IPhwzEVynX4tJ6nZCOxIJGk3arK+owHkxjYFTuYrpBud1+4/72b5biaAUyYcNBzRrk7QL97pjpeMXd9i8p608mwyXlUh1dtUhfqdQrLYbhNC71dvMtXqMEtQ7VcpNioYKeTmMnkxipFLqmoaoahm5TcMr4BQHlTDTxR4oGFUlVVdpBj6ofELGUqlMid3aBYeRJJXY5eP2Ko/dvuXiV4OLTHpZm4uZ9Sl6VTDrL4eEBex8/8mlvj/39fc7OznCFkUlp1CQxZSvT2QwXci2KpE5PSR4dkhRQ+vSEyy+fsc0btqt76dU8Bl5K9l/OzzmReCqdIikVNRtdVvPbeNLKShq6Xd/LIPq4dh7rPIklGz0nuiYyxaAbx6MJVssNHDUnL+IaW8ovStwTTUYLudR3zKOhrIQa0afhhEDVaX0+pyalbHojNtLotcRmkzXRwf1SjWoqS+UqIw/AYNufsllFh22ZTdcCXPMPN2vG6ho/DzIAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='example' title='example' src='/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/ca1dc/example.png' srcset='/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/e7570/example.png 170w,\n/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/f46e7/example.png 340w,\n/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/ca1dc/example.png 680w,\n/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/02d09/example.png 1020w,\n/blog/static/2068701c59ad7ada0e5e3bd73cd7b641/0c139/example.png 1081w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>p = 11, q = 17</p>\n<p>n = p x q = 187</p>\n<p>∮(n) = (p-1)(q-1) = 160</p>\n<p>e = 7 (160과 서로소인 수)</p>\n<p>d = 23 ( e*d를 mod 160했을 때 1이 나옴. d는 e의 곱셈의 역원)</p>\n<ul>\n<li>plaintext는 n(187)보다 작은 숫자</li>\n</ul>\n</blockquote>\n<h3>Dealing with Long Message</h3>\n<ul>\n<li>128bit단위로 잘라서 블록 단위로 암호화했었음</li>\n<li>RSA에선?</li>\n</ul>\n<blockquote>\n<ol>\n<li>마찬가지로 M을 쪼개서 블록단위로 암호화</li>\n<li>\n<p>하이브리드 encrypiton</p>\n<ul>\n<li><strong>Data encryption</strong> : src가 랜덤한 키를 만들어서 M을 나눈 블록에 대해 K를 사용해서 암호화 시킴 (블록 암호화)</li>\n<li><strong>Key encapsulation</strong> : K는 메시지라고 간주해서 메시지를 암호화해서 보내는 것 처럼 같이 보냄 (K^e mod n)</li>\n<li>dest는 받은 메시지와 키를 가지고 메시지를 키로 암호화해서 평문으로 복호화 가능</li>\n</ul>\n</li>\n</ol>\n</blockquote>\n<h3>RSA Signature</h3>\n<blockquote>\n<p>Decryption : Signature generation</p>\n<p>Encryption : Signature Verification</p>\n</blockquote>\n<ul>\n<li>\n<p>Alice 가 Bob에게 보낼 때 Alice가 자신의 private key로 Signature generation을 한다. (M, S)를 전달</p>\n<ul>\n<li>M은 메시지</li>\n<li>S는 서명한 M ==  (M^d mod n)</li>\n</ul>\n</li>\n<li>\n<p>Bob 은 받은 S를 Alice의 public key(e)를 사용해서 Signature Verification을 한다</p>\n<ul>\n<li>S ^ e mod n == (M^d mod n)^e mod n == M^de mod n == M</li>\n</ul>\n</li>\n</ul>\n<h3>Left to Right binary</h3>\n<p><strong>Square and Multiply라고도 불림</strong></p>\n<p>지수승 계산</p>\n<p>a^b mod n</p>\n<blockquote>\n<p>암호화할때는 b가 e가 되고, 복호화할 때는 b가 d가 된다</p>\n</blockquote>\n<p>예제 a=7, b=560, n=561</p>\n<blockquote>\n<p>c = 2c와 c = c+1은 편의상의 코드 (없어도 됨)</p>\n<p>f = fxf와 f = fxa를 수행한다</p>\n<p>f는 a의 c제곱 mod n을 의미</p>\n</blockquote>\n<ul>\n<li>\n<p>for k부터 0까지 루프를 돈다</p>\n<ul>\n<li>k는 b의 비트수 (bk ~ b0)</li>\n<li>예제의 경우 bit수가 10개이므로 k는 9~0</li>\n</ul>\n</li>\n<li>\n<p>c는 현재 a의 몇 제곱인지를 알려줌(10진수). </p>\n<ul>\n<li>b의 bit를 10001까지 수행했을 경우 10001은 10진수로 17 = c </li>\n<li>결과값에는 영향을 주지 않음. (지워도 상관없음. 이해를 돕기위한 값)</li>\n</ul>\n</li>\n<li>f의 initial은 1</li>\n<li>f는 (a의 bi제곱 mod n)을 의미</li>\n<li><strong>f는 일단 제곱을 무조건 시킴</strong>  + (c = cx2)</li>\n<li>\n<p>해당 bit인 bi가 1일 경우</p>\n<ul>\n<li>c = c+1</li>\n<li>f 에 a를 곱함</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>운이 좋을 경우 (1000000)</p>\n<p>: 제곱만 수행 (곱셉 연산 한 번)</p>\n<p>운이 나쁠 경우 (1111111)</p>\n<p>: 제곱과 곱하기를 수행 (곱셈 연산 두 번)</p>\n<p>지수 e가 2048일 경우</p>\n<p>즉, 총 log2 n ~ 2log2n 의 연산을 수행</p>\n<ul>\n<li>운이 나쁘면 연산 두 개를 하므로 두 배</li>\n<li>즉, (2048 ~ 4096)</li>\n<li>평균적으로 3/2 log2n (3072)</li>\n</ul>\n<p>만약 이렇게 로그에 기반해서 연산안하고 바로 a x a x a x ...a 했다면 2^2048번의 연산을 수행해야한다고함</p>\n</blockquote>\n<h3>Efficient Operation Using the Public Key</h3>\n<p>근데 저렇게 해도 숫자가 너무 커서 오래걸림</p>\n<p>그래서 e를 2^16 +1로 고정(어차피 public key라 고정해도 상관없음)</p>\n<ul>\n<li>17bit - 맨 앞과 맨 뒤만 1이고 나머지는 0</li>\n<li>제곱 15번, 곱셈 2번 (위의 2048보다 훨씬 줄어듦)</li>\n</ul>\n<p>2^16 +1하면  제곱 16번 + bit 1인게 두개라서 2번 곱셈</p>\n<p>가끔 3이나 17같은 엄청 작은 숫자를 쓰기도 하나 공격에 취약할수도있음</p>\n<p><strong>d는 프라이빗이라 고정해놓으면 안됨</strong></p>\n<h3>Attack against RSA</h3>\n<ul>\n<li>\n<p>Brute force</p>\n<ul>\n<li>d에 모든 값 대입 </li>\n<li>2048가지의 경우 존재 너무 오래걸림</li>\n</ul>\n</li>\n<li>\n<p>Mathematical attacks</p>\n<ul>\n<li>소인수 p와 q의 쌍을 구하려함</li>\n</ul>\n</li>\n<li>\n<p>Chosen ciphertext attack</p>\n<ul>\n<li>RSA의 구조적인 특성을 이용한 공격</li>\n<li>homomorphic 특성 이용</li>\n</ul>\n</li>\n<li>\n<p>Implementation attacks</p>\n<ul>\n<li>하드웨어적 구현상의 문제</li>\n<li>수행하는데 걸리는 시간, power, cache</li>\n</ul>\n</li>\n</ul>\n<h3>Factoring Problem</h3>\n<ul>\n<li>n으로 p, q두 쌍을 구할 수 있으면 RSA는 깨짐 - n을 p, q로 factoring</li>\n</ul>\n<blockquote>\n<p>1999년에 실제 RSA에서 쓰는 512bit까지 팩토링 할 수 있게됨</p>\n</blockquote>\n<h2>Chosen Ciphertext Attack (CCA)</h2>\n<ul>\n<li>공격자가 Plain text와 Cipher text의 쌍을 알 때 private key없이 어떤 Cipher text의 Plain text를 추측할 수 있는 것</li>\n<li>공격자가 어떤 C에 대한 P를 물어봐서 P를 얻어냄</li>\n<li>이를 바탕으로 또 다른 C를 물어보지않고도 P를 추측하면 공격자가 성공했다고 판단</li>\n<li>우리가 앞에서 봤던 rsa(textbook rsa)는 이런 공격법에 취약. </li>\n<li>\n<p>ex</p>\n<blockquote>\n<p>C의 P를 구하고자 할 때</p>\n<p>C' = C x 2^e mod n</p>\n<p>C'의 P를 요청함</p>\n<p>P' = C'^d mod n =  (C x 2^e)^d mod n = C^d x 2 mod n</p>\n<p>즉 C의 P는 P'에 2의 역원을 곱하면 된다</p>\n</blockquote>\n</li>\n</ul>\n<p>이런 공격을 방지하기 위해 RSA에 특별한 구조를 넣게 되어있음 RSA Security- OAEP</p>\n<p>안전성때문에 RSA-OAEP 사용</p>\n<h3>OAEP(Optimal Asymmetric encryption padding)</h3>\n<blockquote>\n<p>원래는 M에 e제곱을 해서 암호화를 했지만 OAEP에서는 M을 인코딩한 EM을 e제곱한다</p>\n</blockquote>\n<p>인코딩방법</p>\n<ul>\n<li>M에 0을 쭉 채워넣은 패딩을 추가</li>\n<li>파라미터를 해쉬함 (파라미터는 공개됨)</li>\n<li>해시 + 패딩 + M을 더해서 데이터블록생성</li>\n<li>암호할때마다 매번 생성하는 랜덤 시드를 MGF돌림(MGF도 해시함수의 일종)</li>\n<li>MGF한 seed와 DB를 xor연산</li>\n<li>DB에 위의 MGF가 아닌 또 다른 MGF를 돌린후 seed와 xor해서 maskedseed를 얻는다</li>\n<li>maskedseed + maskedDB 형태인 EM획득</li>\n</ul>\n<p>복호화 방법</p>\n<blockquote>\n<p>암호문을 복호화하면 EM이 나옴</p>\n<p>EM의 형식이 맞는지 체크하는 과정이 있음</p>\n</blockquote>\n<ul>\n<li>EM을 파싱해서 앞부분과 뒷부분으로 나눔(maskedseed + maskedDB)</li>\n<li>\n<p>maskedDB에 해시함수 적용</p>\n<ul>\n<li>해시함수는 모두에게 공개됨</li>\n</ul>\n</li>\n<li>maskedseed와 해시함수를 적용한 maskedDB를 xor해서 seed값을 얻는다</li>\n<li>xor과 MGF로 DB도 얻는다</li>\n<li>\n<p>파라미터를 해시함수로 돌려서 DB의 앞부분이 나오는지 확인</p>\n<ul>\n<li>MAC(Message Authentication)과 유사</li>\n<li>정상적인 구조인가 확인</li>\n<li>공격자가 만든 임의로 조작된 Ciphertext였다면 인증이 안됨</li>\n<li>임의로 조작됐다면 파라미터를 해시함수 적용했을때 원하는 값이 안나옴</li>\n<li>이럴 땐 Decryption 결과 안돌려줌</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>그 외 장점</p>\n<p>랜덤 시드값을 사용하므로 같은 M이라도 다른 결과가 나옴</p>\n<p>이전 M의 쌍을가지고 추측이 어려움</p>\n</blockquote>\n<h2>Side Channel Attack</h2>\n<p>implementation attack의 하나</p>\n<p>알고리즘을 실행시키고있는 기계 자체를 공격</p>\n<p>알고리즘을 실행하면 기계에서 부수적인 정보가 나옴</p>\n<ul>\n<li>\n<p>Timing attack : 누군가 private key를 가지고 연산을 하고있을 때 private key에 따라 연산 시간이 달라질수도있다</p>\n<ul>\n<li>C^d mod n 할 때  앞에서 비트 값이 0이면 제곱만, 1이면 제곱+곱셈연산 수행</li>\n<li>연산 시간에 따라 1인지  0인지 추측 가능</li>\n</ul>\n</li>\n<li>\n<p>Power analysis : 전력 소모의 패턴을 분석. 제곱연산할때의 전력소모와 곱셈 연산을 할 때 전력소모를 구해서 분석. (전자기파 분석, 클라우드 분석)</p>\n<ul>\n<li>1이면 S M , 0이면 S</li>\n</ul>\n</li>\n<li>\n<p>Cache</p>\n<ul>\n<li>논리적인 자원은 분리되어있지만 물리적인 자원은 분리되어있지않음</li>\n<li>캐시가 어떤 형태로 플래쉬되는지 패턴을 통해 추측가능</li>\n</ul>\n</li>\n</ul>\n<p><br/><br/></p>\n<p>어떻게 막나?</p>\n<h3>Constant-time algorithm</h3>\n<ul>\n<li>알고리즘을 비트가 0이냐 1이냐에 따라서 바뀌지않게 만든다</li>\n<li>M을 항상 하게 바꿈</li>\n<li>f x f 연산 결과값을 f에넣지않고 x[0]또는 x[1]에 넣는다</li>\n<li>1이냐 0이냐에 따라 X[0] or X[1] 반환</li>\n<li>비트가 0이든 1이든 항상 곱셈을 수행한다.</li>\n<li>시간이 더 오래 걸리긴 함(필요없는 M도 하게 되어서)</li>\n<li>시간분석 대응가능. 일정한 시간 소요</li>\n</ul>\n<h3>Fault-Based Attack</h3>\n<p>좀 더 공격적</p>\n<p>아까는 공격자가 그냥 관찰만</p>\n<p>연산이 수행되는 와중에 강력한 전압을 걸어주는등의 공격을 해서 오류가 생기게</p>\n<p>(ex) 내 버스카드에 물리적으로 충격을 걸어서(전압공격등) 잔액정보를 마음대로 조작~~)</p>\n<h3>Misconceptions Concerning Public-Key Encryption</h3>\n<ul>\n<li>공개키 알고리즘은 암호 공격에 대해서 시메트릭 암호보다 안전하다</li>\n</ul>\n<blockquote>\n<p>맞을수도있고 틀릴수도있음</p>\n<p>AES 128비트 버전과 RSA 2048 어떤게 더 안전할까?</p>\n<p>RSA가 시도할 경우의 수가 더 많음</p>\n<p>그러나 이렇게 무작위로 하지않음</p>\n<p>팩토링을 사용하면 효율적으로 가능. AES보다 더 빠르게</p>\n<p>공격할 방식 자체가 다르기 때문에 맞을수도있고 틀릴수도있음</p>\n</blockquote>\n<ul>\n<li>\n<p>공개키 알고리즘이 대칭 알고리즘을 완벽하게 대체할 수 있는 알고리즘이다</p>\n<p>x : 성능 측면에서 대칭 알고리즘이 훨씬 유리</p>\n<p>키 공유 문제에선 공개키 알고리즘이 유리</p>\n<p>보통 둘 다 사용하는 하이브리드 알고리즘 사용</p>\n</li>\n<li>\n<p>대칭 암호의 키공유문제를 해결하기 위해 나온게 공개키 알고리즘 : 공개키 암호를 쓰면 키 분배를 하는데 전혀 문제가 없을까?</p>\n<p>x : 상대적으로 대칭 암호에 비해 키 공유가 나은 것이지 근본적으로 해결되는 것은 아니다</p>\n<p>시메트릭 : 키를 안전하게 전달하는 것이 목표</p>\n<p>퍼블릭키 : 키를 숨기면서 전달할 필요가 없음. </p>\n<p>대칭 암호에서의 키 분배는 confidentialiry</p>\n<p>퍼블릭키는 authentication과 Integrity 보장해야함</p>\n<p>공격자가 다른 사람의 공개키인척 공유하면 안됨</p>\n<p>이런 문제때문에 공개키 인증서가 나옴</p>\n<p>정부에서 공인된 절차로 만든게 공인인증서</p>\n</li>\n</ul>\n<p>RSA에서 Factoring과 Discrete Logarithm(이산대수)이 중요하다...</p>","frontmatter":{"title":"9-2","date":"May 01, 2022","update":null,"tags":["computer protection"],"series":"컴퓨터 보안"},"fields":{"slug":"/public-key/","readingTime":{"minutes":21.425}}},"seriesList":{"edges":[{"node":{"id":"e4acbdfb-722b-57a9-80ae-d895e0db1293","fields":{"slug":"/access-control/"},"frontmatter":{"title":"1-2 Access Control"}}},{"node":{"id":"4a6f8d90-3618-56c6-8559-879e5ecc9bf4","fields":{"slug":"/number-theory/"},"frontmatter":{"title":"2-2 Number Theory"}}},{"node":{"id":"0bd2f3a2-2ebf-58a4-b9b1-3362f3eb162d","fields":{"slug":"/osi-structure/"},"frontmatter":{"title":"1-1 OSI 보안 구조"}}},{"node":{"id":"c09c6352-565d-5712-bd74-a03fc2d175a7","fields":{"slug":"/cia-aa/"},"frontmatter":{"title":"1-1 컴퓨터 보안의 요구 조건 (CIA + AA)"}}},{"node":{"id":"7e8ccf0c-4d31-5ed5-834d-372268de637e","fields":{"slug":"/aes-process/"},"frontmatter":{"title":"5-2 AES Process"}}},{"node":{"id":"c18d6769-2773-5438-80d8-71766e893de4","fields":{"slug":"/cp-danger/"},"frontmatter":{"title":"4-1 다양한 보안 위협"}}},{"node":{"id":"31a7ca0e-a91b-5b21-90ba-72df9a459e48","fields":{"slug":"/multi-enc/"},"frontmatter":{"title":"6-2 Modes of Operation"}}},{"node":{"id":"dc9ea5bb-374d-534c-a413-adc23222b506","fields":{"slug":"/symmetric-cipher/"},"frontmatter":{"title":"3-2 Symmetric Cipher Model (고전 암호)"}}},{"node":{"id":"9a54b7cc-4a15-5b76-8fac-388d5b9e7d11","fields":{"slug":"/pseudo-random/"},"frontmatter":{"title":"7-2 난수 생성"}}},{"node":{"id":"81096a32-03d0-5672-bd39-ceaaefef6160","fields":{"slug":"/web-hack/"},"frontmatter":{"title":"5-1 Web Hacking Overview"}}},{"node":{"id":"33246c96-e01f-5f26-9fe0-935c2ea6d6c8","fields":{"slug":"/finite-field/"},"frontmatter":{"title":"4-2 finite field (Galois Field)"}}},{"node":{"id":"44143c20-8cd6-52c5-a65b-38ae0c254d40","fields":{"slug":"/steam-block/"},"frontmatter":{"title":"4-2 Stream Cipher와 Block Cipher"}}},{"node":{"id":"1cb1eed8-1228-5d4b-8147-ba3cbfbb1ac9","fields":{"slug":"/dos-attack/"},"frontmatter":{"title":"7-1 DoS attack"}}},{"node":{"id":"8ef6b148-c9b0-5e0f-8262-9d5c903ff8da","fields":{"slug":"/arp-attack/"},"frontmatter":{"title":"9-1"}}},{"node":{"id":"723a031e-e408-592d-875a-0ebc19f93a34","fields":{"slug":"/1-network-security/"},"frontmatter":{"title":"9-1 "}}},{"node":{"id":"540db76b-63f4-546a-bab2-98f6dc615676","fields":{"slug":"/public-key/"},"frontmatter":{"title":"9-2"}}},{"node":{"id":"e9c57be2-d977-5fbc-adab-f5d561e162d2","fields":{"slug":"/rsa-mod/"},"frontmatter":{"title":"10-1"}}},{"node":{"id":"8a943633-5d6b-5251-89a3-2c7806793dc4","fields":{"slug":"/rsa-mod/"},"frontmatter":{"title":"10-1"}}},{"node":{"id":"50d433cf-eb0f-543e-a2ab-b910ab2da972","fields":{"slug":"/other-public-key/"},"frontmatter":{"title":"10-2"}}},{"node":{"id":"4b4d9c37-4c09-5364-a635-b279835081b6","fields":{"slug":"/2-hash-func/"},"frontmatter":{"title":"11-2"}}},{"node":{"id":"e5769a05-01a2-595d-8e10-8ff79bd8dc19","fields":{"slug":"/1/"},"frontmatter":{"title":"11-1"}}},{"node":{"id":"e89c1c7f-6f2e-5033-b1d9-790b11ad95d2","fields":{"slug":"/1/"},"frontmatter":{"title":"12-1"}}},{"node":{"id":"54f259cd-800a-566f-9aba-1375697c0710","fields":{"slug":"/2/"},"frontmatter":{"title":"12-2"}}},{"node":{"id":"c66fa2c3-ac99-52b6-9542-acf2ef40f48d","fields":{"slug":"/2/"},"frontmatter":{"title":"13-2"}}},{"node":{"id":"5d789f23-5ef9-5d59-82c9-f7f6fbc87ddc","fields":{"slug":"/1/"},"frontmatter":{"title":"13-1"}}},{"node":{"id":"94edf4db-f16b-5415-bac7-a0631d61876c","fields":{"slug":"/2/"},"frontmatter":{"title":"14-2"}}},{"node":{"id":"6801285e-c42f-5541-b35b-192c80ea0bd0","fields":{"slug":"/1/"},"frontmatter":{"title":"14-1"}}}]},"previous":{"fields":{"slug":"/LoginView/"},"frontmatter":{"title":"Django LoginView 사용"}},"next":{"fields":{"slug":"/rsa-mod/"},"frontmatter":{"title":"10-1"}}},"pageContext":{"id":"540db76b-63f4-546a-bab2-98f6dc615676","series":"컴퓨터 보안","previousPostId":"33b29129-f5ac-57b7-b66e-814169eebcbc","nextPostId":"e9c57be2-d977-5fbc-adab-f5d561e162d2"}},"staticQueryHashes":[]}