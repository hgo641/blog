{"componentChunkName":"component---src-templates-post-jsx","path":"/2-hash-func/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"4b4d9c37-4c09-5364-a635-b279835081b6","excerpt":"Hash Function 자료구조의 해시테이블이랑 비슷한 개념 인풋으로 길이가 변할 수 있는 블록 M을 받는다 아웃풋으로 정해진 길이의 해시값을 출력한다 h = H(M) 주로 데이터 무결성(Integrity)를 보장하는데  사용됨 일종의 압축함수라고 생각할 수 있다 Crptographic hash 함수의 조건 h를 주면 M을 찾기 어려워야함 the one…","html":"<h2>Hash Function</h2>\n<blockquote>\n<p>자료구조의 해시테이블이랑 비슷한 개념</p>\n</blockquote>\n<ul>\n<li>인풋으로 길이가 변할 수 있는 블록 M을 받는다</li>\n<li>아웃풋으로 정해진 길이의 해시값을 출력한다</li>\n<li>h = H(M)</li>\n<li>주로 데이터 무결성(Integrity)를 보장하는데  사용됨</li>\n<li>일종의 압축함수라고 생각할 수 있다</li>\n</ul>\n<blockquote>\n<p>Crptographic hash 함수의 조건</p>\n<ul>\n<li>\n<p>h를 주면 M을 찾기 어려워야함</p>\n<ul>\n<li>the one-way property : 단방향적, M에서 h를 찾긴 쉽지만 그 반대는 어렵다</li>\n</ul>\n</li>\n<li>the collision-free property : 같은 hash value를 아웃풋으로 가지는 인풋 데이터 쌍을 찾기 어렵다</li>\n</ul>\n</blockquote>\n<h3>해시 함수의 다섯가지 용도</h3>\n<ul>\n<li>MAC : keyed hash</li>\n<li>digital signature</li>\n<li>password protection</li>\n<li>system integrity 보호</li>\n<li>PRF / PRNG 수도 랜덤 함수, 수도 랜덤 넘버 제너레이터</li>\n</ul>\n<h3>Data Integrity 용도</h3>\n<ul>\n<li>src는 데이터 뒷부분에 해시값을 붙여서 보냄</li>\n<li>dest는 받은 데이터의 앞부분에 해시함수를 적용하고 그 값이 데이터 뒷부분의 해시값과 일치하는지 확인</li>\n<li>같다면 전송과정에서 오류가 없는것</li>\n</ul>\n<p>만약 다스가 중간에서 공격한다면? (Man in the middle attack)</p>\n<p>원래 데이터의 해시값인지 변조된 해시값인지 구별이 불가능</p>\n<p>왜 이 방법이 가능한가?</p>\n<ul>\n<li>다스가 변조된 데이터에 대해서 자기 나름대로 해시값을 쉽게 계산할 수 있기 때문</li>\n<li>해쉬값을 쉽게 계산 못하게하자!</li>\n</ul>\n<h3>MAC</h3>\n<ul>\n<li>keyed hash function이라고도 한다</li>\n<li>key를 넣고 hash를 돌리겠다! (앞의 허술한 hash와는 다르다!)</li>\n<li>key는 src와 dest가 미리 공유한 비밀키</li>\n</ul>\n<blockquote>\n<p>인풋으로 시크릿 키와 데이터 블록을 받는다 - MAC으로 작용</p>\n<ul>\n<li>무결성을 점검해보려면 </li>\n<li>src는 원래 메시지 데이터에 MAC을 붙여서 보냄</li>\n<li>dest는 자기가 알고있는 keyed hash를 돌려서 받은 MAC과 비교</li>\n</ul>\n<p>공격자는 key가 없어서 MAC값을 변조할 수 없다</p>\n</blockquote>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 531px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/2d3f35d250355a0a6bf1d50a8992bd6d/b2c14/mac-procedure.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 32.94117647058823%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABJElEQVQoz01R2ZKCQAzk//9sl7JAvFBBuW9mOEbdfeqdZBn0IZVUp9O5rEE8IPuZbeiV9gqim1dszWneIBTHgrDO8BcO1yhYTSU4kJpsBKfhhZEaLQIk1tUD2loyNsqn5jy5wbDwCGPBrXPAPUyRZw2ypEKhvf3l4HwKUeYd46nGd9sT/GPAecrZ3w7Cawxn4yGJS6RxxeJWFGYosxbz+MOTTbrTxb+hqSRPLNoJ8/QL19ljY7u6SctCJJqnDXODawTPPaIue1i0WnCJeMrkXrCnIhI2d+rbEdEtRaNXpimoxqw8ygdz+ET/N5Q47HzsPV8XZTj7IU9ljk3EqmhR5NWCKX6KWGL58UAStqj7rFedxxevTLF5zvpBod4P6tVH/m0G/wPlEwwX5Jy9/AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mac procedure' title='mac procedure' src='/blog/static/2d3f35d250355a0a6bf1d50a8992bd6d/b2c14/mac-procedure.png' srcset='/blog/static/2d3f35d250355a0a6bf1d50a8992bd6d/e7570/mac-procedure.png 170w,\n/blog/static/2d3f35d250355a0a6bf1d50a8992bd6d/f46e7/mac-procedure.png 340w,\n/blog/static/2d3f35d250355a0a6bf1d50a8992bd6d/b2c14/mac-procedure.png 531w' sizes='(max-width: 531px) 100vw, 531px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>|| : 붙인다는 뜻</p>\n<ul>\n<li>Message에다가 Secret key를 비트 스트링으로 뒤에 붙임</li>\n<li>이걸 해시로 돌림</li>\n<li>Message에 해시값을 붙여서 보냄</li>\n<li>dest는 받은 Message부분에 해시함수를 돌려서 받은 MAC과 자신이 만든 MAC이 같은지 비교</li>\n<li>integrity와 authentication 둘 다 수행</li>\n</ul>\n<h3>Digital Signature</h3>\n<p>MAC에서의 역할과 비슷</p>\n<p>nonrepudation</p>\n<p>메시지의 해시값에 서명할 것</p>\n<blockquote>\n<p>RSA에서의 디지털 서명</p>\n<p>src의 프라이빗키인 d로 M을 암호화한 S를 M에 붙여서 dest에게 보냄</p>\n<p>dest는 S를 src의 퍼블릭 키로 복호화하고 M과 일치하는지 확인</p>\n<ul>\n<li>그러나 RSA는 암호화에 mod n을 적용하기 때문에 메시지인 M이 n보다 작아야함</li>\n<li>그러나 엄청 긴 메시지를 보내려면...?</li>\n<li>M을 블록처럼 나누고 서명해서 여러개를 보낸다?</li>\n<li>그럴 필요 없음!</li>\n<li>누군가가 조작하지않았다는 것만 보장하면 되기때문에 굳이 길이에 집착할 필요 없음 해시를 대신 적용하자!</li>\n</ul>\n</blockquote>\n<ul>\n<li>M을 해시함수에 돌려 H를 얻는다</li>\n<li>H를 src의 프라이빗키로 암호화한 E(sign)를 얻는다</li>\n<li>M에 E를 붙여 전송한다</li>\n<li>dest는 받은 M에 해시함수를 돌린 값과 받은 E를 퍼블릭키로 복호화한 값이 같은지 확인</li>\n</ul>\n<p>Other Hash Function Uses</p>\n<h3>one-way password</h3>\n<p>유저의 아이디와 패스워드를 저장할 때</p>\n<ul>\n<li>id : password</li>\n</ul>\n<p>이런식으로 저장하지않고</p>\n<ul>\n<li>id : H(password)</li>\n</ul>\n<p>를 저장한다</p>\n<h4>오프라인 딕셔너리 어택</h4>\n<p>공격자는 자주 사용되는 패스워드에 대응하는 해시 값을 딕셔너리 형태로 미리 만들어둠  </p>\n<p>해킹을 해서 user의 H(password)를 알아내고 H(password)와 일치하는 값이 미리 만들어둔 딕셔너리에 있는지 탐색</p>\n<p>이걸 막기위해</p>\n<p>해시를 쓸 때 그냥 쓰는게 아니라 salt라는 값을 쓴다</p>\n<p>sault 값이 12345라면,</p>\n<p>H(password || 12345 )를 한다.</p>\n<p>공격자는 사전을 만드려면 패스워드에 여러 salt값까지 추가로 붙여야하기때문에 salt 크기만큼 사전의 크기도 늘어난다</p>\n<p>공격자의 리소스 사용을 늘림</p>\n<h3>intrusion and virus detection</h3>\n<p>F = file</p>\n<p>파일을 해시함수로 돌려서 저장</p>\n<p>이후 똑같은 파일을 해시 함수로 돌렸는데 해시값이 바뀌면 파일이 변조된것</p>\n<ul>\n<li>공격방법은 아까와 동일하게 공격자가 해시값을 생성해서 변조된 해시값을 붙이는 것</li>\n<li>막는 방법은 해시값을 안전한 곳에 보관하거나 key를 추가로 사용</li>\n</ul>\n<h3>PRF, PRNG</h3>\n<p>해시함수의 요구 조건</p>\n<p>Preimage</p>\n<ul>\n<li>x를 해시함수에 돌렸는데 h가 나옴 (h = H(x)) 이때 x를 h의 preimage라고 부름</li>\n<li>해시함수는 일반적이로 다대일 매핑</li>\n<li>h 결과값에 대응하는 원래 인풋들이 많음</li>\n</ul>\n<p>Collision</p>\n<ul>\n<li>공격자가 변조된 데이터를 보냈는데</li>\n<li>변조된 데이터의 해시값과 원본 데이터의 해시값이 일치하면 무결성을 보증할 수 없기때문에 안됨</li>\n</ul>\n<h2>해시 함수를 어떻게 만들어야할까?</h2>\n<h4>이렇게 만들면 안됨!</h4>\n<p>노안전 사례</p>\n<ul>\n<li>입력을 n bit단위의 여러 블록으로 자름</li>\n<li>한 블록을 한 번에 하나씩 해시 함수로 돌림</li>\n<li>비트 단위로 xor - 패리티비트 생성</li>\n<li>단순히 xor이 아니라 다음 블록으로 넘어갈때마다 한 비트를 circular shift해서 비트 xor</li>\n</ul>\n<p>Preimage랑 Collision 특징 충족못함</p>\n<ul>\n<li>oneway : 결과물을 가지고 인풋을 임의로 만들어낼 수 있다</li>\n<li>collision : 같은 xor결과값을 만들어낼 수 있다</li>\n</ul>\n<h2>Attacks on Hash Functions</h2>\n<h3>Brute-Force Attack</h3>\n<p>막 던져봄</p>\n<p>아웃풋 길이가 길수록 공격하기 어려움 -> 그만큼 시도수가 늘어나니까</p>\n<h3>Cryptanalysis</h3>\n<p>알고리즘의 취약점을 찾는다</p>\n<p>ex. 아까 위에서는 xor을 만든다는 특징을 이용해서 공격. 0,0 -> 1,1로 바꿔서 다른 input 같은 결과도출</p>\n<h3>Collision Resistant Attacks</h3>\n<p>birthday paradox</p>\n<p>m bit짜리 아웃풋의 인풋을 맞춰보려면 2^m + 1만큼 시도해야함</p>\n<p>그러나 그 반인 2^(m/2) 번의 시도로도 1/2이상의 확률로 충돌을 찾을 수 있다</p>\n<h2>Secure Hash Algorithm(SHA)</h2>\n<p>해시 함수를 잘 설계해야한다!</p>\n<p>NIST에서 해시 함수 안전 표준 알고리즘을 제안</p>\n<p>SHA-0 : 1993 : 표준화는 안됨</p>\n<p>SHA-1 : 1995, 해시 함수 MD(message digest = hash func)4에 기반, 160bit의 해시 값, 근데 깨짐</p>\n<p>SHA-2 : 256, 384, 512 bit</p>\n<p>SHA-3 224, 256, 384, 512 bit</p>\n<p>SHA 는 역방향 계산안됨~ 블럭암호와 해쉬암호의 차이</p>\n<p>뒤에 10분정도 다시 듣기</p>","frontmatter":{"title":"11-2","date":"June 06, 2022","update":null,"tags":["computer protection"],"series":"컴퓨터 보안"},"fields":{"slug":"/2-hash-func/","readingTime":{"minutes":8.87}}},"seriesList":{"edges":[{"node":{"id":"e4acbdfb-722b-57a9-80ae-d895e0db1293","fields":{"slug":"/access-control/"},"frontmatter":{"title":"1-2 Access Control"}}},{"node":{"id":"4a6f8d90-3618-56c6-8559-879e5ecc9bf4","fields":{"slug":"/number-theory/"},"frontmatter":{"title":"2-2 Number Theory"}}},{"node":{"id":"0bd2f3a2-2ebf-58a4-b9b1-3362f3eb162d","fields":{"slug":"/osi-structure/"},"frontmatter":{"title":"1-1 OSI 보안 구조"}}},{"node":{"id":"c09c6352-565d-5712-bd74-a03fc2d175a7","fields":{"slug":"/cia-aa/"},"frontmatter":{"title":"1-1 컴퓨터 보안의 요구 조건 (CIA + AA)"}}},{"node":{"id":"7e8ccf0c-4d31-5ed5-834d-372268de637e","fields":{"slug":"/aes-process/"},"frontmatter":{"title":"5-2 AES Process"}}},{"node":{"id":"c18d6769-2773-5438-80d8-71766e893de4","fields":{"slug":"/cp-danger/"},"frontmatter":{"title":"4-1 다양한 보안 위협"}}},{"node":{"id":"31a7ca0e-a91b-5b21-90ba-72df9a459e48","fields":{"slug":"/multi-enc/"},"frontmatter":{"title":"6-2 Modes of Operation"}}},{"node":{"id":"dc9ea5bb-374d-534c-a413-adc23222b506","fields":{"slug":"/symmetric-cipher/"},"frontmatter":{"title":"3-2 Symmetric Cipher Model (고전 암호)"}}},{"node":{"id":"9a54b7cc-4a15-5b76-8fac-388d5b9e7d11","fields":{"slug":"/pseudo-random/"},"frontmatter":{"title":"7-2 난수 생성"}}},{"node":{"id":"81096a32-03d0-5672-bd39-ceaaefef6160","fields":{"slug":"/web-hack/"},"frontmatter":{"title":"5-1 Web Hacking Overview"}}},{"node":{"id":"33246c96-e01f-5f26-9fe0-935c2ea6d6c8","fields":{"slug":"/finite-field/"},"frontmatter":{"title":"4-2 finite field (Galois Field)"}}},{"node":{"id":"44143c20-8cd6-52c5-a65b-38ae0c254d40","fields":{"slug":"/steam-block/"},"frontmatter":{"title":"4-2 Stream Cipher와 Block Cipher"}}},{"node":{"id":"1cb1eed8-1228-5d4b-8147-ba3cbfbb1ac9","fields":{"slug":"/dos-attack/"},"frontmatter":{"title":"7-1 DoS attack"}}},{"node":{"id":"8ef6b148-c9b0-5e0f-8262-9d5c903ff8da","fields":{"slug":"/arp-attack/"},"frontmatter":{"title":"9-1"}}},{"node":{"id":"723a031e-e408-592d-875a-0ebc19f93a34","fields":{"slug":"/1-network-security/"},"frontmatter":{"title":"9-1 "}}},{"node":{"id":"540db76b-63f4-546a-bab2-98f6dc615676","fields":{"slug":"/public-key/"},"frontmatter":{"title":"9-2"}}},{"node":{"id":"e9c57be2-d977-5fbc-adab-f5d561e162d2","fields":{"slug":"/rsa-mod/"},"frontmatter":{"title":"10-1"}}},{"node":{"id":"8a943633-5d6b-5251-89a3-2c7806793dc4","fields":{"slug":"/rsa-mod/"},"frontmatter":{"title":"10-1"}}},{"node":{"id":"50d433cf-eb0f-543e-a2ab-b910ab2da972","fields":{"slug":"/other-public-key/"},"frontmatter":{"title":"10-2"}}},{"node":{"id":"4b4d9c37-4c09-5364-a635-b279835081b6","fields":{"slug":"/2-hash-func/"},"frontmatter":{"title":"11-2"}}},{"node":{"id":"e5769a05-01a2-595d-8e10-8ff79bd8dc19","fields":{"slug":"/1/"},"frontmatter":{"title":"11-1"}}},{"node":{"id":"e89c1c7f-6f2e-5033-b1d9-790b11ad95d2","fields":{"slug":"/1/"},"frontmatter":{"title":"12-1"}}},{"node":{"id":"54f259cd-800a-566f-9aba-1375697c0710","fields":{"slug":"/2/"},"frontmatter":{"title":"12-2"}}},{"node":{"id":"c66fa2c3-ac99-52b6-9542-acf2ef40f48d","fields":{"slug":"/2/"},"frontmatter":{"title":"13-2"}}},{"node":{"id":"5d789f23-5ef9-5d59-82c9-f7f6fbc87ddc","fields":{"slug":"/1/"},"frontmatter":{"title":"13-1"}}},{"node":{"id":"94edf4db-f16b-5415-bac7-a0631d61876c","fields":{"slug":"/2/"},"frontmatter":{"title":"14-2"}}},{"node":{"id":"6801285e-c42f-5541-b35b-192c80ea0bd0","fields":{"slug":"/1/"},"frontmatter":{"title":"14-1"}}}]},"previous":{"fields":{"slug":"/other-public-key/"},"frontmatter":{"title":"10-2"}},"next":{"fields":{"slug":"/1/"},"frontmatter":{"title":"11-1"}}},"pageContext":{"id":"4b4d9c37-4c09-5364-a635-b279835081b6","series":"컴퓨터 보안","previousPostId":"50d433cf-eb0f-543e-a2ab-b910ab2da972","nextPostId":"e5769a05-01a2-595d-8e10-8ff79bd8dc19"}},"staticQueryHashes":[]}