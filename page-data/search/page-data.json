{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"문제 N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.\n\n이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴…","fields":{"slug":"/2164/"},"frontmatter":{"date":"July 26, 2022","title":"백준 2164 카드2","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\nN장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.\r\n<br/>\r\n이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.\r\n<br/>\r\n예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.\r\n<br/>\r\nN이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nqueue를 이용하면 손쉽게 구현할 수 있다.\r\n\r\n<br/>\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint n;\r\nqueue<int> q;\r\nint main() {\r\nios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\ncin >> n;\r\nfor (int i = 1; i <= n; i++) {\r\nq.push(i);\r\n}\r\nwhile (q.size() > 1) {\r\nq.pop();\r\nq.push(q.front());\r\nq.pop();\r\n}\r\n\r\n    cout << q.front();\r\n\r\n}\r\n\r\n```\r\n> 실버4치곤 너무 쉬워서 당황스러운 문제였다... (오히려좋아?)\r\n```\r\n"},{"excerpt":"작성중","fields":{"slug":"/1/"},"frontmatter":{"date":"July 25, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 8주차 월요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 작성중\r\n"},{"excerpt":"문제 두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오. 첫 번째 풀이 원시적인 방법으로 풀었다 >< 최대 공약수 최대 공약수는 a또는 b보다 클 수 없다. \na > b이므로, i = 1 ~ b 사이의 모든 수로 a와 b를 나눈다. 만약 a와 b 둘 다 i로 나눠진다면 gcd에 i를 대입한다.\n가장 마지막에 대입된 값이…","fields":{"slug":"/2609/"},"frontmatter":{"date":"July 24, 2022","title":"백준 2609 최대공약수와 최소공배수","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.\r\n\r\n## 첫 번째 풀이\r\n\r\n원시적인 방법으로 풀었다 \\><<br/><br/>\r\n\r\n### 최대 공약수\r\n\r\n최대 공약수는 a또는 b보다 클 수 없다. <br/>\r\na > b이므로, i = 1 ~ b 사이의 모든 수로 a와 b를 나눈다.<br/><br/>\r\n\r\n만약 a와 b 둘 다 i로 나눠진다면 gcd에 i를 대입한다.\r\n가장 마지막에 대입된 값이 GCD(a,b)이다.\r\n\r\n### 최소 공배수\r\n\r\n역시나 원시적인 방법으로 a, b 두 수에 값(aq, bq)를 차례대로 곱하면서 a\\*aq == b\\*bq가 되는 aq와 bq를 구한다. <br/><br/>\r\n\r\n최소 공배수는 최대 a\\*b이므로 aq는 무조건 b이하의 수이고, bq는 a이하의 수이다.\r\naq가 b이하일동안 while문을 통해 aq와 bq를 1씩 더해가며 최소 공배수를 구한다.<br/><br/>\r\n\r\naq _ a와 bq _ b를 비교하며, aq\\*a가 더 크다면 bq의 값을 1늘리고, bq\\*b의 값이 더 크다면 aq의 값을 1늘린다.<br/><br/>\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, temp, q;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> a >> b;\r\n\tif (a < b) { // 항상 a가 b보다 더 큼\r\n\t\ttemp = a;\r\n\t\ta = b;\r\n\t\tb = temp;\r\n\t}\r\n\tint gcd, lcm;\r\n\tfor (int i = 1; i <= b; i++) {\r\n\t\tif (a % i == 0 && b % i == 0) {\r\n\t\t\tgcd = i;\r\n\t\t}\r\n\t}\r\n\tint k = 1;\r\n\tint aq = 1;\r\n\tint bq = 1;\r\n\twhile (aq <= b) {\r\n\t\tif (a * aq > b * bq) bq++;\r\n\t\telse if (a * aq < b * bq) aq++;\r\n\t\telse {\r\n\t\t\tlcm = a * aq;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tcout << gcd << \"\\n\";\r\n\tcout << lcm << \"\\n\";\r\n}\r\n```\r\n\r\n## 두 번째 풀이\r\n\r\n유클리드 알고리즘을 사용하면 빠르게 최대 공약수를 구할 수 있다!<br/><br/>\r\n유클리드 알고리즘은 수 a, b가 있을 때 (이 때 a > b 이다.)\r\n\r\n- 1. a를 b로 나눈 나머지인 r을 구하고\r\n- 2. a에 b를 b에 r을 대입하고 다시 나머지를 구한다.\r\n- 3. r이 0이 될때까지 2번을 반복한다.\r\n- 4. r이 0이 되었을 때 b에 있는 값이 최대 공약수이다.\r\n     <br/><br/>\r\n     최소 공배수를 구하는 식은 다음과 같다.\r\n     > (a \\* b) / gcd(a,b)\r\n     > <br/><br/>\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint a, b, temp, q;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> a >> b;\r\n\tif (a < b) { // 항상 a가 b보다 더 큼\r\n\t\ttemp = a;\r\n\t\ta = b;\r\n\t\tb = temp;\r\n\t}\r\n\t// 유클리드 호제법\r\n\tint r = 1;\r\n\tint _a = a;\r\n\tint _b = b;\r\n\twhile (r != 0) {\r\n\t\tq = _a / _b;\r\n\t\tr = _a % (_b * q);\r\n\t\t_a = _b;\r\n\t\t_b = r;\r\n\t}\r\n\r\n\tint gcd = _a;\r\n\tint lcm = (a * b) / gcd;\r\n\r\n\tcout << gcd << \"\\n\";\r\n\tcout << lcm << \"\\n\";\r\n}\r\n```\r\n"},{"excerpt":"SELECT (1) 📌 예제 하위질의 : 조건절에 주어진 질의를 먼저 수행하여 그 검색 결고를 조건절의 피연산자로 활용한다. EXIST : 하위질의로 검색된 결과가 존재하는지 확인할 때 쓴다... 위 예시의 경우 사원테이블의 이름이 여가활동의 이름에도 있는지 확인하고, 두 테이블에 이름이 존재하는 사원의 이름과 주소를 출력한다. SELECT (2) 그룹함…","fields":{"slug":"/select/"},"frontmatter":{"date":"July 23, 2022","title":"SQL-SELECT","tags":["SQL"]},"rawMarkdownBody":"\r\n## SELECT (1)\r\n\r\n```sql\r\nSELECT [DISTINCT]\r\nFROM\r\n[WHERE]\r\n\t[GROUP BY]\r\n\t[HAVING]\r\n[ORDER BY]\r\n```\r\n\r\n#### 📌 예제\r\n\r\n```sql\r\nSELECT 이름 + '의 월급' AS 이름2, 기본급 + 10 AS 기본급2\r\nFROM 사원\r\n```\r\n\r\n```sql\r\nSELECT *\r\nFROM 사원\r\nWHERE 부서 IN ('기획', '마케팅');\r\n```\r\n\r\n```sql\r\nSELECT *\r\nFROM 사원\r\nWHERE 이름 LIKE '김_';\r\n\r\nSELECT *\r\nFROM 사원\r\nWHERE 이름 LIKE '김%';\r\n\r\nSELECT *\r\nFROM 사원\r\nWHERE 경력 LIKE '1#';\r\n```\r\n\r\n```SQL\r\nSELECT *\r\nFROM 사원\r\nWHERE 생일 BETWEEN #010169# AND #12/31/73#\r\n```\r\n\r\n```SQL\r\nSELECT *\r\nFROM 사원\r\nWHERE 주소 IS NULL\r\n\r\nSELECT *\r\nFROM 사원\r\nWHERE 주소 IS NOT NULL\r\n```\r\n\r\n```sql\r\nSELECT TOP 2 *\r\nFROM 사원\r\nORDER BY 경력 DESC, 생일 ASC;\r\n```\r\n\r\n하위질의 : 조건절에 주어진 질의를 먼저 수행하여 그 검색 결고를 조건절의 피연산자로 활용한다.\r\n\r\n```sql\r\nSELECT 이름, 주소\r\nFROM 사원\r\nWHERE 이름 = (SELECT 이름 FROM 여가활동 WHERE 취미 = '코딩')\r\n\r\nSELECT 이름, 주소\r\nFROM 사원\r\nWHERE 이름 NOT IN (SELECT 이름 FROM 여가활동)\r\n\r\nSELECT 이름, 주소\r\nFROM 사원\r\nWHERE EXISTS (SELECT 이름 FROM 여가활동 WHERE 여가활동.이름 = 사원.이름)\r\n```\r\n\r\n> EXIST : 하위질의로 검색된 결과가 존재하는지 확인할 때 쓴다...\r\n>\r\n> 위 예시의 경우 사원테이블의 이름이 여가활동의 이름에도 있는지 확인하고, 두 테이블에 이름이 존재하는 사원의 이름과 주소를 출력한다.\r\n\r\n## SELECT (2)\r\n\r\n## 그룹함수\r\n\r\n> GROUP BY 절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술함\r\n\r\n- COUNT\r\n- SUM\r\n- AVG\r\n- MAX\r\n- MIN\r\n- STDDEV : 표준편차\r\n- VARIANCE : 분산\r\n- ROLLUP\r\n- CUBE\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nSELECT 부서, AVG(상여금) AS 상여금평균\r\nFROM 상여금\r\nGROUP BY 부서\r\n```\r\n\r\n> `상여금 `테이블에서 `부서`별 `상여금`평균을 구한다.\r\n\r\n```sql\r\nSELECT 부서, COUNT(*) AS 사원수\r\nFROM 상여금\r\nWHERE 상여금 >= 100\r\nGROUP BY 부서\r\nHAVING COUNT(*) >= 2\r\n```\r\n\r\n> `상여금 `테이블에서 `상여금`이 `100`이상인 사원이 `2명`이상인 `부서`의 튜플 개수를 구한다.\r\n\r\n## WINDOW 함수\r\n\r\n> GROUP BY절을 이용하지 않고 함수의 인수로 지정한 속성의 값을 집계한다\r\n>\r\n> WINDOW함수의 범위는 PARTITION BY절에 지정한 속성이 된다.\r\n\r\n```sql\r\nSELECT\r\n[WINDOW함수 OVER (PARTITION BY 속성 ORDER BY 속성)]\r\n```\r\n\r\n<br/>\r\n\r\n- ROW_NUMBER() : 각 레코드에 대한 일련번호 반환\r\n- RANK() : 공동 순위 반영\r\n- DENSE_RANK() : 공동 순위 무시\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nSELECT 상여내역, 상여금, ROW_NUMBER() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS NO\r\nFROM 상여금\r\n```\r\n\r\n> `상여금` 테이블에서 `상여내역`별로 `상여금`에 대한 일련번호를 구한다.\r\n>\r\n> 순서는 내림차순이며, 속성명은 NO\r\n\r\n```sql\r\nSELECT 상여내역, 상여금, RANK() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS 상여금순위\r\nFROM 상여금\r\n```\r\n\r\n### 집합연산자\r\n\r\n- UNION : 합집합\r\n- UNION ALL : 중복허용 합집합\r\n- INTERSECT : 교집합\r\n- EXCEPT : 차집합\r\n\r\n<br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nSELECT *\r\nFROM 사원\r\nINTERSECT\r\nSELECT *\r\nFROM 직원\r\n```\r\n\r\n## JOIN\r\n\r\n> JOIN은 두 개의 릴레이션에서 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환한다.\r\n>\r\n> - 일반적으로 FROM절에 기술한다.\r\n> - 크게 INNER JOIN과 OUTER JOIN으로 구분된다.\r\n\r\n### INNER JOIN\r\n"},{"excerpt":"아아... 내 아바타 오늘은 슬픈 소식을 가져왔다... MOD 운영진에게 지급되었던 MOD 캐시와 캐시로 산 코디가 모두 초기화되었다...  저 초라한 옷차림 좀 보세요   죽으라는 법은 없다. 비록 이쁜 캐시 아이템들은 더 이상 없지만... 꿩대신 닭이라고 상점에 무료로 살 수 있는 아이템들이 업데이트 되어 있었다.  그래서 오늘은 무료 아이템들을 플렉…","fields":{"slug":"/5-poor-avatar/"},"frontmatter":{"date":"July 22, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 7주차 금요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 아아... 내 아바타\r\n\r\n오늘은 슬픈 소식을 가져왔다...<br/>\r\n\r\nMOD 운영진에게 지급되었던 MOD 캐시와 캐시로 산 코디가 모두 초기화되었다...\r\n\r\n![](poor-avatar.png)\r\n\r\n> 저 초라한 옷차림 좀 보세요\r\n\r\n<br/> <br/>\r\n\r\n## 죽으라는 법은 없다.\r\n\r\n비록 이쁜 캐시 아이템들은 더 이상 없지만... 꿩대신 닭이라고 상점에 무료로 살 수 있는 아이템들이 업데이트 되어 있었다. <br/>\r\n\r\n그래서 오늘은 무료 아이템들을 플렉스해서 코디를 다시 꾸며보겠다.\r\n\r\n![](store.png)\r\n\r\n좌측의 아바타 아이콘을 누르고 상점을 클릭하면 무료 아이템들을 볼 수 있다.<br/>\r\n\r\n마음에 드는 것을 잔뜩 구매해준다.\r\n\r\n## 꽃단장\r\n\r\n![](myavatar.png)\r\n\r\n짜잔... 새 코디이다. 나름 귀여운 것 같다. <br/>\r\n\r\n파란색을 좋아해서 파란색으로 꾸몄다.<br/>\r\n\r\n저 병아리는 코디가 초기화되기 이전에도 착용했던 아이템인데 무료템이라 다행이다.(최애템이다)<br/>\r\n\r\n<br/><br/>\r\n\r\n![](move.png)\r\n\r\n이동할 때 병아리를 들고 이동하는 것이 제법 귀엽다.<br/>\r\n\r\n너라도 살 수 있어서 다행이야<br/>\r\n\r\n## 회고\r\n\r\n오늘은 초기화된 아바타로 인해 마음이 괴로우니 공부는 스킵하겠다. 절대 농땡이를 부리는 것이 아니다.\r\n"},{"excerpt":"DDL (Data Control Language) 데이터 제어어 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어이다. 데이터베이스 관리자가 데이터 관리를 목적으로 사용한다. COMMIT : 트랙잭션 수행 결과를 실제 물리적 디스크에 저장하고, 관리자에게 데이터 베이스 조작 작업이 정상적으로 완료되었음을 알림. ROLLBACK : …","fields":{"slug":"/dcl/"},"frontmatter":{"date":"July 21, 2022","title":"SQL-DCL","tags":["SQL"]},"rawMarkdownBody":"\r\n## DDL (Data Control Language)\r\n\r\n> 데이터 제어어\r\n\r\n데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는데 사용하는 언어이다.<br/>\r\n\r\n데이터베이스 관리자가 데이터 관리를 목적으로 사용한다.\r\n\r\n<br/>\r\n\r\n- COMMIT : 트랙잭션 수행 결과를 실제 물리적 디스크에 저장하고, 관리자에게 데이터 베이스 조작 작업이 정상적으로 완료되었음을 알림.\r\n- ROLLBACK : 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구함\r\n- GRANT : 데이터베이스 사용자에게 사용 권한 부여\r\n- REVOKE : 데이터 베이스 사용자의 사용 권한 취소\r\n\r\n\r\n\r\n## GRANT, REVOKE\r\n\r\n\r\n\r\n### 사용자 등급 지정 및 해제\r\n\r\n```sql\r\nGRANT 사용자등급 TO 사용자아이디리스트\r\nREVOKE 사용자등급 FROM 사용자아이디리스트\r\n```\r\n\r\n<br/><br/>\r\n\r\n#### 📌 사용자 등급\r\n\r\n* DBA : 데이터베이스 관리자\r\n* RESOURCE : 데이터베이스 및 테이블 생성 가능자\r\n* CONNECT : 단순 사용자\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nGRANT CONNECT TO HONG\r\n```\r\n\r\n> 사용자 아이디가 `HONG` 인 사람에게 단순히 데이터베이스에 있는 정보를 검색할 수 있는 권한을 부여\r\n\r\n\r\n\r\n### 테이블 및 Attribute에 대한 권한 부여 및 취소\r\n\r\n```sql\r\nGRANT 권한리스트 ON 개체 TO 사용자 [WITH GRANT OPTION]\r\nREVOKE [GRANT OPTION FOR] 권한리스트 ON 개체 FROM 사용자 [CASCADE]\r\n```\r\n\r\n* 권한 종류 : ALL, SELECT, INSERT, DELETE, UPDATE\r\n* WITH GRANT OPTION : 부여받은 권한을 다른 사용자에게 다시 부여할 수 있는 권한\r\n* GRANT OPTION FOR : 다른 사용자에게 권한을 부여할 수 있는 권한을 취소함\r\n* CASCADE : 권한 취소 시 권한을 부여받았던 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소함\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nGRANT ALL ON 고객 TO HONG WITH GRANT OPTION\r\n```\r\n\r\n> 사용자 아이디 `HONG`에게 `고객`테이블에 대한 모든 권한과 다른 사람에게 권한을 부여할 수 있도록 허용\r\n\r\n<br/><br/>\r\n\r\n```sql\r\nREVOKE GRANT OPTION FOR UPDATE ON 고객 FROM HONG\r\n```\r\n\r\n> 사용자 아이디 `HONG`에게 `고객`테이블에 대한 권한 중 다른 사용자에게 UPDATE권한을 부옇라 수 있는 권한만 취소한다.\r\n\r\n\r\n\r\n## COMMIT, ROLLBACK, SAVEPOINT\r\n\r\n> 커밋 명령을 수행한 시점 전으로는 롤백 명령으로도 되돌릴 수 없다.\r\n\r\n<br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nDELETE FROM 사원 WHERE 사원번호 = 1;\r\nCOMMIT;\r\n\r\n// << ROLLBACK\r\n\r\nDELETE FROM 사원 WHERE 사원번호 = 2;\r\nSAVEPOINT S1;\r\n\r\n// << ROLLBACK TO S1;\r\n\r\nDELETE FROM 사원 WHERE 사원번호 = 3;\r\n\r\nROLLBACK TO S1; // SAVEPOINT S1을 설정했던 시점으로 돌아간다\r\nROLLBACK; // 최근 커밋 이후로 돌아간다.\r\n```\r\n\r\n"},{"excerpt":"DML (Data Manipulate Language) 데이터 조작어 데이터 베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다. 데이터베이스 사용자와 데이터 베이스 관리 시스템 간의 인터페이스를 제공한다. SELECT INSERT DELETE UPDATE JOIN SELECT와 JOIN은 분량이 길어 다른 포스트에서 설명하고 여기서는…","fields":{"slug":"/dml/"},"frontmatter":{"date":"July 21, 2022","title":"SQL-DML","tags":["SQL"]},"rawMarkdownBody":"\r\n## DML (Data Manipulate Language)\r\n\r\n> 데이터 조작어\r\n\r\n데이터 베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어이다.<br/>\r\n\r\n데이터베이스 사용자와 데이터 베이스 관리 시스템 간의 인터페이스를 제공한다.\r\n\r\n<br/>\r\n\r\n- SELECT\r\n- INSERT\r\n- DELETE\r\n- UPDATE\r\n- JOIN\r\n\r\n<br/>\r\n\r\n> SELECT와 JOIN은 분량이 길어 다른 포스트에서 설명하고 여기서는 INSERT, DELETE, UPDATE만 정리해보겠다!\r\n\r\n## INSERT INTO ~\r\n\r\n테이블에 새로운 튜플을 삽입할 때 사용한다.\r\n\r\n```sql\r\nINSERT INTO 테이블명[(속성, 속성, ...)]\r\nVALUES (데이터, 데이터, ...)\r\n```\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\nAttribute가 이름, 학번, 생일, 학과, 학년이 있는 학생테이블이 있다고 해보자.\r\n\r\n```sql\r\nINSERT INTO 학생 VALUES ('홍길동', '1111', '05/03/00', '컴퓨터공학과',1)\r\nINSERT INTO 학생(이름, 학과, 학년) VALUES ('홍길동', '컴퓨터공학과',1)\r\n```\r\n\r\n<br/>\r\n\r\n아래와 같이 SELECT문 사용도 가능하다.\r\n\r\n```sql\r\nINSERT INTO 1학년학생(이름, 학과)\r\nSELECT 이름, 학과\r\nFROM 학생\r\nWHERE 학년 = 1\r\n```\r\n\r\n## DELETE FROM ~\r\n\r\n```sql\r\nDELETE\r\nFROM 테이블명\r\n[WHERE 조건] // 모든 레코드를 삭제할 때는 생략한다.\r\n```\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nDELETE\r\nFROM 학생\r\nWHERE 이름 = '홍길동'\r\n```\r\n\r\n## UPDATE~ SET~\r\n\r\n> 특정 튜플의 내용을 변경한다.\r\n\r\n```sql\r\nUPDATE 테이블명\r\nSET 속성명 = 데이터[, 속성명 = 데이터, ...]\r\n[WHERE 조건]\r\n```\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nUPDATE 학생\r\nSET 학과 = '의적학과', 학년 = 2\r\nWHERE 이름 = '홍길동'\r\n```\r\n"},{"excerpt":"그룹원과 공동 월드 제작하기 지금까진 나 혼자서 개발을 한 것만 포스팅했는데 사실 MOD는 공동 개발도 가능하다! Github에서 Organization의 일원이 되어서 repositoriy를 만들고 코드를 주고 받으면서 개발을 했던 것처럼, MOD에서는 ‘그룹'의 일원이 되어서 ‘그룹 월드'를 만들어 실시간으로 팀원들과 함께 개발할 수 있다. 지금까지 …","fields":{"slug":"/4/"},"frontmatter":{"date":"July 21, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 7주차 목요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 그룹원과 공동 월드 제작하기\r\n\r\n지금까진 나 혼자서 개발을 한 것만 포스팅했는데 사실 MOD는 공동 개발도 가능하다!<br/>\r\n\r\nGithub에서 Organization의 일원이 되어서 repositoriy를 만들고 코드를 주고 받으면서 개발을 했던 것처럼, MOD에서는 ‘그룹'의 일원이 되어서 ‘그룹 월드'를 만들어 실시간으로 팀원들과 함께 개발할 수 있다.<br/>\r\n\r\n<br/>\r\n\r\n지금까지 개인 월드는 `MOD MAKER`에서 생성했는데 그룹 월드는 `MOD MAKER`에서 생성할 수 없고 MOD 웹사이트에서 생성할 수 있다. (아마 나중엔 `MOD MAKER`에서도 그룹 월드를 생성할 수 있는 기능이 생기지않을까싶다.)<br/><br/>\r\n\r\n[MOD웹](https://mod.nexon.com/)에서 로그인후 프로필란에 들어간 후, `만들기`버튼을 누른다.\r\n\r\n![](make-group.png)\r\n\r\n좌측의 `그룹만들기`버튼을 누르면 그룹을 생성할 수 있다.<br/>\r\n\r\n그룹을 만들고 멤버추가란에서 멤버의 닉네임이나 코드를 입력해 그룹 월드에 초대할 수 있다.<br/>\r\n\r\n<br/>\r\n\r\n이후 `MOD MAKER`의 그룹란에서 생성한 그룹 월드를 확인할 수 있다.<br/>\r\n\r\n<br/>\r\n\r\n![](group-mydesk.png)\r\n\r\n그룹 월드는 위와 같이 다른 사람이 작업하고 있는 컴포넌트옆에 사람모양+자물쇠 아이콘이 생긴다. 공유 자원에 대한 접근을 제한하기 위해 누군가가 작업중인 스크립트, 컴포넌트 등은 잠금이 되는 것을 볼 수 있다.\r\n\r\n\r\n\r\n\r\n\r\n## 주의할 점\r\n\r\n룹을 생성한 그룹원이 `MOD MAKER`를 통해 그룹 월드로 들어가 저장을 해줘야 다른 팀원들도 그룹 월드에 들어올 수 있었다.<br/>\r\n\r\n그룹을 생성한 사람은 꼭 그룹을 저장해주자!\r\n"},{"excerpt":"DDL (Data Define Language) 데이터 정의어 DB를 구축하거나 수정할 목적으로 사용하는 언어이며, 총 세 가지 유형이 존재한다. CREATE ALTER DROP CREATE CREATE 명령어에 대해 자세히 알아보기전 알고있으면 좋을 것! 데이터베이스 서버 ⊃ 데이터베이스 스키마 ⊃ 데이터베이스 테이블 데이터베이스 서버는 데이터베이스들의…","fields":{"slug":"/ddl/"},"frontmatter":{"date":"July 20, 2022","title":"SQL-DDL","tags":["SQL"]},"rawMarkdownBody":"\r\n## DDL (Data Define Language)\r\n\r\n> 데이터 정의어\r\n\r\nDB를 구축하거나 수정할 목적으로 사용하는 언어이며, 총 세 가지 유형이 존재한다.\r\n\r\n<br/>\r\n\r\n* CREATE\r\n* ALTER\r\n* DROP\r\n\r\n\r\n\r\n## CREATE\r\n\r\nCREATE 명령어에 대해 자세히 알아보기전 알고있으면 좋을 것!<br/>\r\n\r\n데이터베이스 서버 ⊃ 데이터베이스 스키마 ⊃ 데이터베이스 테이블<br/>\r\n\r\n* 데이터베이스 서버는 데이터베이스들의 그룹화이고,\r\n* 스키마는 테이블들의 그룹화이다.\r\n\r\n<br/><br/>\r\n\r\n* 표(= 릴레이션) : 행(=row=record=tuple) + 열(=column=attribute=field)\r\n\r\n* degree : Attribute의 수\r\n\r\n* cardinality : tuple의 수\r\n\r\n* domain : 하나의 Attribute가 취할 수 있는 동일한 유형의 원자값들의 집합을 의미한다.(네?)\r\n\r\n  * 쉽게 말하면 도메인은 특정 Attribute에서 사용할 데이터의 범위를 사용자가 정의하는 사용자 정의 데이터 타입이다.\r\n\r\n  * ex) 만약 성별 속성의 값이 \"남\", \"여\" 라면 이 두 개의 값은 성별 속성의 도메인이다.\r\n\r\n  * ex) 만약 학년 속성의 값이 1~4라면, 1~4가 학년 속성의 도메인이다.\r\n\r\n    > 위 성별 속성에서는 타입이 문자열로, 원래라면 모든 문자열이 들어갈 수 있지만 범위를 지정했기에 \"남\"과 \"여\" 둘 중 하나만 허용된다.<br/>\r\n    >\r\n    > 학년 속성도 동일하다.\r\n\r\n\r\n\r\n\r\n\r\n### CREATE SCHEMA\r\n\r\n스키마는 MySQL을 보면 database 그 자체를 의미한다.<br/>\r\n\r\n스키마를 생성하고 스키마 안에 db테이블을 생성한다.<br/><br/>\r\n\r\n명령어 구조는 아래와 같다.\r\n\r\n```sql\r\nCREATE SCHEMA 스키마명 AUTHORIZATION 유저아이디;\r\n```\r\n\r\n예시 : CREATE SCHEMA `대학교` AUTHORIZATION `홍길동`\r\n\r\n> 스키마 이름은 `대학교`이고, 소유권자의 유저아이디는 `홍길동`이다.\r\n\r\n\r\n\r\n### CREATE DOMAIN\r\n\r\n\r\n\r\n명령어 구조는 아래와 같다. []안의 내용은 생략가능하다.\r\n\r\n```sql\r\nCREATE DOMAIN 도메인명 [AS] 데이터타입\r\n\t\t[DEFAULT 디폴트값]\r\n\t\t[CONSTRAINT 제약조건명 CHECK(범위값)];\r\n```\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nCREATE DOMAIN SEX CHAR(1)\r\n\t\tDEFAULT '남'\r\n\t\tCONSTRAINT VALID-SEX CHECK(VALUE IN ('남', '여'));\r\n```\r\n\r\n> 도메인 이름은 `SEX`이고<br/>\r\n>\r\n> 디폴트값은 '남'이고<br/>\r\n>\r\n> 제약조건은 '남'과 '여' 둘 중 하나여야하며, 이 이름은 편의상 `VALID-SEX`라고 붙인다.\r\n\r\n\r\n\r\n### CREATE TABLE\r\n\r\nCREATE TABLE명령어의 옵션은 아래와 같다.\r\n\r\n* PRIMARY KEY\r\n* UNIQUE\r\n* FOREIGN KEY ~ REFERENCE ~\r\n  * ON DELETE\r\n  * ON UPDATE\r\n* CONSTRAINT [CHECK()]<br/><br/><br/>\r\n\r\n형식보다 예시를 보는게 더 이해가 쉬워서 바로 예시로 넘아가겠다!\r\n\r\n```sql\r\nCREATE TABLE 학생\r\n\t\t(이름 VARCHAR(15) NOT NULL,\r\n         학번 CHAR(8),\r\n         전공 CHAR(5),\r\n         성별 SEX, // SEX 도메인 사용\r\n         PRIMARY KEY(학번),\r\n         FOREIGN KEY(전공) REFERENCES 학과(학과코드)\r\n         \t\tON DELETE SET NULL\r\n         \t\tON UPDATE CASCADE,\r\n         CONSTRAINT 생년월일제약\r\n         \tCHECK(생년월일 >= '1980-01-01'));\r\n```\r\n\r\n\r\n\r\n### CREATE VIEW\r\n\r\n명령어 구조는 아래와 같다. []안의 내용은 생략가능하다.\r\n\r\n```sql\r\nCREATE VIEW 뷰명[(속성명, 속성명, ...)]\r\nAS SELECT문\r\n```\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nCREATE VIEW 서울고객(성명)\r\nAS SELECT 성명\r\nFROM 고객\r\nWHERE 주소 = \"서울시\";\r\n```\r\n\r\n\r\n\r\n### CREATE INDEX\r\n\r\n인덱스는 검색 시간을 단축시키기 위해 만든 보조적인 데이터 구조이다.\r\n\r\n명령어 구조는 아래와 같다. []안의 내용은 생략가능하다.\r\n\r\n```sql\r\nCREATE [UNIQUE] INDEX 인덱스명\r\nON 테이블명(속성명[ASC|DESC], 속성명, 속성명 ...)\r\n[CLUSTER];\r\n```\r\n\r\n> 클러스터드 인덱스는 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식이다.\r\n\r\n<br/><br/>\r\n\r\n#### 📌 예시\r\n\r\n```sql\r\nCREATE UNIQUE INDEX 고객번호_idx\r\nON 고객(고객번호 DESC);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## ALTER TABLE\r\n\r\n표기형식\r\n\r\n* ALTER TABLE  `테이블명`  ADD `속성명`  `데이터 타입` [DEFAULT ``'기본값'``];\r\n* ALTER TABLE  `테이블명` ALTER  `속성명` [SET DEFAULT ``'기본값'``];\r\n* ALTER TABLE  `테이블명`  DROP COLUMN  `속성명` [CASCADE];\r\n\r\n> ADD : 새로운 Attribute(열)를 추가할 때 사용한다.\r\n>\r\n> ALTER : 특정 Attribute의 DEFAULT값을 변경할 때 사용한다.\r\n>\r\n> DROP COLUMN : 특정 Attribute를 삭제할 때 사용한다.\r\n\r\n<br/>\r\n\r\n\r\n\r\n## DROP\r\n\r\nDROP은 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문이다.\r\n\r\n```sql\r\nDROP SCHEMA 스키마명 [CASCADE | RESTRICT];\r\nDROP DOMAIN 도메인명 [CASCADE | RESTRICT];\r\nDROP TABLE 테이블명 [CASCADE | RESTRICT];\r\nDROP VIEW 뷰명 [CASCADE | RESTRICT];\r\nDROP INDEX 인덱스명 [CASCADE | RESTRICT];\r\nDROP CONSTRAINT 제약조건명 [CASCADE | RESTRICT];\r\n```\r\n\r\n> CASCADE : 제거할 요소를 참조하는 다른 모든 개체를 함께 제거한다.\r\n>\r\n> RESTRICT : 다른 개체가 제거할 요소를 참조중일 때는 제거를 취소한다.\r\n"},{"excerpt":"작성중","fields":{"slug":"/3/"},"frontmatter":{"date":"July 20, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 7주차 수요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 작성중\r\n"},{"excerpt":"문제 주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오. 풀이 만약 10000등 큰 수가 들어온다면, 2부터 9999까지의 모든 수로 10000을 나눠보면 10000이 소수인지 아닌지 알 수 있다.\n그러나 예를 들어 10000의 약수 2와 5000이 있을 때,\n2와 5000를 서로 곱해야 10000을 만들 수 있다. 이처럼 2…","fields":{"slug":"/1978/"},"frontmatter":{"date":"July 19, 2022","title":"백준 1978 소수 찾기","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n주어진 수 N개 중에서 소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.\r\n\r\n## 풀이\r\n\r\n만약 10000등 큰 수가 들어온다면, 2부터 9999까지의 모든 수로 10000을 나눠보면 10000이 소수인지 아닌지 알 수 있다.<br/><br/>\r\n그러나 예를 들어 10000의 약수 2와 5000이 있을 때,\r\n2와 5000를 서로 곱해야 10000을 만들 수 있다.<br/><br/>\r\n\r\n이처럼 2부터 9999까지 서로를 곱해서 10000을 만들어내는 페어가 반드시 존재한다.\r\n\r\n> 2x5000 = 5000x2 = 10000\r\n> <br/><br/>\r\n\r\n그리고 이 페어는 가장자리에서부터 서로 짝을 짓기 때문에,\r\n어떤 수 n이 소수인지 알아보려면 2부터 n-1까지 전부 나눨볼 필요가 없고 2부터 루트(n)까지의 수로만 나눠봐도 충분하다.\r\n<br/><br/>\r\n\r\n위 알고리즘을 `에라토스테네스의 체`라고 한다. 이번 문제에서는 `에라토스테네스의 체` 방법을 사용해 풀어봤다.<br/><br/>\r\n\r\n```c++\r\nint n, k, flag, cnt;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tcin >> k;\r\n\t\tflag = 0;\r\n\t\tif (k == 1) flag = 1;\r\n\t\tfor (int j = 2; j <= sqrt(k); j++) {\r\n\t\t\tif (k % j == 0) {\r\n\t\t\t\tflag = 1;// not prime\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!flag) cnt++;\r\n\t}\r\n\r\n\tcout << cnt;\r\n}\r\n```\r\n"},{"excerpt":"작성중 UI 실습 UI 실습을 위해 버튼 UI를 하나 만들어준다. 상단의 UI 아이콘을 클릭한 뒤, 스크린의 좌측 상단 아이콘들 중 버튼을 생성하는 아이콘을 눌러 만든다. 해당 UI의 이름을 이라고 바꿔준다. 알아보기 쉽게 를 추가해서 MyButton 이라고 크게 적어줬다.   언제나 그렇듯이 MyDesk에서  -> 로 새 컴포넌트를 만든다. 컴포넌트 이…","fields":{"slug":"/2/"},"frontmatter":{"date":"July 19, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 7주차 화요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n작성중\r\n\r\n## UI 실습\r\n\r\nUI 실습을 위해 버튼 UI를 하나 만들어준다.<br/>\r\n\r\n- 상단의 UI 아이콘을 클릭한 뒤, 스크린의 좌측 상단 아이콘들 중 버튼을 생성하는 아이콘을 눌러 만든다.\r\n- 해당 UI의 이름을 `MyButton`이라고 바꿔준다. 알아보기 쉽게 `TextComponent`를 추가해서 MyButton 이라고 크게 적어줬다.\r\n\r\n![](./create-ui.png)\r\n\r\n<br/><br/>\r\n\r\n- 언제나 그렇듯이 MyDesk에서 `Create Scripts` -> `Create Component`로 새 컴포넌트를 만든다. 컴포넌트 이름은 `UIManager`이다.\r\n\r\n- 그 다음 컴포넌트에 `Button Click Event`를 등록하고 이벤트를 받는 대상을 `self`에서 `entity` 로 바꾼 뒤, `MyButton`을 등록해준다.\r\n\r\n![](add-event.png)\r\n"},{"excerpt":"문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로 첫 번째 풀이 중복을 제거해야하므로 set배열을 만들어 구현했다.\nset내부에서 정렬이 안되는줄알고 sort를 하려고했지만, set은 자체적으로 오름차순으로 정렬을 해서 sort를 할 필요가 없었다…","fields":{"slug":"/1181/"},"frontmatter":{"date":"July 18, 2022","title":"백준 1181 단어 정렬","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\r\n<br/><br/>\r\n\r\n1. 길이가 짧은 것부터\r\n2. 길이가 같으면 사전 순으로\r\n\r\n## 첫 번째 풀이\r\n\r\n중복을 제거해야하므로 set배열을 만들어 구현했다.<br/>\r\nset내부에서 정렬이 안되는줄알고 sort를 하려고했지만, set은 자체적으로 오름차순으로 정렬을 해서 sort를 할 필요가 없었다.<br/><br/>\r\n\r\n```c++\r\nint n;\r\nstring str;\r\nset<string> words[51]; //길이별로 문자열을 저장한다. (길이가 최대 50인 문자열만 들어온다)\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tcin >> str;\r\n\t\twords[str.size()].insert(str);\r\n\t}\r\n\r\n\tfor (int i = 0; i < 51; i++) {\r\n\t\t//sort(words[i].begin(), words[i].end());\r\n\t\tfor (auto w : words[i]) {\r\n\t\t\tcout << w << \"\\n\"; // set은 자체적으로 오름차순 정렬을 하므로 작은 길이의 문자열들부터 차례대로 출력한다.\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## 두 번째 풀이\r\n\r\nset에 임의로 비교함수를 설정해서 길이가 짧은 순으로, 길이가 같다면 사전순으로 정렬되게 한다.<br/>\r\n비교함수는 반환값이 true이면, 왼쪽이 오른쪽보다 먼저 나오게 해준다.<br/><br/>\r\n\r\n```c++\r\nstruct Compare\r\n{\r\n\tbool operator() (const string& _Left, const string& _Right) const {\r\n\t\tif (_Left.size() == _Right.size()) {\r\n\t\t\treturn _Left < _Right;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn _Left.size() < _Right.size();\r\n\t\t}\r\n\t}\r\n};\r\n\r\nint n;\r\nstring str;\r\nset<string, Compare> words;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tcin >> str;\r\n\t\twords.insert(str);\r\n\t}\r\n\tfor (auto w : words) {\r\n\t\tcout << w << \"\\n\";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"UI를 야무지게 활용하는 법 UI를 야무지게 활용하는 법... 어렵지 않아요~ 두 가지만 기억하면 된답니다. 정렬 스트레치  정렬 말그대로 UI 컴포넌트를 정렬한다! 왜 UI 컴포넌트는 정렬이 필요할까?🤔 에서 좌표를 설정할 수 있는 x, y, width등의 속성을 보면 원점을 기준으로 좌표와 크기가 정해지는 것을 알 수 있다.  원점을 기준으로 위치를 …","fields":{"slug":"/1-ui-concept/"},"frontmatter":{"date":"July 18, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 7주차 월요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## UI를 야무지게 활용하는 법\r\n\r\nUI를 야무지게 활용하는 법... 어렵지 않아요~ 두 가지만 기억하면 된답니다.<br/>\r\n\r\n1. 정렬\r\n2. 스트레치\r\n\r\n<br/><br/>\r\n\r\n### 정렬\r\n\r\n말그대로 UI 컴포넌트를 정렬한다!<br/>\r\n\r\n**왜 UI 컴포넌트는 정렬이 필요할까?🤔**<br/>\r\n\r\n> `UITransformComponent`에서 좌표를 설정할 수 있는 x, y, width등의 속성을 보면 원점을 기준으로 좌표와 크기가 정해지는 것을 알 수 있다. <br/>\r\n\r\n<br/>\r\n\r\n원점을 기준으로 위치를 정하면 기기마다 해상도가 다르기 때문에 UI 컴포넌트가 스크린밖으로 벗어나는 일이 생길 수도 있다. 때문에 정렬 기능을 사용해서 의도한 위치에 놓일 수 있도록 해야한다.<br/>\r\n\r\n`UITransformComponent`를 보면 우측 상단에 UI 컴포넌트를 정렬할 수 있는 아이콘이 있다. 해당 아이콘을 눌러서 원하는 위치에 정렬을 해주면 된다.\r\n\r\n\r\n\r\n### 스트레치\r\n\r\nUI 컴포넌트의 크기를 x, y로 지정하면 기기마다 화면의 크기가 다르기 때문에 컴포넌트가 화면을 삐져나가는 등 의도한 UI를 연출하지 못할 수도 있다.\r\n\r\n`UITransformComponent`의 우측 상단 아이콘(정렬을 설정했던 아이콘과 동일)을 클릭해 스트레치를 적용하면 Left와 Right로 상대적인 크기를 설정할 수 있다. (정렬을 설정했던 아이콘과 동일)\r\n\r\n\r\n\r\n### UI 컴포넌트 활용\r\n\r\nUI의 프로퍼티에 `ButtonComponent` 나 `TextComponent` 등을 추가하면, 해당 UI를 버튼으로 이용하거나 텍스트를 넣을수도 있다. UI도 하나의 Entity이니 여러 컴포넌트를 추가적으로 등록할 수 있다는걸 기억하자!\r\n\r\n\r\n\r\n## Group\r\n\r\n`SceneMaker`의 `ui`하위를 보면 ` DefaultGroup`등 Group이 있는 것을 볼 수 있다.<br/>\r\n\r\nGroup은 MapLayer처럼 **UI 전용 Layer**라고 생각하면 편하다.<br/>\r\n\r\n만약 돌발 이벤트 상황에 유저에게 팝업창 UI를 보여줘야한다고 치자. 이벤트 상황이 아니라면 유저에게 팝업창을 띄워줄 필요가 없다. UI를 Group으로 나눈다면 특정 상황에 맞게 보여줄 UI를 편리하게 선택할 수 있다.<br/>\r\n\r\n> 프로퍼티란 `UISprite`의 `Enable`속성을 통해 UI 활성화 여부를 결정할 수도 있지만, 그렇게 하면 개발중에 UI를 확인하기 이해 Enable을 다시 활성화 시키고 확인 후에 다시 활성화를 끄는 등 번거로움이 존재한다.<br/>\r\n>\r\n> Group을 설정하면 한 번에 UI들을 프리뷰할 수 있다. - 그룹의 프로퍼티란에서 `UIGroup`의 `Enable`속성을 조정\r\n\r\n\r\n\r\n### Group 활성화\r\n\r\nGroup을 활성화시키려면 `UISprite`의 `Enable`을 True로 하고 `UIGroupComponent`의 `DefaultShow`도 True로 설정해줘야한다. <br/>\r\n\r\n둘 중 하나만 하면 활성화가 되지않으므로 주의하자!\r\n\r\n\r\n\r\n## UI는 클라이언트에서만 적용\r\n\r\n`Scene Maker`에서 ui 객체들을 보면 초록색 아이콘이 붙어있는 것을 볼 수 있다.<br/>\r\n\r\n이는 클라이언트 전용이라는 의미로, 서버에서는 ui가 존재하지않는다.<br/>\r\n\r\n즉, UI는 로컬 엔티티이기 때문에(= 클라이언트단에서만 작용) Sync가 불가능하다.\r\n\r\n> Sync : 서버에 있는 값과 클라이언트에 있는 값을 동기화 \r\n\r\n\r\n\r\n## 회고\r\n\r\n이번 포스트에서는 UI 활용을 위한 이론 위주로 정리해봤다. \r\n\r\n한 가지 궁금한 점이 생겼는데 왜 `UITransformComponent`의 디폴트 속성이 스트레치를 적용한 `Left`, `Right`가 아니라 X, Y이냐이다. 나중에 팀원들이랑 얘기하면서 다시 생각해봐야겠다 ㅎㅎ.<br/>\r\n\r\n다음 포스트에서는 실습을 중심으로 UI를 정리해 볼 예정이다. <br/>\r\n"},{"excerpt":"문제 카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.\n\n한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.\n\n김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다…","fields":{"slug":"/2798/"},"frontmatter":{"date":"July 17, 2022","title":"백준 2798 블랙잭","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다. 카드의 합이 21을 넘지 않는 한도 내에서, 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.\r\n<br/><br/>\r\n한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.\r\n<br/><br/>\r\n김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다. 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다. 그런 후에 딜러는 숫자 M을 크게 외친다.\r\n<br/><br/>\r\n이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다. 블랙잭 변형 게임이기 때문에, 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.\r\n<br/><br/>\r\nN장의 카드에 써져 있는 숫자가 주어졌을 때, M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.\r\n\r\n## 풀이\r\n\r\n`next_permutation` 함수를 이용해 조합을 구현해서 풀었다<br/><br/>\r\n조합으로 카드를 세 개씩 임의로 뽑고 세 개의 숫자합을 구하며 가장 정답에 가까운 숫자합을 도출한다. <br/><br/><br/>\r\n\r\n```c++\r\nint n,m, ans, sum;\r\nint card[100];\r\nint k = 3;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n >> m;\r\n\tfor (int i = 0; i < n; i++) {//초기 카드 입력\r\n\t\tcin >> card[i];\r\n\t}\r\n\r\n\tvector<int> flag;\r\n\tfor (int i = 0; i < n - k; i++) {// 전체 카드 수 - 뽑아야 하는 카드 수(3개)만큼 0을 flag에 추가 == 뽑지않는 카드 수\r\n\t\tflag.push_back(0);\r\n\t}\r\n\r\n\twhile (k--) { // 뽑아야 하는 카드 수만큼(3개) 1을 flag에 추가\r\n\t\tflag.push_back(1);\r\n\t}\r\n\r\n\tdo {\r\n\t\tsum = 0;\r\n\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\tif (flag[i] == 1) { // flag에서 1이 있는 i번째는 더하고, 0인 i번째는 더하지않는다.\r\n\t\t\t\tsum += card[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (m - sum >= 0) { // 합이 m을 넘으면 안됨\r\n\t\t\tif (sum > ans) { // 합이 기존 ans보다 더 m에 가까운 수인지 확인\r\n\t\t\t\tans = sum;\r\n\t\t\t}\r\n\t\t}\r\n\t} while (next_permutation(flag.begin(), flag.end())); // next_permutation 함수를 이용해 flag원소들로 순열을 만듦\r\n\tcout << ans;\r\n}\r\n```\r\n"},{"excerpt":"Camera Component 플레이어가 움직이면 화면이 그에 맞춰 따라간다. 이는 가 플레이어에 설정되어있어 계속 플레이어를 카메라로 비추기 때문이다.  를 사용해서 화살표를 누르면 플레이어중심인 화면에서 멀리 떨어진 골 지점을 가리키고오게 하자! 골 지점을 보여주기  짜잔~ 위는 현재 맵의 구성도이다!  우측 상단의 종이 달린 하트모양 오브젝트를 플레…","fields":{"slug":"/5-camera/"},"frontmatter":{"date":"July 15, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 6주차 금요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n\r\n\r\n## Camera Component\r\n\r\n플레이어가 움직이면 화면이 그에 맞춰 따라간다. 이는 `CameraComponent`가 플레이어에 설정되어있어 계속 플레이어를 카메라로 비추기 때문이다. <br/>\r\n\r\n`Camera Component`를 사용해서 화살표를 누르면 플레이어중심인 화면에서 멀리 떨어진 골 지점을 가리키고오게 하자!<br/>\r\n\r\n\r\n\r\n### 골 지점을 보여주기\r\n\r\n![](map-view.png)\r\n\r\n짜잔~ 위는 현재 맵의 구성도이다! <br/>\r\n\r\n우측 상단의 종이 달린 하트모양 오브젝트를 플레이어가 도달할 골지점이라고 하자<br/>\r\n\r\n> 좌측 하단의 투명한 캐릭터 모양은 `SpawnLocation` Entity로, 플레이어가 스폰될 위치를 의미한다.\r\n>\r\n> `SpawnLocation` Model은 `MoDelList`란의 왼쪽 아래 별모양 아이콘인  `SpecialModel`을 누르면 볼 수 있다.\r\n\r\n\r\n\r\n<br/>\r\n\r\n![](player-zoom.png)\r\n\r\n게임을 실행하면 플레이어에게 카메라 초점이 맞춰지므로 위에 있는 골 지점까지는 보이지않는다.<br/>\r\n\r\n골 지점이 어디있는지 미리 보여주기위해, 화살표를 클릭하면 위의 골 지점이 있는 곳까지 올라가 보여주기로 하자!<br/>\r\n\r\n크게 다음과 같이 진행된다.<br/>\r\n\r\n1. goal Object에 `CameraComponent`등록\r\n2. arrow Object에 `TouchReceivedComponent` 등록\r\n3. arrow Object에 터치 이벤트 핸들러를 정의할 새 컴포넌트 등록\r\n\r\n<br/><br/>\r\n\r\n#### 📌 goal Object에 `CameraComponent`등록\r\n\r\n![](camerarea.png)\r\n\r\ngoal Object에 `CameraComponent`를 등록한다.<br/>\r\n\r\n`ConfineCameraArea`속성을 꺼둔다.\r\n\r\n* `ConfineCameraArea` 속성을 키면 위 Scene처럼 goal Object가 화면의 중앙에 있지않고 가장자리에 있는 것을 보여준다. 이는 카메라가 비치는 영역이 맵의 발판 영역으로 제한되기 때문이다.  (goal Object는 맵 발판의 끝에 있기때문에 발판이 있는 곳 까지만 보여줘서 가장자리에 보인다.)\r\n* `ConfineCameraArea`이 켜져있어도 카메라 offset이나 `UseCustomBound`를 켜 좌표를 조정하면 goal Object를 화면 정중앙에서 보여줄 수 있으나... 그냥 끄는게 더 쉽고 빠른 방법인 것 같다.\r\n\r\n\r\n\r\n<br/><br/>\r\n\r\n#### 📌 arrow Object에 `TouchReceivedComponent` 등록 & 터치 이벤트 핸들러를 정의할 새 컴포넌트 등록\r\n\r\narrow Object에 `TouchReceivedComponent`를 등록했다면, 터치 이벤트 핸들러를 정의할 새 컴포넌트를 생성해야한다. 새 컴포넌트의 내용은 다음과 같다.<br/>\r\n\r\n![](arrow-goal.png)\r\n\r\n* 우선 플레이어의 카메라 컴포넌트와 골 오브젝트의 카메라 컴포넌트를 가져온다.\r\n  * **유저의 컴포넌트는 `_UserService.LocalPlayer`에서 가져올 수 있다.**\r\n  * 골은 id를 가지고 entity를 불러온다음 entity의 카메라 컴포넌트를 저장한다.\r\n* 함수 `_CameraService:SwtichCameraTo`를 사용해 게임 화면을 보여주는 카메라를 변경할 수 있다.\r\n* arrow Object가 터치되면 goalCamera를 보여주고 5초뒤에 다시 플레이어의 Camera로 돌아가게 해준다.\r\n\r\n\r\n\r\n#### 📌 완성!\r\n\r\n게임을 실행하고 화살표를 누르면 카메라가 goal Object를 비춰줬다가 다시 플레이어 카메라로 돌아오는 것을 볼 수 있다.<br/>\r\n\r\n*화살표를 눌렀을 때 아래와 같이 골 지점을 보여주고 다시 돌아감*\r\n\r\n![](goal-zoom.png)\r\n\r\n\r\n\r\n<br/><br/>\r\n\r\n---\r\n\r\n이번 포스트에는 유저의 Input data와 상호작용 할 수 있는 컴포넌트들과 Sound Component를 학습했다.<br/>\r\n\r\n게임에 여러가지 퍼포먼스, 기능을 추가하기 위해선 컴포넌트를 얼마나 활용할 줄 아느냐가 중점일 것 같다. 재밌는 MOD 게임을 만들기 위해 개발자 문서를 보며 여러 컴포넌트들을 학습하고 적용하는 연습을 많이 해야할 것 같다.\r\n"},{"excerpt":"📌 미션1  XML 데이터 입력 기능 추가 현재 csv파일형태로 영화 목록 리스트를 받아오고있다. 미션1은 영화 목록 리스트를 xml형태로도 받아올 수 있게 확장하는 것이다.  이번 포스팅에서는 XML 데이터 입력 기능을 구현해보진않지만, 기능을 CSV reader와 XML reader로 나누기 위해 어떤 전략을 취하면 좋을지 얘기해보겠다.  1. 분기문…","fields":{"slug":"/4-mission1/"},"frontmatter":{"date":"July 15, 2022","title":"MovieBuddy - [미션1] XML 데이터 입력 기능 추가","tags":["spring"]},"rawMarkdownBody":"\r\n\r\n\r\n## 📌 [미션1]  XML 데이터 입력 기능 추가\r\n\r\n현재 csv파일형태로 영화 목록 리스트를 받아오고있다. 미션1은 영화 목록 리스트를 xml형태로도 받아올 수 있게 확장하는 것이다. <br/>\r\n\r\n이번 포스팅에서는 XML 데이터 입력 기능을 구현해보진않지만, 기능을 CSV reader와 XML reader로 나누기 위해 어떤 전략을 취하면 좋을지 얘기해보겠다. \r\n\r\n\r\n\r\n## 1. 분기문으로 로직을 분리해서 구현\r\n\r\n!<br/><br/><br/>\r\n\r\n첫 번째 방법은 분기문으로 로직을 분리하면 된다.<br/>\r\n\r\nCSV파일을 받는 함수 `loadMoviesCSV()`와 XML파일을 받는 함수`loadMoviesXML()`를 생성해 아래와 같이 분기문으로 로직을 분리한다.\r\n\r\n```java\r\nif (mode == \"CSV\"){\r\n    return loadMoviesCSV();\r\n} else if (mode == \"XML\"){\r\n    return loadMoviesXML();\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n> 그러나 이 방법에는 크나큰 단점이 있으니...<br/>\r\n>\r\n> 만약 또 다른 형식의 메타데이터를 읽어야 한다면, 계속해서 `load MoviesXXX()`라는 함수를 만들어야하고 분기문의 처리도 길어진다.<br/>\r\n>\r\n> 이렇게 새로운 기능을 추가해야할 때마다 기존의 코드를 변경해야한다면 버그가 발생할 확률이 높아진다.\r\n\r\n\r\n\r\n## 소프트웨어 개발시 지켜야 할 것\r\n\r\n> 오늘 완성해야 하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야 한다.\r\n\r\n<br/>\r\n\r\n개발을 시작하는 시점에서 모든 요구사항을 수집하는 것이 불가능에 가깝다. 개발이 진행되는 동안 요구사항이 변경되기때문에, 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 수용할 수 있도록 소프트웨어를 설계해야한다.<br/>\r\n\r\n<br/>\r\n\r\n`MovieFinder` 클래스에는 크게 두 가지 관심사가 있다.\r\n\r\n* CSV 파일로 작성된 영화 메타데이터를 읽어들이기\r\n* 조건에 맞는 영화를 검색하기\r\n\r\n<br/><br/>\r\n\r\n위 관심사를 상속과 다형성을 이용해서 분리해보자\r\n\r\n\r\n\r\n## 2. 상속과 다형성을 이용해 로직을 분리\r\n\r\n* `MovieFinder` 클래스를 추상화 클래스로, `loadMovies` 메소드도 추상 메소드로 변경한다.\r\n* `moviebuddy.domain`에 클래스 `CsvMovieFinder`과 `XmlMovieFinder`를 생성합니다.\r\n* 두 클래스 모두 `MovieFinder`를 상속받은 후, 내부에서 `loadMovies`를 정의합니다.\r\n  * `@Override` 어노테이션을 사용해 메소드 오버라이딩을 합니다.\r\n\r\n![](./csv.png)\r\n\r\n<br/><br/>\r\n\r\n> 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 구조를 템플릿 메소드 패턴이라고 한다.\r\n\r\n\r\n\r\n\r\n\r\n## 그럼 상속이 코드 재사용면에서 가장 좋은 방법일까?\r\n\r\n그렇진않다...! <br/>\r\n\r\n상속은 아래 두 가지 관점에서 설계에 안 좋은 영향을 끼친다.<br/>\r\n\r\n* 캡슐화를 위반한다.\r\n* 설계를 유연하지 못하게 만든다.\r\n\r\n<br/>\r\n\r\n코드를 재사용하기 위해서는 `상속`보다는 `합성`을 먼저 고려하는 것이 좋다. (추상 클래스보다는 인터페이스를 우선해라!)\r\n\r\n<br/>\r\n\r\n### 합성이란?\r\n\r\n합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.\r\n\r\n> 객체는 인터페이스를 통해 참조해라!\r\n\r\n<br/>\r\n\r\n**인터페이스**는 자바가 추상화를 위해 제공하는 유용한 도구이다. <br/>\r\n\r\n인터페이스는 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있으며,  참조되는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하게 만들어준다.<br/>\r\n\r\n<br/>\r\n\r\n즉, 코드를 재사용하기 위해서는 상속보다는 합성이 더 좋은 방법이다.<br/>\r\n\r\n<br/>\r\n\r\n상속을 이용한 방법에서 합성을 이용한 방법으로 다시 바꿔보자!\r\n\r\n\r\n\r\n## 3. 합성을 이용해 분리\r\n\r\n> `MovieFinder` 클래스를 추상 클래스에서 일반 클래스로 다시 바꾸고 새로운 인터페이스 `MovieReader`를 생성해보자\r\n>\r\n> * `MovieReader` 인터페이스는 내부에 `loadMovies`라는 메소드가 정의된다.\r\n> * `MovieReader` 인터페이스를 구현한 `CsvMovieReader`와 `XMlMovieReader`를 작성해보자!\r\n\r\n<br/>\r\n\r\n**위에서 상속과 다형성을 위해 수정한 코드를 모두 복구했다는 가정하의 과정입니다.**\r\n\r\n* `moviebuddy.domain`에 `MovieReader`라는 이름의 인터페이스를 생성한다.\r\n* `MovieReader`안에서 `loadMovies`라는 함수를 정의한다.\r\n\r\n```java\r\npackage moviebuddy.domain;\r\n\r\nimport java.util.List;\r\n\r\npublic interface MovieReader {\r\n\tList<Movie> loadMovies();\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n* `moviebuddy.domain` 에 클래스 `CsvMovieReader`를 만듭니다.\r\n* implements를 사용해서 `MovieReader`를 참조하게 한 뒤, 클래스안에서 오버라이딩을 사용해 함수 `loadMovies`를 작성합니다.\r\n\r\n![](./csvmoviereader.png)\r\n\r\n<br/>\r\n\r\n* `MovieFinder` 클래스에서 `MovieReader`객체를 생성 후 객체를 사용해 `loadMovies`함수를 불러옵니다.\r\n\r\n![](load-reader.png)\r\n"},{"excerpt":"Sound Component Object에서 Sound를 플레이 시킬 수도 있다. 상자 Object에서 쿵쿵거리는 소리가 나오게 해보자! 소리나는 상자 맵에는 소리가 나는 상자가 있다. 플레이어가 상자에 가까이 갈수록 쿵쿵거리는 소리가 커지게 해보자! 우선 Object에 를 추가하고, 원하는 Sound를 설정한다.  AudioClipRUID옆에 동그란 버…","fields":{"slug":"/4-sound/"},"frontmatter":{"date":"July 14, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 6주차 목요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n\r\n\r\n## Sound Component\r\n\r\nObject에서 Sound를 플레이 시킬 수도 있다.<br/>\r\n\r\n상자 Object에서 쿵쿵거리는 소리가 나오게 해보자!<br/>\r\n\r\n### 소리나는 상자\r\n\r\n맵에는 소리가 나는 상자가 있다.<br/>\r\n\r\n플레이어가 상자에 가까이 갈수록 쿵쿵거리는 소리가 커지게 해보자!<br/>\r\n\r\n* 우선 Object에 `SoundComponent`를 추가하고, 원하는 Sound를 설정한다.\r\n\r\n  ![](sound.png)\r\n\r\n> AudioClipRUID옆에 동그란 버튼을 클릭하면 Sound Resource들을 볼 수 있다.<br/>\r\n>\r\n> monster, skill등 종류별로 확인할 수 있고, 루디브리엄등 특정 키워드를 검색할수도있다.\r\n\r\n<br/>\r\n\r\n* Object에 Sound 등록이 완료되었다면, 플레이어에 등록된 컴포넌트안의 코드를 수정한다.\r\n\r\n  ![](sound-player.png)\r\n\r\n  * 유저마다 상자와의 거리가 상이하므로 함수는 `client only`로 설정한다.\r\n\r\n  * 상자Object의 아이디를 가지고 Entity를 가져온다.\r\n\r\n    > 아이디는 `Scene Maker`에서 해당 Object를 우클릭하고 `Copy Entity ID`를 클릭하면된다.\r\n\r\n  <br/>\r\n\r\n  * 상자의 `SoundComponent`도 가져온 뒤,\r\n\r\n  * `SetListenerEntity` 함수를 가지고 상자와의 거리에 따라서 소리가 커지고 작아지게 설정한다.\r\n\r\n    >  self.Entity는 플레이어를 의미하며, 상자 소리와 플레이어간의 거리를 고려하겠다는 의미이다.\r\n\r\n  <br/>\r\n\r\n  * `SetListenerEntity` 함수를 부르고 `Play`함수를 가지고 사운드를 다시 플레이한다.\r\n\r\n    > 이미 실행되고 있는 Sound는 `SetListenerEntity`함수를 설정해도 적용되지않는다.<br/>\r\n    >\r\n    >  다시 `Play`를 해줘서 `SetListenerEntity`가 반영되게한다.\r\n\r\n\r\n\r\n"},{"excerpt":"문제 상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\n\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 …","fields":{"slug":"/2839/"},"frontmatter":{"date":"July 13, 2022","title":"백준 2839 설탕배달","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.\r\n<br/>\r\n상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.\r\n<br/>\r\n상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\n- greedy 방식으로 바로 풀 수 있는 문제였다!\r\n\r\n### 첫 번째 방법 - 그리디 알고리즘\r\n\r\n```c++\r\nint n, cnt;\r\nint main() {\r\n\tcin >> n;\r\n\tint quo = n / 5;\r\n\tint flag = 0; // 봉지에 정확하게 나눠 담을 수 있는지 확인\r\n\tfor (int i = quo; i >= 0; i--) { // 5kg 봉지를 최대한 많이 사용할 수 있는 경우의 수 부터 체크\r\n\t\tint sub = i * 5;\r\n\t\tif ((n - sub) % 3 == 0) { // 5kg봉지로 담고 남은 양을 3kg봉지로 전부 담을 수 있는지 확인\r\n\t\t\tcnt = i + ((n - sub) / 3);\r\n\t\t\tflag = 1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (flag) cout << cnt;\r\n\telse cout << -1;\r\n}\r\n```\r\n\r\n### 두 번째 방법 - 다이나믹 프로그래밍\r\n\r\n- 다른 분의 풀이를 보니 다이나믹 프로그래밍으로도 풀 수 있었다.\r\n\r\n```c++\r\nint dp[5001]; //global 변수이기때문에 0으로 초기화된 배열\r\n\r\nint main() {\r\n\tint n;\r\n\tcin >> n;\r\n\tdp[3] = dp[5] = 1;\t//3kg와 5kg는 봉지 1개로 만들 수 있으므로 초기화 하고 시작\r\n\r\n\tfor (int i = 6; i <= n; i++) { // 1,2,4는 봉지 0개이므로 6부터 시작\r\n\t\tif (dp[i - 5]) dp[i] = dp[i - 5] + 1;\r\n\t\tif (dp[i - 3]) dp[i] = dp[i] ? dp[i] : dp[i - 3] + 1; // 5kg봉지를 많이 쓸수록 봉지수가 줄어드므로 위에서 이미 dp[i]를 채웠다면 그대로 dp[i]를 적용하고, dp[i]가 없다면 dp[i-3]+1을 적용\r\n\t}\r\n\tcout << (dp[n] == 0 ? -1 : dp[n]) << endl;\r\n\treturn 0;\r\n}\r\n```\r\n"},{"excerpt":"문제 팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.\n\n목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 …","fields":{"slug":"/18111/"},"frontmatter":{"date":"July 13, 2022","title":"백준 18111 마인크래프트","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n팀 레드시프트는 대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 × 1 × 1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.\r\n<br/><br/>\r\n목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’ 작업을 해야 한다.\r\n<br/><br/>\r\nlvalue는 세로 N, 가로 M 크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.\r\n<br/><br/>\r\n\r\n1. 좌표 (i, j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.\r\n2. 인벤토리에서 블록 하나를 꺼내어 좌표 (i, j)의 가장 위에 있는 블록 위에 놓는다.\r\n   <br/><br/>\r\n   1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’ 작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.\r\n   <br/><br/>\r\n   단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는 B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.\r\n   <br/><br/>\r\n\r\n## 풀이\r\n\r\n이번 문제는 특별한 자료구조를 사용하진않고, 로직을 짜서 바로 구현했다...<br/><br/>\r\n\r\n```c++\r\nint cnt[257]; // 높이가 idx인 블럭들을 카운트한다.\r\nint n, m, b, e;\r\nint sum, cur, need, extra, depth;\r\nint ans = INT_MAX;\r\n\r\nvoid count_time(int i) {\r\n\tfor (int j = 0; j < 257; j++) {\r\n\t\tif (i < j) {\r\n\t\t\tsum += cnt[j] * (j - i) * 2; // 높이가 i가 될 때까지 블럭을 제거하는데 걸리는 시간\r\n\t\t\textra += cnt[j] * (j - i); // 위 에서 블럭을 제거하고 추가적으로 획득하는 블럭\r\n\t\t}\r\n\t\telse if (i > j) {\r\n\t\t\tsum += cnt[j] * (i - j); // 높이가 i가 될 때까지 블럭을 쌓는데 걸리는 시간\r\n\t\t\tneed += cnt[j] * (i - j); // 위에서 블럭을 쌓는데 필요한 블럭\r\n\t\t}\r\n\t}\r\n\r\n\tif (b + extra - need >= 0) { // 쌓을 블럭이 부족한지 확인\r\n\t\tif (sum <= ans) { // 가장 빠른 소요시간을 찾기위해 비교\r\n\t\t\tans = sum;\r\n\t\t\tdepth = i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n >> m >> b;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\tcin >> e;\r\n\t\t\tcnt[e]++; // 높이가 e인 블럭들을 카운트\r\n\t\t}\r\n\t}\r\n\r\n\tfor (int i = 0; i < 257; i++) { // 모든 블럭들의 높이를 i로 만드는데 걸리는 시간을 체크한다.\r\n\t\tsum = 0; // 걸리는 시간\r\n\t\tneed = 0; // 높이를 i로 만드는데 필요한 블럭의 수\r\n\t\textra = 0; // 높이를 i를 만들면서 추가적으로 획득하는 블럭의 수\r\n\t\tcount_time(i);\r\n\t}\r\n\r\n\tcout << ans <<\" \"<< depth;\r\n}\r\n```\r\n"},{"excerpt":"문제 우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x > p 그리고 y > q 이라면 우리는 A의 덩치가 B의 덩치보다 \"더 크다\"고 말한다.…","fields":{"slug":"/7568/"},"frontmatter":{"date":"July 13, 2022","title":"백준 7568 덩치","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x > p 그리고 y > q 이라면 우리는 A의 덩치가 B의 덩치보다 \"더 크다\"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, \"덩치\"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다. <br/>\r\n\r\n<br/>\r\n\r\nN명의 집단에서 각 사람의 덩치 등수는 자신보다 더 \"큰 덩치\"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.\r\n\r\n<br/><br/>\r\n\r\n| 이름 | (몸무게, 키) | 덩치 등수 |\r\n| ---- | ------------ | --------- |\r\n| A    | (55, 185)    | 2         |\r\n| B    | (58, 183)    | 2         |\r\n| C    | (88, 186)    | 1         |\r\n| D    | (60, 175)    | 2         |\r\n| E    | (46, 155)    | 5         |\r\n\r\n<br/>\r\n위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.\r\n\r\n<br/><br/>\r\n\r\n## 풀이\r\n\r\n`tuple`을 사용해서 (몸무게, 키, 랭킹)의 정보를 담는다.<br/>\r\n\r\n`vector` v안에 모든 `tuple`을 담는다.<br/>\r\n\r\n가장 먼저 들어오는 튜플의 경우, 바로 벡터안에 넣고, <br/>\r\n\r\n그렇지않다면 벡터안의 모든 원소와 비교하며 랭킹을 정한다.<br/>\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n```c++\r\nint n, x, y;\r\nint a, b, idx, th;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\r\n\tvector<tuple<int, int, int>> v; // x, y, greater\r\n\ttuple<int, int, int> cur;\r\n\twhile (n--) {\r\n\t\tcin >> x >> y;\r\n\t\tint cur_th = 1; // 현재 튜플의 랭킹 - 1부터 시작\r\n\r\n\t\tif (v.empty()) { // first tuple\r\n\t\t\tcur = make_tuple(x, y, cur_th);\r\n\t\t\tv.push_back(cur);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (int j = 0; j < v.size(); j++) { // 벡터안의 모든 튜플들과 cur을 비교\r\n\t\t\t\ttie(a, b, th) = v[j];\r\n\t\t\t\tif (x > a and y > b) { // cur이 덩치가 더 크면, 비교한 튜플의 랭킹을 늘림\r\n\t\t\t\t\tth += 1;\r\n\t\t\t\t\tv[j] = make_tuple(a, b, th);\r\n\t\t\t\t}\r\n\t\t\t\telse if (x < a and y < b) { // cur이 덩치가 더 작으면, cur의 랭킹을 늘림\r\n\t\t\t\t\tcur_th++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcur = make_tuple(x, y, cur_th);\r\n\t\t\tv.push_back(cur);\r\n\t\t}\r\n\r\n\r\n\t}\r\n\tfor (int i = 0; i < v.size(); i++) {\r\n\t\ttie(a, b, th) = v[i];\r\n\t\tcout << th << \" \";\r\n\t}\r\n}\r\n```\r\n\r\n"},{"excerpt":"문제 지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.\n\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 …","fields":{"slug":"/1018/"},"frontmatter":{"date":"July 13, 2022","title":"백준 1018 체스판 다시 칠하기","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.\r\n<br/><br/>\r\n체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.\r\n<br/><br/>\r\n보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8\\*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.\r\n<br/><br/>\r\n\r\n## 풀이\r\n\r\n만약 체스판이 \"BWBW...\"로 시작한다면 B의 x좌표 + y좌표는 언제나 짝수고 W의 x좌표 + y좌표는 언제나 홀수이다.<br/>\r\n이를 이용해서 보드의 8x8만큼을 전부 순회하며, 해당 부분이 체스판이 된다면 얼마나 많은 색을 다시 칠해야하는지 카운트한다.<br/><br/>\r\n\r\n```c++\r\nint n,m;\r\nchar board[50][50];\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\r\n\tcin >> n >> m;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tfor (int j = 0; j < m; j++) {\r\n\t\t\tcin >> board[i][j]; //보드 입력\r\n\t\t}\r\n\t}\r\n\r\n\tint count_bw = 0; // B로 시작하는 체스판\r\n\tint count_wb = 0; // W로 시작하는 체스판\r\n\tint ans = INT_MAX; // 출력값\r\n\tint min_cnt;\r\n\r\n\tfor (int i = 0; i < n - 7; i++) {\r\n\t\tfor (int j = 0; j < m - 7; j++) {\r\n\t\t\tfor (int k = 0; k < 8; k++) {\r\n\t\t\t\tfor (int l = 0; l < 8; l++) { // 보드의 8x8크기만큼 하나씩 비교\r\n\t\t\t\t\tchar cur = board[i + k][j + l]; // 현재 보드판의 색\r\n\t\t\t\t\tif ((i + k + j + l) % 2) { //홀수\r\n\t\t\t\t\t\tif (cur != 'B') {\r\n\t\t\t\t\t\t\tcount_wb++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (cur != 'W') {\r\n\t\t\t\t\t\t\tcount_bw++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { // 짝수\r\n\t\t\t\t\t\tif (cur != 'B') {\r\n\t\t\t\t\t\t\tcount_bw++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (cur != 'W') {\r\n\t\t\t\t\t\t\tcount_wb++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmin_cnt = min(count_bw, count_wb); // 현재 보드의 8x8부분에서 색을 최소로 바꾸고 체스판을 만들 수 있는 수\r\n\t\t\tif (ans > min_cnt) { // min_cnt들 중, 가장 작은 min_cnt를 구해야 함\r\n\t\t\t\tans = min_cnt;\r\n\t\t\t}\r\n\t\t\tcount_bw = 0;\r\n\t\t\tcount_wb = 0;\r\n\t\t}\r\n\t}\r\n\tcout << ans << \"\\n\";\r\n}\r\n```\r\n"},{"excerpt":"문제 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.  달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다. 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오. 풀이 손으로 하나하나 적어가면서 규칙을 찾았다…","fields":{"slug":"/2869/"},"frontmatter":{"date":"July 13, 2022","title":"백준 2869 달팽이는 올라가고 싶다","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다. <br/>\r\n\r\n달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.<br/>\r\n\r\n달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.<br/>\r\n\r\n## 풀이\r\n\r\n손으로 하나하나 적어가면서 규칙을 찾았다... <br/>\r\n\r\n### 첫 번째 풀이\r\n\r\n```c++\r\ndouble a,b,v;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\tcin >> a >> b >> v;\r\n\tdouble x = v / (a - b);\r\n\tx = ceil(x);\r\n\r\n\tdouble y = a + x * (a - b); // 낮에 a만큼 먼저 올라가니까 a를 더함\r\n\r\n\tdouble z = y - v;\r\n\r\n\tint sub = z / (a - b);\r\n\r\n\tint ans = x - sub + 1;\r\n\tcout << ans << \"\\n\";\r\n\r\n}\r\n```\r\n\r\n### 두 번째 풀이\r\n\r\n위에서 난리를 치며 풀었지만, 단 한 줄로 간단하게 풀 수 있다. <br/>\r\n`(V - B - 1) / (A - B) + 1`을 하면 원하는 답이 나온다.<br/>\r\n<br/>\r\n\r\n- 골에 도달하는 날은 미끄러지지않으므로, V에서 B를 뺀다.\r\n- (V - B)를 하루동안 최종적으로 올라간 만큼인 (A - B)로 나눈다.\r\n- (V - B) / (A - B) 했을 때 딱 나눠 떨어지지 않을 수도 있다.\r\n- 나눠 떨어지지않는다면 올림을 해야 답과 같으므로 마지막에 +1을 해준다.\r\n- 딱 나눠 떨어질 수도 있으므로 미리 (V - B)에 1을 뺀다.\r\n  <br/>\r\n  <br/>\r\n\r\n```c++\r\ndouble a,b,v;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\tcin >> a >> b >> v;\r\n\r\n\tint ans = (v - b - 1) / (a - b) + 1;\r\n\r\n\tcout << ans << \"\\n\";\r\n}\r\n\r\n```\r\n"},{"excerpt":"문제 2와 5로 나누어 떨어지지 않는 정수 n(1 ≤ n ≤ 10000)가 주어졌을 때, 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하시오.\n 배수는 어떤 수 n을 곱해서 만들 수 있는 수를 의미한다.\n1로만 이루어진 n의 배수는 1, 11, 111, 1111 ... 을 의미한다\n 풀이 입력을 계속 받으므로 을 사용한다. while(scanf(%d,…","fields":{"slug":"/4375/"},"frontmatter":{"date":"July 13, 2022","title":"백준 4375 1","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n2와 5로 나누어 떨어지지 않는 정수 n(1 ≤ n ≤ 10000)가 주어졌을 때, 1로만 이루어진 n의 배수를 찾는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n> 배수는 어떤 수 n을 곱해서 만들 수 있는 수를 의미한다.\r\n> 1로만 이루어진 n의 배수는 1, 11, 111, 1111 ... 을 의미한다\r\n> <br/>\r\n\r\n## 풀이\r\n\r\n- 입력을 계속 받으므로 `while (cin >> n)`을 사용한다.\r\n  > while(scanf(%d,&n) != EOF) 도 가능하다.\r\n  > <br/><br/>\r\n\r\n### 첫 번째 시도 - 시간초과\r\n\r\ncmp는 배수를 의미한다. cmp가 n으로 나눠지지않는다면 1 -> 11 -> 111 ... 순으로 증가한다.<br/>\r\n단순히 cmp = cmp \\* 10 + 1 했을 때 시간초과가 나는 것을 볼 수 있다. cmp의 수가 너무 커졌기 때문으로 보인다. <br/>\r\ncnt는 cmp의 자리수를 의미한다. <br/> <br/> <br/>\r\n\r\n```c++\r\nint n;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\twhile (cin >> n) {\r\n\t\tlong long cmp = 1;\r\n\t\tint cnt = 1;\r\n\t\twhile (cmp%n != 0) {\r\n\t\t\tcmp = cmp * 10 + 1;\r\n\t\t\tcnt += 1;\r\n\t\t}\r\n\t\tcout << cnt << \"\\n\";\r\n\t}\r\n}\r\n```\r\n\r\n### 두 번째 시도\r\n\r\nmod 연산은 아래와 같은 공식으로 풀 수 있다. <br/><br/>\r\n\r\n- (A+B)%N=(A%N+B%N)%N\r\n- (A∗B)%N=(A%N)∗(B%N)%N\r\n- (A−B)%N=((A%N)−(B%N)+N)%N\r\n  <br/>\r\n  우리는 ( cmp \\* 10 + 1 ) % n한 값을 체크해야하므로, <br/><br/>\r\n\r\n```c++\r\nwhile (cmp%n != 0) {\r\n\t\t\tcmp = cmp * 10 + 1;\r\n\t\t\tcnt += 1;\r\n\t\t}\r\n```\r\n\r\n<br/><br/>\r\n위 부분을 다음과 같이 바꿔준다.<br/>\r\n\r\n```c++\r\nwhile (cmp%n != 0) {\r\n\t\t\tcmp = (cmp%n) * (10%n) + 1;\r\n\t\t\tcnt += 1;\r\n\t\t}\r\n```\r\n\r\n<br/>\r\ncmp에 %n연산을 추가하면 시간초과문제가 해결되는 것을 볼 수 있다.<br/>\r\n전체 코드는 다음과 같다. <br/>\r\n```c++\r\nint n;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\twhile (cin >> n) {\r\n\t\tlong long cmp = 1;\r\n\t\tint cnt = 1;\r\n\t\twhile (cmp%n != 0) {\r\n\t\t\tcmp = (cmp%n) * (10%n) + 1;\r\n\t\t\tcnt += 1;\r\n\t\t}\r\n\t\tcout << cnt << \"\\n\";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"스크린 터치 이벤트란? 유저가 스크린을 터치하면 그에 대한 피드백을 보내준다 게임 화면의 어떤 부분을 터치하면 좌표를 출력하게 해보자! 컴포넌트에 아래 코드를 작성한다.  에 컴포넌트를 등록하고 실행하면 로그가 잘 찍히는 것을 볼 수 있다.","fields":{"slug":"/3-screen-touch/"},"frontmatter":{"date":"July 13, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 6주차 수요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 스크린 터치 이벤트란?\r\n\r\n> 유저가 스크린을 터치하면 그에 대한 피드백을 보내준다\r\n\r\n게임 화면의 어떤 부분을 터치하면 좌표를 출력하게 해보자!\r\n\r\n* 컴포넌트에 아래 코드를 작성한다.\r\n\r\n![](xy-code.png)\r\n\r\n<br/>\r\n\r\n* `DefaultPlayer`에 컴포넌트를 등록하고 실행하면 로그가 잘 찍히는 것을 볼 수 있다.\r\n\r\n![](xy-log.png)\r\n\r\n\r\n\r\n"},{"excerpt":"문제 자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.\n\n첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.. 풀이 간단한 문제인 것 같지만, 수들이 2,147,483,647로 크기가 크…","fields":{"slug":"/1629/"},"frontmatter":{"date":"July 12, 2022","title":"백준 1629 곱셈","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.\r\n<br/>\r\n첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다..<br/>\r\n\r\n## 풀이\r\n\r\n간단한 문제인 것 같지만, 수들이 2,147,483,647로 크기가 크므로 그냥 곱하면 오버헤드가 일어난다.<br/>\r\n`분할정복 거듭제곱`을 이용하면 오버헤드없이 계산을 할 수 있다.<br/>\r\n![](algorithm.png)\r\n\r\n### 첫 번째 시도\r\n\r\n위 공식을 재귀함수로 구현했다.\r\nmod 연산을 마지막에 하지않고 각 원소들을 곱셈연산하기전 mod를 먼저하고 곱했다.\r\n\r\n```c++\r\ntypedef long long ll;\r\nll a, b, c;\r\nint mod(ll x, ll y) {\r\n\tif (y == 1) {\r\n\t\treturn x%c;\r\n\t}\r\n\tll C = mod(x, y/2);\r\n\tif (y % 2) { //홀수\r\n\t\treturn (C%c *C%c*x%c);\r\n\t}\r\n\telse {\r\n\t\treturn (C%c * C%c);\r\n\t}\r\n}\r\nint main() {\r\n\tcin >> a >> b >> c;\r\n\tcout << mod(a, b);\r\n}\r\n```\r\n\r\n### 두 번째 시도\r\n\r\n컴퓨터 보안시간에 `Fast Modular Exponentiation Algorithm`을 배워 적용해봤다!\r\n\r\n> 보안 공부한걸 활용할 수 있어 기쁘다... 흑흑\r\n> <br/><br/>\r\n\r\n- `#include <bitset>`을 해서 bitset 라이브러리를 가져온다.\r\n- bitset을 사용해서 10진수 모듈러인 b를 2진수로 변환한다.\r\n- 변환한 2진수를 가지고 `Fast Modular Exponentiation Algorithm`을 적용한다.\r\n\r\n```c++\r\ntypedef long long ll;\r\nll a, b, c, f;\r\n\r\nint main() {\r\n\tcin >> a >> b >> c;\r\n\tbitset<100> bs(b);\r\n\tstring s = bs.to_string();\r\n\ts = s.substr(s.find('1'));\r\n\r\n\tf = 1;\r\n\tfor (int i = 0; i < s.size(); i++) {\r\n\t\tf = (f * f) % c;\r\n\t\tif (s[i] == '1') {\r\n\t\t\tf = (f * a) % c;\r\n\t\t}\r\n\t}\r\n\tcout << f;\r\n}\r\n```\r\n"},{"excerpt":"문제 이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 '좋은 단…","fields":{"slug":"/3986/"},"frontmatter":{"date":"July 12, 2022","title":"백준 3986 좋은단어","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 '좋은 단어'나 세보기로 마음 먹었다.\r\n<br/>\r\n평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 '좋은 단어'이다. 평석이가 '좋은 단어' 개수를 세는 것을 도와주자.<br/>\r\n\r\n## 풀이\r\n\r\n### 첫 번째 시도\r\n\r\n문자열의 원소를 하나하나 확인하며 다음 과정을 진행한다.\r\n\r\n- 벡터 v안에는 pair가 없는 문자들이 들어가서 대기하게 된다.\r\n- `last`는 벡터 v의 마지막 원소이다. (v.back())\r\n- 새로 들어오는 원소의 flag를 증가시킨다. (flag[0]은 A의 flag, flag[1]은 B의 flag이다.)\r\n- 새로 들어오는 원소가 `last`와 같다면 벡터에서 `last`를 pop하고 해당 flag를 -2한다.\r\n- `last`와 같지않다면 벡터안에 넣는다.\r\n\r\n```c++\r\nint n, cnt;\r\nstring str;\r\nint flag[2];\r\nvector<char> v;\r\nchar last = 'X';\r\nint main() {\r\n\tcin >> n;\r\n\twhile (n--) {\r\n\t\tcin >> str;\r\n\t\tfor (int i = 0; i < str.size(); i++) {\r\n\t\t\tif (!v.empty()) last = v.back();\r\n\t\t\telse last = 'X';\r\n\t\t\tflag[str[i] - 'A']++;\r\n\t\t\tif (last == str[i]) {\r\n\t\t\t\tflag[str[i] - 'A'] -= 2;\r\n\t\t\t\tv.pop_back();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tv.push_back(str[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (v.empty()) cnt++;\r\n\t\tv.clear();\r\n\t\tflag[0] = 0;\r\n\t\tflag[1] = 0;\r\n\t}\r\n\tcout << cnt;\r\n}\r\n```\r\n\r\n### 두 번째 시도\r\n\r\n다른 분들의 풀이를 보며 굳이 flag로 확인할 필요가 없다는 걸 깨달았다...ㅎㅎ<br/>\r\n위 코드를 단순화한 코드이다. \\+ stack의 기능만으로 구현이 충분하므로 vector에서 stack으로 바꿔줬다.\r\n\r\n<br/><br/>\r\n\r\n```c++\r\nint n, cnt;\r\nstring str;\r\nstack<char> s;\r\nint main() {\r\n\tcin >> n;\r\n\twhile (n--) {\r\n\t\tcin >> str;\r\n\t\tfor (auto c : str) {\r\n\t\t\tif (!s.empty() and s.top() == c) s.pop();\r\n\t\t\telse s.push(c);\r\n\t\t}\r\n\t\tif (s.empty()) cnt++;\r\n\t\ts = stack<char>();\r\n\t}\r\n\tcout << cnt;\r\n}\r\n```\r\n"},{"excerpt":"터치 이벤트란? 유저가 어떤 Entity를 터치하면 그에 대한 피드백을 보내준다 플레이어를 터치하면 로그가 출력되게 해보자! 컴포넌트에서  이벤트를 등록하고 로그를 출력하는 코드를 작성한다.  해당 컴포넌트를 에 등록한다. TouchEvent를 받기 위해선 Entity에 TouchReceiveComponent를 등록해야한다. 에 를 등록한다.  플레이어를…","fields":{"slug":"/2-touch-event/"},"frontmatter":{"date":"July 12, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 6주차 화요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n\r\n\r\n## 터치 이벤트란?\r\n\r\n> 유저가 어떤 Entity를 터치하면 그에 대한 피드백을 보내준다\r\n\r\n플레이어를 터치하면 로그가 출력되게 해보자!\r\n\r\n* 컴포넌트에서 `TouchEvent` 이벤트를 등록하고 로그를 출력하는 코드를 작성한다.\r\n\r\n![](touch-event.png)\r\n\r\n<br/>\r\n\r\n* 해당 컴포넌트를 `DefaultPlayer`에 등록한다.\r\n* **TouchEvent를 받기 위해선 Entity에 TouchReceiveComponent를 등록해야한다.**\r\n* `DefaultPlayer`에 `TouchReceiveComponent`를 등록한다.\r\n\r\n![](receive.png)\r\n\r\n<br/>\r\n\r\n* 플레이어를 클릭하면 로그가 잘찍히는 것을 볼 수 있다.\r\n\r\n![](touched.png)\r\n\r\n\r\n\r\n### 터치 예시 - 터치하면 싫어하는 나무\r\n\r\n터치하면 \"터치하지 마세요.\"라고 말하는 나무 Object를 만들어보자!\r\n\r\n* 나무 Object에 `TouchReceiveComponent`를 추가한다.\r\n* `ChatBalloonComponent`를 추가한다.\r\n\r\n![](chat.png)\r\n\r\n> `ChatBalloonComponent`의 `Message`를 사용해 나무 Object가 \"나무입니다\" 라고 말하게한다.\r\n>\r\n> * `AutoShowEnable` 활성화해야 말풍선이 보인다.\r\n> * `HideDuration`을 0으로 해서 말풍선이 계속 보이게 한다.\r\n\r\n<br/>\r\n\r\n* 터치 이벤트에 피드백을 보내줄 컴포넌트를 생성하고 오브젝트에 등록한다. (DontTouch)\r\n\r\n* 컴포넌트에 다음과 같이 코드를 작성한다.\r\n\r\n![](donttouch.png)\r\n\r\n> TouchEvent 핸들러를 등록하고, 이벤트를 받으면 말풍선의 메시지를 \"터치하지마세요\" 로 바꾼다.\r\n>\r\n> 2초뒤에 원래 메시지였던 \"나무입니다\"로 돌아간다.\r\n\r\n<br/>\r\n\r\n* 게임을 실행시키고 나무를 클릭하면 말풍선이 잘 변경되는 것을 볼 수 있다.\r\n\r\n<br/>\r\n\r\n* 나무 누르기 전\r\n\r\n![](before-click.png)\r\n\r\n<br/>\r\n\r\n* 나무 누른 후\r\n\r\n![](after-click.png)\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"관심사의 분리 & 계층화 Spring은 객체 지향 프로그래밍을 지향한다. 기능(관심)별로 객체를 분리하는 것을 라고 한다. 관심이 같은 것을 한 곳으로 모으고 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리한다. 복잡한 소프트웨어를 계층으로 나눔으로써 관심사를 분리한다. 앤터프라이즈 애플리케이션은 크게 3가지로 계층을 나눈다. (필요에 따라서 더 …","fields":{"slug":"/3-layering/"},"frontmatter":{"date":"July 12, 2022","title":"Spring 관심사 분리","tags":["spring"]},"rawMarkdownBody":"\r\n## 관심사의 분리 & 계층화\r\n\r\n> Spring은 객체 지향 프로그래밍을 지향한다.\r\n>\r\n> 기능(관심)별로 객체를 분리하는 것을 `관심사의 분리`라고 한다.\r\n\r\n<br/>\r\n\r\n- 관심이 같은 것을 한 곳으로 모으고 다른 것은 따로 떨어뜨려 서로 영향을 주지 않도록 분리한다.\r\n- 복잡한 소프트웨어를 계층으로 나눔으로써 관심사를 분리한다.\r\n- 앤터프라이즈 애플리케이션은 크게 3가지로 계층을 나눈다. (필요에 따라서 더 세분화된 계층을 가질 수도 있다.)\r\n\r\n### 프레젠테이션\r\n\r\n- 사용자와 소프트웨어간 상호작용을 처리한다.\r\n\r\n- HTML기반 웹 UI나 모바일 앱으로 만들어지는 경우가 가장 많다.\r\n- 데스크톱이나 명령줄 기반 클라이언트도 있다.\r\n- 사용자에게 정보를 표시하고 사용자가 입력한 명령을 도메인과 데이터 원본에서 수행할 수 있는 작업으로 해석한다.\r\n\r\n> ex) 유저 명령을 받고, 요청한 영화 목록 결과를 출력\r\n\r\n### 도메인\r\n\r\n- **핵심 업무 논리를 처리하는 객체들**로 구성되며 엔터프라이즈 애플리케이션에서 가장 중요한 자산이다.\r\n- 비즈니스 논리라고도 부른다.\r\n\r\n> ex) 영화 메타데이터를 읽고 검색\r\n\r\n### 데이터 원본\r\n\r\n- 파일 또는 데이터베이스 시스템등과 데이터 송/수신을 처리한다.\r\n- 메시징 솔루션, 다른 엔터프라이즈 애플리케이션 등의 다른 시스템과 통신하며 데이터를 조회하거나 저장하는 등의 처리를 한다.\r\n\r\n## 도메인 관심사를 분리해보자\r\n\r\n`moviebuddy` 프로젝트의 도메인 관심사 두 개를 분리해보자!\r\n\r\n- 사용자 명령을 입력받아 비즈니스 로직을 실행하고 결과를 출력하는 관심사 (프레젠테이션)\r\n- csv 파일로 작성된 영화 메타데이터를 읽어 들인 후 조건에 맞는 영화를 검색하는 관심사\r\n\r\n#### 📌 도메인 패키지를 생성하고, 도메인에 관련되어 있는 클래스인 `Movie` 클래스를 이동시킨다.\r\n\r\n![](./create_domain.png)\r\n\r\n- moviebuddy에서 우클릭 -> `New` -> `Pakage`로 패키지 생성\r\n- 생성한 패키지 moviebuddy.domain으로 `Movie`클래스를 옮긴다.\r\n\r\n#### 📌 Moviebuddy.domain안에 MovieFinder클래스를 생성한다.\r\n\r\n> 도메인에는 애플리케이션의 핵심로직을 처리하는 객체를 넣는다.\r\n\r\n- 영화 목록을 불러들이고 영화를 검색하는 코드를 도메인으로 이동시킨다.\r\n\r\n- `MovieFinder`라는 클래스를 생성하고 `MovieBuddyApplication`에 있는 loadMovies, directedBy, releasedYearBy메소드를 이동시킨다.\r\n- `MovieBuddyApplication`에 있는 `run` method 아래에 `final MovieFinder movieFinder = new MovieFinder();` 코드를 작성해 MovieFinder객체를 생성한다.\r\n- `MovieBuddyApplication`의 directedBy, releasedYearBy메소드를 호출하는 부분을 MovieFinder.directedBy와 같은 형식으로 바꾼다.\r\n\r\n- src/test/java아래의 `MovieBuddyApplicationTest.java`클래스도 비슷하게 변경해준다.\r\n\r\n![](./modify_test.png)\r\n\r\n> **굳이 안해도 되지만 추가적으로 할 것**<br/>\r\n>\r\n> 클래스 이름도 MovieFinderTest로 변경해준다.\r\n>\r\n> - 클래스 이름에서 우클릭 후 `Refactor` -> `Rename`을 누른 뒤 변경후 이름 바운더리 밖에서 엔터를 치면 변경 창이 나오고 클래스명이 변경된다.\r\n>\r\n> test 클래스도 new pakage를 통해 도메인 폴더를 만들고 옮겨준다.\r\n\r\n<br/>\r\n\r\n#### 📌 부록\r\n\r\n![](test-import.png)\r\n\r\n- 사용하지않는 클래스들이 import 된 것을 볼 수 있다.\r\n- import 최적화는 단축키 `ctrl` + `O` +`shift`를 통해 할 수 있다.\r\n- 단축키는 preference에서 확인해볼 수 있다.\r\n\r\n![](./ref-keys.png)\r\n\r\n<br/>\r\n\r\n> 자동완성 단축키는 ctrl+space\r\n\r\n<br/><br/><br/>\r\n\r\n관심사 분리까지 완료했다!<br/>\r\n\r\n다음 시간에는 \r\n"},{"excerpt":"문제 'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.\n\n게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의…","fields":{"slug":"/3190/"},"frontmatter":{"date":"July 11, 2022","title":"백준 11655 ROT13","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.\r\n<br/>\r\n게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.\r\n<br/>\r\n뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.\r\n<br/>\r\n먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.\r\n만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.\r\n만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.\r\n사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.\r\n<br/>\r\n\r\n## 풀이\r\n\r\ndeque를 이용해 뱀의 body 좌표 정보를 저장했다.<br/>\r\n뱀이 바라보는 방향은 0, 1, 2, 3 총 네가지가 있으며 각각 up, right, down, left를 의미한다. <br/>\r\n초기값을 입력받고 게임을 시작한다.<br/>\r\n뱀의 방향 변화가 일어나는 시간과 현재 시간을 비교하며 2번째 while문을 돌린다.<br/>\r\n뱀이 한 방향으로 가는 만큼 while문을 돌렸다면, 회전 방향에 따라 뱀이 바라보는 방향을 변화시키고 다음 time slice만큼 또 while문을 돌린다.<br/>\r\n가장 바깥의 while문이 break 되었다면,<br/>\r\n\r\n1. 뱀이 주어진 방향 변화를 모두 마쳤지만 아직 죽지않았는지(== flag가 0)\r\n2. 뱀이 map의 바운더리에 부딪혔거나, 몸에 부딪혀 죽었는지(== flag가 1)\r\n   판단하고 1번이라면 뱀이 죽을때까지 cur_time을 카운트한다.<br/>\r\n   <br/><br/>\r\n   apple을 먹었다면 apple의 값을 1에서 0으로 바꿔줘야하는 것을 간과해 처음에 실패했었다<br/>\r\n   일어날 경우의 수를 세세하게 짜자!<br/><br/>\r\n\r\n```c++\r\nint N,K,L;\r\nint apple[101][101];\r\nint direction = 1; //0, 1, 2, 3 : up, right, down, left\r\npair<int, char> rotation[100];\r\nint rotation_cnt = 0;\r\ndeque<pair<int, int>> body;\r\nbool flag = 0;\r\nint cur_time = 0;\r\nvoid change_direction(char c) {\r\n\tif (c == 'D') {\r\n\t\tif (direction == 3) {\r\n\t\t\tdirection = 0;\r\n\t\t}\r\n\t\telse direction++;\r\n\t}\r\n\telse if (c == 'L') {\r\n\t\tif (direction == 0) {\r\n\t\t\tdirection = 3;\r\n\t\t}\r\n\t\telse direction--;\r\n\t}\r\n}\r\nbool check_flag(int x, int y, int f) {\r\n\t// map idx out of range\r\n\tif (f == 1) {\r\n\t\tif (y > N or y < 1) {\r\n\t\t\tflag = 1;\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\tif (f == 0) {\r\n\t\tif (x > N or x < 1) {\r\n\t\t\tflag = 1;\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// body collision\r\n\tif (find(body.begin(), body.end(), make_pair(x, y)) != body.end()) {\r\n\t\tflag = 1;\r\n\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\nint main() {\r\n\t//init\r\n\tcin >> N >> K;\r\n\tint a, b;\r\n\twhile (K--) {\r\n\t\tcin >> a >> b;\r\n\t\tapple[a][b] = 1;\r\n\t}\r\n\tcin >> L;\r\n\tint t;\r\n\tchar r;\r\n\tfor (int i = 0; i < L; i++) {\r\n\t\tcin >> t >> r;\r\n\t\trotation[i] = make_pair(t, r);\r\n\t}\r\n\t// game start\r\n\tint r_idx = 0;\r\n\tbody.push_back(make_pair(1,1));\r\n\r\n\twhile (!flag) {\r\n\t\tif (r_idx == L) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\twhile (rotation[r_idx].first != cur_time) {\r\n\t\t\tpair<int, int> head = body.back();\r\n\t\t\tint x = head.first;\r\n\t\t\tint y = head.second;\r\n\r\n\t\t\t// up\r\n\t\t\tif (direction == 0) {\r\n\t\t\t\tx--;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\tif (check_flag(x, y, 0)) break;\r\n\t\t\t\tbody.push_back(make_pair(x, y));\r\n\t\t\t}\r\n\t\t\telse if (direction == 1) {\r\n\t\t\t\ty++;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\tif (check_flag(x, y, 1)) break;\r\n\t\t\t\tbody.push_back(make_pair(x, y));\r\n\t\t\t}\r\n\t\t\telse if (direction == 2) {\r\n\t\t\t\tx++;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\tif (check_flag(x, y, 0)) break;\r\n\t\t\t\tbody.push_back(make_pair(x, y));\r\n\t\t\t}\r\n\t\t\telse if (direction == 3) {\r\n\t\t\t\ty--;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\tif (check_flag(x, y, 1)) break;\r\n\t\t\t\tbody.push_back(make_pair(x, y));\r\n\t\t\t}\r\n\t\t\t//check apple\r\n\t\t\tif (apple[x][y] == 1) {\r\n\t\t\t\tapple[x][y] = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbody.pop_front();\r\n\t\t\t}\r\n\t\t}\r\n\t\tchange_direction(rotation[r_idx].second);\r\n\t\tr_idx++;\r\n\t}\r\n\r\n\t// rotation end, but not dead\r\n\tif (flag == 0) {\r\n\t\tif (direction == 0) {//up\r\n\t\t\tpair<int, int> head = body.back();\r\n\t\t\tint x = head.first;\r\n\t\t\tint y = head.second;\r\n\t\t\twhile (x > 0) {\r\n\t\t\t\tx--;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\t// body collision\r\n\t\t\t\tif (find(body.begin(), body.end(), make_pair(x, y)) != body.end()) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check apple\r\n\t\t\t\tif (apple[x][y] != 1) {\r\n\t\t\t\t\tbody.pop_front();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (direction == 1) {//right\r\n\t\t\tpair<int, int> head = body.back();\r\n\t\t\tint x = head.first;\r\n\t\t\tint y = head.second;\r\n\t\t\twhile (y <= N) {\r\n\t\t\t\ty++;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\t// body collision\r\n\t\t\t\tif (find(body.begin(), body.end(), make_pair(x, y)) != body.end()) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// check apple\r\n\t\t\t\tif (apple[x][y] != 1) {\r\n\t\t\t\t\tbody.pop_front();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (direction == 2) {//down\r\n\t\t\tpair<int, int> head = body.back();\r\n\t\t\tint x = head.first;\r\n\t\t\tint y = head.second;\r\n\t\t\twhile (x <= N) {\r\n\t\t\t\tx++;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\t// body collision\r\n\t\t\t\tif (find(body.begin(), body.end(), make_pair(x, y)) != body.end()) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// check apple\r\n\t\t\t\tif (apple[x][y] != 1) {\r\n\t\t\t\t\tbody.pop_front();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (direction == 3) {//left\r\n\t\t\tpair<int, int> head = body.back();\r\n\t\t\tint x = head.first;\r\n\t\t\tint y = head.second;\r\n\t\t\twhile (y > 0) {\r\n\t\t\t\ty--;\r\n\t\t\t\tcur_time++;\r\n\t\t\t\t// body collision\r\n\t\t\t\tif (find(body.begin(), body.end(), make_pair(x, y)) != body.end()) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// check apple\r\n\t\t\t\tif (apple[x][y] != 1) {\r\n\t\t\t\t\tbody.pop_front();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << cur_time;\r\n}\r\n```\r\n"},{"excerpt":"오랜만에 돌아온 mod 회고록입니다 > <  주차별로 하나씩 포스팅하고 있었는데, mod 서포터즈를 모집후 월~금마다 하나씩 쓰는 것으로 규칙이 바뀌어서 앞으로는  라는 형식으로 주에 5개씩 포스팅할 예정이다.ㅎㅎ 그럼 다시 힘차게 학습 내용을 포스팅해보자...!ㅎㅎ Input Service 유저가 특정 입력을 누르면 해당 입력에 대한 피드백을 전달한다.…","fields":{"slug":"/1-key-input/"},"frontmatter":{"date":"July 11, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 6주차 월요일 회고","tags":["mod"]},"rawMarkdownBody":"\r\n오랜만에 돌아온 mod 회고록입니다 > < <br/>\r\n\r\n주차별로 하나씩 포스팅하고 있었는데, mod 서포터즈를 모집후 월~금마다 하나씩 쓰는 것으로 규칙이 바뀌어서 앞으로는 `n주차 m요일 회고 ` 라는 형식으로 주에 5개씩 포스팅할 예정이다.ㅎㅎ<br/><br/><br/>\r\n\r\n그럼 다시 힘차게 학습 내용을 포스팅해보자...!ㅎㅎ\r\n\r\n## Input Service\r\n\r\n유저가 특정 입력을 누르면 해당 입력에 대한 피드백을 전달한다. <br/>\r\n\r\n입력같은 이벤트들은 서비스에 직접 접근을 못해서 이벤트를 받아 처리한다.<br/>\r\n\r\n> **예시**\r\n>\r\n> 유저가 키보드 `I`를 누르면 인벤토리창을 보여준다<br/>\r\n>\r\n> 키보드 `A`를 누르면 대응하는 스킬을 사용한다<br/>\r\n>\r\n> 마우스로 특정 아이템을 클릭하면 해당 아이템을 습득한다<br/>\r\n\r\n## 키 입력 이벤트란?\r\n\r\n> 유저가 특정 키를 입력하면 그에 대한 피드백을 보내줄 수 있다!\r\n\r\n유저가 `R` 키를 누르면 로그를 찍게 만들어보자!\r\n\r\n- 이벤트를 등록할 Component를 생성하고, `KeyDownEvent`를 등록한다.\r\n\r\n![](add-event.png)\r\n\r\n<br/>\r\n\r\n- 컴포넌트에 코드를 작성한다.\r\n\r\n```lua\r\nlocal key = event.key\r\nif key == KeyboardKey.R then\r\n    -- 누른 키가 R이라면 아래 로그를 출력한다.\r\n\tlog(\"RRRRRRRRRR\")\r\nend\r\n```\r\n\r\n<br/>\r\n\r\n- 생성한 컴포넌트를 `DefaultPlayer`에 적용하고 실행하면, R키를 누를 때 마다 로그가 잘 찍히는 것을 볼 수 있다.\r\n\r\n![](r-log.png)\r\n\r\n### 키 입력 예시 - R키를 누르면 스킬 이펙트\r\n\r\n- 컴포넌트를 생성하고 아래와 같이 코드를 작성합니다.\r\n\r\n```lua\r\nlocal key = event.key\r\nif key == KeyboardKey.R then\r\n\t--_EffectService:PlayEffect(\"00613b24f0c045deab14ba24cdb90187\", self.Entity, self.Entity.TransformComponent.Position,0, Vector3(1,1,1))\r\n\t_EffectService:PlayEffectAttached(\"00613b24f0c045deab14ba24cdb90187\", self.Entity, Vector3(0,0,0), 0, Vector3(1,1,1))\r\nen\r\n```\r\n\r\n> `PlayEffect`는 월드의 position을 기반으로 이펙트를 띄워준다. <br/>\r\n>\r\n> 예시 스킬의 경우 플레이어에 계속 붙어있는 스킬이 적합하므로 `PlayEffectAttached`를 사용한다.\r\n>\r\n> `PlayEffect`의 인자는 차례대로\r\n>\r\n> (Effect RUID, Entity, 이펙트를 띄울 위치, 회전도, 이펙트의 크기)이다.\r\n\r\n<br/>\r\n\r\n- 컴포넌트를 플레이어에 적용하고 실행하면 R키를 누를때마다 스킬이펙트가 잘 실행되는 것을 볼 수 있습니다.\r\n\r\n![](skill.png)\r\n\r\n<br/>\r\n\r\n캐릭터가 보는 방향 앞에 스킬 이펙트를 띄워주려면 다음과 같이 하면 된다.\r\n\r\n```lua\r\nlocal direction = self.Entity.PlayerControllerComponent.LookDirectionX\r\nlocal displayPosition = self.Entity.TransformComponent.Position:Clone()\r\ndisplayPosition = displayPosition + Vector3(3*direction, 0,0)\r\n\r\nif key == KeyboardKey.E then\r\n\t_EffectService:PlayEffect(\"00e23d2d229b49d6895288ab7cf5b8ab\", self.Entity, displayPosition,0,Vector3(1,1,1))\r\nend\r\n```\r\n\r\n![](skill3.png)\r\n\r\n<br/>\r\n\r\n이처럼 여러 스킬들의 RUID를 적용해 다양한 스킬 이펙트를 띄워줄 수 있다!\r\n\r\n![](skill2.png)\r\n"},{"excerpt":"짜잔! 멋사에서 Django로만 백엔드 개발을 해봤는데 방학동안 스프링도 배워보려고 한다... (취업하고 싶어요...) 의 스프링러너의 스프링 아카데미 강의를 듣고 배운 것을  시리즈로 정리해보려고한다. 본격적으로 스프링 개발을 해보기 전, 스프링을 왜 써야하는지에 대해 알아보자! 스프링을 왜 써야하죠? 스프링은 자바 엔터프라이즈 환경에 필요한 모든 것을…","fields":{"slug":"/1-ot/"},"frontmatter":{"date":"July 11, 2022","title":"Spring 오리엔테이션","tags":["spring"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n짜잔! 멋사에서 Django로만 백엔드 개발을 해봤는데 방학동안 스프링도 배워보려고 한다...<br/>\r\n\r\n(취업하고 싶어요...)<br/>\r\n\r\n`fastcampus.app`의 스프링러너의 스프링 아카데미 강의를 듣고 배운 것을 `spring` 시리즈로 정리해보려고한다.\r\n\r\n본격적으로 스프링 개발을 해보기 전, 스프링을 왜 써야하는지에 대해 알아보자!\r\n\r\n\r\n\r\n## 스프링을 왜 써야하죠?\r\n\r\n> 스프링은 자바 엔터프라이즈 환경에 필요한 모든 것을 제공하고, 자바 엔터프라이즈 애플리케이션을 손쉽게 만들 수 있다.\r\n\r\n* 엔터프라이즈 애플리케이션의 핵심적인 기능, 비즈니스 로직을 빠르고 효과적으로 구현할 수 있게 돕는다.\r\n* 엔터프라이즈 애플리케이션을 구현하면서 실수하기 쉬운 저수준의 기술에 많은 신경을 쓰지않아도 된다.\r\n\r\n\r\n\r\n\r\n\r\n### 엔터프라이즈 애플리케이션이란?\r\n\r\n> 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다.\r\n\r\n* 많은 사용자의 요청을 동시에 처리해야하므로 서버의 자원을 효율적으로 분배해서 사용해야한다. \r\n* 대규모의 복잡한 데이터를 관리하고, 이러한 데이터를 이용해 비즈니스 프로세스 지원 및 자동화한다.\r\n* 기업의 핵심 정보를 관리하기에 보안과 안정성, 확장성 면에서도 뛰어나야한다. \r\n* 다수의 사용자가 접근하며, 기업내 분산된 다른 엔터프라이즈 애플리케이션과 통합된다.\r\n* 데이터 입/출력을 위한 다양한 사용자 인터페이스가 제공된다.\r\n\r\n\r\n\r\n### 엔터프라이즈 자바\r\n\r\n> 자바는 엔터프라이즈 환경이 필요로 하는 보안성, 안정성, 확장성등을 고려해 자바 플랫폼이자 프레임워크인 자바 엔터프라이즈 에디션, 자바 EE를 제공하고 있다.\r\n\r\n* 대규모, 네트워크, 다계층 애플리케이션을 더 쉽고 안전하게 구축할 수 있다.\r\n\r\n\r\n\r\n### 자바 EE 서버\r\n\r\n> 서블릿이나 EJB등의 자바 EE 명세를 구현한 서버를 의미... (그게 뭐죠?)\r\n\r\n* 엔터프라이즈 자바로 만든 애플리케이션을 배포하려면 자바 EE 서버가 필요하다.\r\n* 두 가지 종류가 존재\r\n  * 자바 EE의 모든 표준 기술을 지원하고 다양한 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버 (WAS)\r\n  * 웹 모듈만 배포 가능한 경량급 웹 애플리케이션 서버 (서블릭 컨테이너) - 톰캣이나 언더토우, 제티같은 오픈 소스 구현체가 널리 사용됨\r\n\r\n\r\n\r\n## 스프링 프레임워크\r\n\r\n> 위에서 설명한 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 ^^\r\n\r\n<br/>\r\n\r\n* 자바 플랫폼으로 엔터프라이즈 애플리케이션을 개발하는데 필요한 하부 구조를 포괄적으로 제공한다.\r\n* 스프링이 하부 구조를 처리하므로 개발자는 애플리케이션 개발에 집중할 수 있다.\r\n* 핵심은 엔터프라이즈 서비스 기능을 POJO에 제공하는 것이다.\r\n\r\n> 엔터프라이즈 서비스 : 트랜잭션, 보안, 메일, 메시징, 캐시와 같은 엔터프라이즈 애플리케이션에서 요구되는 기술을 의미\r\n\r\n\r\n\r\n### 자바 엔터프라이즈 개발이 어려운 이유?\r\n\r\n폭발적으로 늘어나는 비즈니스와 기술 복잡성 때문!\r\n\r\n* 스프링은 이를 해결하기위해 `POJO`를 중심으로 **제어의 역전과 의존 관계 주입, 관점 지향 프로그래밍, 이식 가능한 서비스 추상화**와 같은 핵심 기술을 프레임워크와 컨테이너를 통해 제공한다!\r\n\r\n\r\n\r\n### 스프링 프레임워크의 전략\r\n\r\n**비즈니스 로직을 담은 애플리케이션 핵심 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키자!**\r\n\r\n> 복잡함을 분리해서 각각의 문제를 효과적으로 해결\r\n\r\n<br/>\r\n\r\n* `POJO`와 함께 스프링 3대 핵심 기술을 사용한다...\r\n* 이를 위해선 좋은 객체 지향 설계가 바탕이 되어야 함!\r\n\r\n<br/><br/>\r\n\r\n근데 포조가 뭔데요...?\r\n\r\n## POJO (Plain Old Java Object)\r\n\r\n> **객체 지향적 원리에 충실**하고, 특정 규약과 환경에 종속되지않게 **재활용될 수 있는 방식으로 설계**된 객체를 의미한다. (네...?)\r\n\r\n* 객체에 애플리케이션 핵심 로직과 기능을 담아 설계, 개발하는 방법을 POJO 프로그래밍이라 부른다.\r\n\r\n[POJO에 대해 더 자세한 설명을 듣고싶다면 여기로!](https://www.youtube.com/watch?v=5NcqgXgmmjg)\r\n"},{"excerpt":"스프링 실습전에 알고가자! 그레이들 빌드툴의 일종이다. Maven의 표준 디렉터리 구조를 따르고 있다. 📌 그레이들의 의존성 관리와 전이 의존성 그레이들은 의존 라이브러리를 관리할 수 있는 기능을 제공한다. 유저가 의존성을 직접 관리하는 것은 복잡하다. 그레이들을 사용하면 주요 의존성만으로 관련성 있는 스프링 모듈과 서드파티 라이브러리가 모두 자동으로 사…","fields":{"slug":"/2-practice/"},"frontmatter":{"date":"July 11, 2022","title":"Spring 간단 실습","tags":["spring"]},"rawMarkdownBody":"\r\n## 스프링 실습전에 알고가자!\r\n\r\n### 그레이들\r\n\r\n빌드툴의 일종이다.\r\n\r\n* Maven의 표준 디렉터리 구조를 따르고 있다.\r\n\r\n<br/>\r\n\r\n#### 📌 그레이들의 의존성 관리와 전이 의존성\r\n\r\n> 그레이들은 의존 라이브러리를 관리할 수 있는 기능을 제공한다.\r\n\r\n유저가 의존성을 직접 관리하는 것은 복잡하다.<br/>\r\n\r\n그레이들을 사용하면 주요 의존성만으로 관련성 있는 스프링 모듈과 서드파티 라이브러리가 모두 자동으로 사용된다.<br/>\r\n\r\n* 전이 의존성 : 의존성 그래프를 따라 자동으로 하위 의존성을 사용하는 것\r\n\r\n> 하단의`Gradle Tasks` -> `help` -> `dependencies` 를 더블클릭하면 콘솔창에서 의존성 그래프를 볼 수 있다.\r\n\r\n<br/><br/>\r\n\r\n#### 📌 직접 그레이들의 의존성 관리를 이용해보자!\r\n\r\n* 그레이들 프로젝트인 `moviebuddy` 프로젝트를 생성한다.\r\n\r\n* `moviebuddy` 프로젝트에 `spring-context`모듈을 추가해보자!\r\n\r\n  * `spring-context` 모듈은 내부적으로 `spring-core`, `beans`, `aop`, `expression`, `jcl`모듈을 사용하고 있다.\r\n\r\n  ![](./spring-context.png)\r\n\r\n  > build.gradle파일에 `spring-context`모듈을 추가하면, 내부 모듈들도 같이 추가되는 것을 볼 수 있다.\r\n\r\n\r\n\r\n## 프로젝트 실행\r\n\r\n### 그레이들로 프로젝트 실행\r\n\r\n그레이들 프로젝트를 깃허브에서 클론해온뒤 <br/>\r\n\r\n* cmd 를 켜고 해당 프로젝트 파일이 있는 곳으로 이동\r\n* cmd에 `gradle build`를 입력\r\n  * windows에서는 ./gradle.bat build를 해야한다고 하는데 어째선지 나는 전자는 되지않고 gradle build라고 해야 됐다...\r\n* ls를 하면 build라는 폴더가 생긴걸 볼 수 있다. `unzip build/distributions/moviebuddy.zip -d build/`를 입력해서 해당 폴더를 압축해제한다.\r\n* `build/moviebuddy/bin/moviebuddy`를 입력하면 프로젝트가 실행된다.\r\n\r\n\r\n\r\n### STS에서 프로젝트 실행\r\n\r\n* MovieBuddyApplication.java에 들어가서\r\n* 우클릭 -> `Run As` -> `2 Java Application`을 누르면 실행된다.\r\n\r\n\r\n\r\n## MovieBuddy 프로젝트 구조\r\n\r\n`src/main/java` -> `moviebuddy`안을 보면\r\n\r\n* ApplicationException.java\r\n* Movie.java\r\n* MovieBuddyApplication.java\r\n\r\n총 세가지의 클래스가 있다.<br/>\r\n\r\n\r\n\r\n### ApplicationException.java\r\n\r\n`moviebuddy` 애플리케이션이 동작하는 과정에서 오류가 있을 때, 그 오류를 예외 객체로 잡아서 외부에 전파하기 위해서 사용이 된다.\r\n\r\n\r\n\r\n### Movie.java\r\n\r\n영화의 정보를 담기 위한 속성들로 구성된 모델 클래스.<br/>\r\n\r\n영화의 제목, 장르, 언어, 국가 등의 정보들로 구성됨. 영화를 시청한 날짜도 기록 가능.\r\n\r\n\r\n\r\n### MovieBuddyApplication.java\r\n\r\n애플리케이션의 주요 로직이 담겨있음.<br/>\r\n\r\n* entry point인 main 메소드를 가지고 있다.\r\n* main 메소드가 호출되면, MovieBuddyApplication 클래스를 생성하고 run 메소드를 호출하도록 구성되어있다.\r\n* run 메소드에는 애플리케이션의 핵심 로직들이 담겨있다.\r\n\r\n\r\n\r\n#### run method\r\n\r\n* running : 애플리케이션 동작을 제어하는 플래그\r\n* input : 유저 입력\r\n* output : 수행 결과 \r\n* commandAction : 명령어별로 실행할 로직을 정의하고 있는 곳 (key가 명령어이고, value가 명령이 실행될 로직)\r\n"},{"excerpt":"문제 그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.\n 풀이 dfs - 재귀함수로 구현\nbfs - queue를 가지고 구현","fields":{"slug":"/1260/"},"frontmatter":{"date":"July 10, 2022","title":"백준 1260 DFS와 BFS","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.\r\n<br/>\r\n\r\n## 풀이\r\n\r\ndfs - 재귀함수로 구현\r\nbfs - queue를 가지고 구현\r\n\r\n```c++\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n#include<string>\r\n#include<queue>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\nint n, m, v;\r\nvector<int> graph[1001];\r\nbool visited[1001];\r\nqueue<int> q;\r\nvoid dfs(int node) {\r\n\tfor (int i = 0; i < graph[node].size(); i++) {\r\n\t\tif (visited[graph[node][i]] == 0) {\r\n\t\t\tcout << graph[node][i] << \" \";\r\n\t\t\tvisited[graph[node][i]] = 1;\r\n\t\t\tdfs(graph[node][i]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid bfs(int node) {\r\n\tq.push(v);\r\n\tvisited[v] = 1;\r\n\twhile (!q.empty()) {\r\n\t\tint first = q.front();\r\n\t\tcout << first << \" \";\r\n\t\tq.pop();\r\n\t\tfor (int i = 0; i < graph[first].size(); i++) {\r\n\t\t\tif (visited[graph[first][i]] == 0) {\r\n\t\t\t\tvisited[graph[first][i]] = 1;\r\n\t\t\t\tq.push(graph[first][i]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n >> m >> v;\r\n\tint a, b;\r\n\t//간선 입력\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tcin >> a >> b;\r\n\t\tgraph[a].push_back(b);\r\n\t\tgraph[b].push_back(a);\r\n\t}\r\n\t// vector sort\r\n\tfor (int i = 1; i < n + 1; i++) {\r\n\t\tsort(graph[i].begin(), graph[i].end());\r\n\t}\r\n\tcout << v << \" \";\r\n\tvisited[v] = 1;\r\n\tdfs(v);\r\n\t// visited init\r\n\tcout << \"\\n\";\r\n\tmemset(visited,0,sizeof(visited));\r\n\tbfs(v);\r\n}\r\n```\r\n"},{"excerpt":"문제 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n\n명령은 총 다섯 가지이다.\n\npush X: 정수 X를 스택에 넣는 연산이다.\npop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\nsize: 스택에 들어있는 정수의 개수를 출력한다…","fields":{"slug":"/10828/"},"frontmatter":{"date":"July 09, 2022","title":"백준 10828 스택","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\r\n<br/>\r\n명령은 총 다섯 가지이다.\r\n<br/>\r\npush X: 정수 X를 스택에 넣는 연산이다.\r\npop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\nsize: 스택에 들어있는 정수의 개수를 출력한다.\r\nempty: 스택이 비어있으면 1, 아니면 0을 출력한다.\r\ntop: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nc++의 stack라이브러리를 사용해 쉽게 구현할 수 있다.<br/>\r\n\r\n```c++\r\nint n, a;\r\nstring cmd;\r\nint main() {\r\n\t//push pop size empty top\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tstack<int> s;\r\n\twhile (n--) {\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == \"push\") {\r\n\t\t\tcin >> a;\r\n\t\t\ts.push(a);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (cmd == \"pop\") {\r\n\t\t\t\tif (s.empty()) {\r\n\t\t\t\t\tcout << -1 << \"\\n\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tint top = s.top();\r\n\t\t\t\t\tcout << top << \"\\n\";\r\n\t\t\t\t\ts.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (cmd == \"size\") {\r\n\t\t\t\tcout << s.size() << \"\\n\";\r\n\t\t\t}\r\n\t\t\telse if (cmd == \"empty\") {\r\n\t\t\t\tcout << s.empty() << \"\\n\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (s.empty()) cout << -1 << \"\\n\";\r\n\t\t\t\telse cout << s.top() << \"\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n\n명령은 총 여섯 가지이다.\n\npush X: 정수 X를 큐에 넣는 연산이다.\npop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\nsize: 큐에 들어있는 정수의 개수를 출력한다.\nemp…","fields":{"slug":"/10845/"},"frontmatter":{"date":"July 09, 2022","title":"백준 10845 큐","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\r\n<br/>\r\n명령은 총 여섯 가지이다.\r\n<br/>\r\npush X: 정수 X를 큐에 넣는 연산이다.\r\npop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\nsize: 큐에 들어있는 정수의 개수를 출력한다.\r\nempty: 큐가 비어있으면 1, 아니면 0을 출력한다.\r\nfront: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\nback: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nc++의 queue 라이브러리를 사용해 쉽게 구현할 수 있다.<br/>\r\n\r\n```c++\r\nint n, a;\r\nstring cmd;\r\nint main() {\r\n\t//push pop size empty front back\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tqueue<int> q;\r\n\twhile (n--) {\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == \"push\") {\r\n\t\t\tcin >> a;\r\n\t\t\tq.push(a);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (cmd == \"pop\") {\r\n\t\t\t\tif (q.empty()) {\r\n\t\t\t\t\tcout << -1 << \"\\n\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tint top = q.front();\r\n\t\t\t\t\tcout << top << \"\\n\";\r\n\t\t\t\t\tq.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (cmd == \"size\") {\r\n\t\t\t\tcout << q.size() << \"\\n\";\r\n\t\t\t}\r\n\t\t\telse if (cmd == \"empty\") {\r\n\t\t\t\tcout << q.empty() << \"\\n\";\r\n\t\t\t}\r\n\t\t\telse if (cmd == \"front\"){\r\n\t\t\t\tif (q.empty()) cout << -1 << \"\\n\";\r\n\t\t\t\telse cout << q.front() << \"\\n\";\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif (q.empty()) cout << -1 << \"\\n\";\r\n\t\t\t\telse cout << q.back() << \"\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\n\n명령은 총 여덟 가지이다.\n\npushfront X: 정수 X를 덱의 앞에 넣는다.\npushback X: 정수 X를 덱의 뒤에 넣는다.\npopfront: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우…","fields":{"slug":"/10866/"},"frontmatter":{"date":"July 09, 2022","title":"백준 10866 덱","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.\r\n<br/>\r\n명령은 총 여덟 가지이다.\r\n<br/>\r\npush_front X: 정수 X를 덱의 앞에 넣는다.\r\npush_back X: 정수 X를 덱의 뒤에 넣는다.\r\npop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\npop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\nsize: 덱에 들어있는 정수의 개수를 출력한다.\r\nempty: 덱이 비어있으면 1을, 아니면 0을 출력한다.\r\nfront: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\nback: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nc++의 deque 라이브러리를 사용해 쉽게 구현할 수 있다.<br/>\r\n\r\n```c++\r\nint n, a;\r\nstring cmd;\r\ndeque<int> d;\r\nint empty() {\r\n\treturn d.empty();\r\n}\r\nint size() {\r\n\treturn d.size();\r\n}\r\nint front() {\r\n\tif (d.empty()) return -1;\r\n\telse return d.front();\r\n}\r\nint back() {\r\n\tif (d.empty()) return -1;\r\n\telse return d.back();\r\n}\r\nvoid push_front() {\r\n\tcin >> a;\r\n\td.push_front(a);\r\n}\r\nvoid push_back() {\r\n\tcin >> a;\r\n\td.push_back(a);\r\n}\r\nint pop_back() {\r\n\tint top = back();\r\n\tif (top != -1) d.pop_back();\r\n\treturn top;\r\n}\r\nint pop_front() {\r\n\tint top = front();\r\n\tif (top != -1) d.pop_front();\r\n\treturn top;\r\n}\r\nint main() {\r\n\t//push_front push_back pop_front pop_back size empty front back\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\twhile (n--) {\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == \"push_front\") push_front();\r\n\t\telse if (cmd == \"push_back\") push_back();\r\n\t\telse if (cmd == \"pop_front\") cout << pop_front() << \"\\n\";\r\n\t\telse if (cmd == \"pop_back\") cout << pop_back() << \"\\n\";\r\n\t\telse if (cmd == \"size\") cout << size() << \"\\n\";\r\n\t\telse if (cmd == \"empty\") cout << empty() << \"\\n\";\r\n\t\telse if (cmd == \"front\") cout << front() << \"\\n\";\r\n\t\telse if (cmd == \"back\") cout << back() << \"\\n\";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.\n\n갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10…","fields":{"slug":"/1940/"},"frontmatter":{"date":"July 08, 2022","title":"백준 1940 주몽","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.\r\n<br/>\r\n갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. 야철대장은 자신이 만들고 있는 재료를 가지고 갑옷을 몇 개나 만들 수 있는지 궁금해졌다. 이러한 궁금증을 풀어 주기 위하여 N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\n무기 재료의 번호를 wn에 담는다.<br/>\r\nwn으로 m을 만들기 위해 필요한 수인 (m - wn)을 idx로 배열 weapon에 체크한다.\r\n\r\n> wn이 들어오면 wn과 더불어 필요한 m-wn을 weapon[m-wn] = 1 로 체크하고, 이후 또 다른 wn2를 입력받고 weapon[wn2]가 1이라면 wn2과 짝인 wn이 존재한다는 의미이므로 카운트를 늘린다.\r\n> wn + wn 으로 나올 수 있는 경우는 2 ~ 200000이므로 200001의 크기를 가지는 배열 weapon을 만든다.<br/>\r\n\r\n```c++\r\nint n, m, wn, idx;\r\nint weapon[200001];\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tint cnt = 0;\r\n\tcin >> n >> m;\r\n\r\n\twhile (n--) {\r\n\t\tcin >> wn;\r\n\t\tif (weapon[wn] == 1) cnt++;\r\n\t\telse {\r\n\t\t\tidx = m - wn;\r\n\t\t\tif (idx <= 200000 and idx >=0) {\r\n\t\t\t\tweapon[idx] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout << cnt;\r\n}\r\n```\r\n"},{"excerpt":"문제 임한수와 임문빈은 서로 사랑하는 사이이다.\n\n임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.\n\n임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.\n\n임문빈을 도와 임한수의 영어 이름을 팰린드롬…","fields":{"slug":"/1213/"},"frontmatter":{"date":"July 06, 2022","title":"백준 1213 팰린드롬 만들기","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n임한수와 임문빈은 서로 사랑하는 사이이다.\r\n<br/>\r\n임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.\r\n<br/>\r\n임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.\r\n<br/>\r\n임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.\r\n\r\n<br/>\r\n> 팰린드롬 : 앞으로 읽어도, 뒤로 읽어도 같은 문장\r\n\r\n## 풀이\r\n\r\n문장안에서 홀수개인 수가 두 개 이상이라면 팰린드롬을 만들 수 없다.<br/>\r\n\r\n- 홀수개인 수가 0개일경우, 모든 수를 가장자리부터 하나씩 채운다.\r\n- 홀수개인 수가 1개일 경우, 모든 수를 가장자리부터 하나씩 채우고 홀수개인 수를 문장의 가운데에 넣는다.\r\n\r\n### 첫 번재 도전\r\n\r\n```c++\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n#include<string>\r\n#include<queue>\r\n#include <cstring>\r\n#include <algorithm>\r\n#include <map>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nmap<char, int> m;\r\nint fail = 0;\r\nstring name;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> name;\r\n\r\n\tfor (auto n : name) {\r\n\t\tm[n] += 1;\r\n\t}\r\n\tint len = name.size();\r\n\tvector<char> v;\r\n\tstack<char> s;\r\n\tvector<char> odd;\r\n\tfor (auto n : m) {\r\n\t\tif (n.second % 2 == 0) {\r\n\t\t\tfor (int i = 0; i < n.second / 2; i++) {\r\n\t\t\t\tv.push_back(n.first);\r\n\t\t\t\ts.push(n.first);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\twhile (n.second--) {\r\n\t\t\t\todd.push_back(n.first);\r\n\t\t\t}\r\n\t\t\t//fail 은 0또는 1\r\n\t\t\tfail += 1;\r\n\t\t}\r\n\t\tif (fail > 1) {\r\n\t\t\tcout << \"I'm Sorry Hansoo\" << \"\\n\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (fail <2) {\r\n\t\tif (fail == 1) {\r\n\t\t\tfor (int i = 0; i < odd.size(); i++) {\r\n\t\t\t\tv.push_back(odd[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\twhile (s.empty() != 1) {\r\n\t\t\tchar a = s.top();\r\n\t\t\ts.pop();\r\n\t\t\tv.push_back(a);\r\n\t\t}\r\n\t\tfor (int i = 0; i < v.size(); i++) {\r\n\t\t\tcout << v[i];\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n처음에 이렇게 풀었지만 정답이 여러 개일 경우, 사전순으로 앞서는 것을 출력한다는 것을 간과했다... 문제를 제대로 읽자\r\n<br/>\r\n\r\n### 두 번째 도전\r\n\r\n```c++\r\nint fail = 0;\r\nstring name;\r\nstring ans;\r\nint alpha[26];\r\nchar mid;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> name;\r\n\tfor (auto n : name) {\r\n\t\talpha[n - 'A'] += 1;\r\n\t}\r\n\tfor (int i = 25; i >= 0; i--) {\r\n\t\tif (alpha[i] % 2 == 0) {\r\n\t\t\tfor (int j = 0; j < alpha[i] / 2; j++) {\r\n\t\t\t\tans = (char)(i + 'A') + ans;\r\n\t\t\t}\r\n\t\t\tfor (int j = 0; j < alpha[i] / 2; j++) {\r\n\t\t\t\tans += (char)(i + 'A');\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmid = (char)(i + 'A');\r\n\t\t\tfail += 1;\r\n\t\t\talpha[i] -= 1;\r\n\t\t\tfor (int j = 0; j < alpha[i] / 2; j++) {\r\n\t\t\t\tans = (char)(i + 'A') + ans;\r\n\t\t\t}\r\n\t\t\tfor (int j = 0; j < alpha[i] / 2; j++) {\r\n\t\t\t\tans += (char)(i + 'A');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (fail > 1) {\r\n\t\tcout << \"I'm Sorry Hansoo\\n\";\r\n\t}\r\n\telse {\r\n\t\tif (fail == 0) {\r\n\t\t\tcout << ans;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint mididx = ans.size()/2;\r\n\t\t\tstring prev = ans.substr(0, mididx);\r\n\t\t\tstring next = ans.substr(mididx);\r\n\t\t\tans = prev + mid + next;\r\n\t\t\tcout << ans;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n```\r\n\r\n팰린드롬이 여러 개일 경우, 사전순으로 앞서는 것을 먼저 출력해야한다. <br/>\r\n\r\n- 그러므로, 각각의 알파벳에 배열 `alpha`의 인덱스 번호를 할당하고 수를 카운트한다.(A = 0 ~ Z = 25)<br/>\r\n\r\n- 이후, 맨 뒤의 원소부터(Z to A) 차례대로 string `ans`의 가장자리에 채워넣는다. (`ans`는 출력할 팰린드롬을 의미한다.)\r\n\r\n  > 첫 번째 풀이에서는 stack과 vector를 써서 풀었는데 ... 왜그랬을까?<br/>\r\n  >\r\n  > 바로 string에 추가해서 넣으면 된다... ㅎㅎ;\r\n\r\n<br/>\r\n\r\n- 만약 수의 카운트가 홀수라면, 팰린드롬의 가운데에 한 글자를 채워넣어야하므로 string `mid`에 저장해둔다.\r\n\r\n  > 홀수개인 수들이 존재하는 만큼 fail을 증가시킨다. (변수명이 적절하지않은 것 같아서 찔린다)\r\n\r\n<br/>\r\n\r\n- 마지막으로 위에서 카운트한 fail이 2이상이면, 홀수개인 수가 2개 이상인 것이므로 팰린드롬 생성에 실패한다.\r\n\r\n- fail이 0이면 가운데에 추가할 글자가 없으므로 바로 `ans`를 출력한다.\r\n\r\n- fail이 1이면 `ans`를 반으로 나누고 가운데에 `mid`를 추가해서 출력한다.\r\n\r\n  > 근데 저렇게 나눌 필요 없이<br/>\r\n  >\r\n  > `ans.insert(ans.begin(), ans.size()/2, mid);` 하면 한 줄로 되더라... ㅎㅎ!\r\n"},{"excerpt":"문제 해빈이는 패션에 매우 민감해서 한번 입었던 옷들의 조합을 절대 다시 입지 않는다. 예를 들어 오늘 해빈이가 안경, 코트, 상의, 신발을 입었다면, 다음날은 바지를 추가로 입거나 안경대신 렌즈를 착용하거나 해야한다. 해빈이가 가진 의상들이 주어졌을때 과연 해빈이는 알몸이 아닌 상태로 며칠동안 밖에 돌아다닐 수 있을까? 풀이 map을 사용해서 의상을 종…","fields":{"slug":"/9375/"},"frontmatter":{"date":"July 02, 2022","title":"백준 9375 패션왕 신해빈","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n해빈이는 패션에 매우 민감해서 한번 입었던 옷들의 조합을 절대 다시 입지 않는다. 예를 들어 오늘 해빈이가 안경, 코트, 상의, 신발을 입었다면, 다음날은 바지를 추가로 입거나 안경대신 렌즈를 착용하거나 해야한다. 해빈이가 가진 의상들이 주어졌을때 과연 해빈이는 알몸이 아닌 상태로 며칠동안 밖에 돌아다닐 수 있을까?\r\n\r\n<br/>\r\n\r\n## 풀이\r\n\r\nmap을 사용해서 의상을 종류별로 몇 벌씩 있는지 카운트를 센다.<br/>\r\n카운트를 토대로 경우의 수를 구한다.\r\n\r\n> 만약 모자가 2개, 상의가 1벌, 하의가 3벌있다면 해빈이가 입을 수 있는 경우의 수는 (2+1) \\* (1+1) \\* (3+1)이다. (각 수에 1을 더하는 이유는 해당 종류의 의상을 아예 입지 않을 수도 있기 때문이다.)\r\n> 구한 경우의 수에서 1을 뺀 값을 출력한다. (어떤 의상도 입지않았을 경우를 제외한다.)\r\n\r\n```c++\r\n\r\nint n, k, cnt;\r\nstring a, b;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\twhile (n--) {\r\n\t\tcin >> k;\r\n\t\tmap<string, int> m;\r\n\t\twhile (k--) {\r\n\t\t\tcin >> a >> b;\r\n\t\t\tm[b] += 1;\r\n\t\t}\r\n\t\tcnt = 1;\r\n\t\tfor (auto c : m) {\r\n\t\t\tcnt *= (c.second + 1);\r\n\t\t}\r\n\t\tcout << --cnt << \"\\n\";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"자주쓰이는 Component MovementComponent 점프력과 이동속도를 결정 RigidbodyComponent 과감속에 따른 움직임을 디테일하게 설정할 수 있다.(중력 등 물리와 관련된) 엔티티의 block 여부도 결정할 수 있음. (block이 활성화되면 해당 Entity를 캐릭터가 통과할 수 없음) 쿼터뷰 설정도 가능 TriggerCompon…","fields":{"slug":"/5-component/"},"frontmatter":{"date":"July 01, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 5주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 자주쓰이는 Component\r\n\r\n* MovementComponent\r\n  * 점프력과 이동속도를 결정\r\n\r\n<br/>\r\n\r\n* RigidbodyComponent\r\n  * 과감속에 따른 움직임을 디테일하게 설정할 수 있다.(중력 등 물리와 관련된)\r\n  * 엔티티의 block 여부도 결정할 수 있음. (block이 활성화되면 해당 Entity를 캐릭터가 통과할 수 없음)\r\n  * 쿼터뷰 설정도 가능\r\n\r\n<br/>\r\n\r\n* TriggerComponent\r\n  * 충돌 트리거 발생\r\n\r\n<br/>\r\n\r\n* WebSpriteComponent\r\n  * 웹 디스플레이 설정\r\n  * 애니메이션도 가능\r\n\r\n<br/>\r\n\r\n* YoutubePlayerComponent\r\n  * 유투브 영상을 디스플레이\r\n\r\n\r\n\r\n\r\n\r\n### Trigger & Movement 예시 - 먹으면 이동속도가 증가하는 아이템\r\n\r\n캐릭터가 먹으면 속도가 증가하고 점프력이 높아지는 아이템을 만들어보자!\r\n\r\n> 해당 기능을 위해선 캐릭터가 아이템을 먹는걸 감지하는 `Trigger Componet`와 트리거가 발생하면 어떻게 처리할 것인지를 결정하는 추가 컴포넌트 `ItemComponent` 가 필요하다.\r\n\r\n<br/>\r\n\r\n* `Workspace`의 `Mydesk`에서 `ItemComponent`를 생성하고 아래와 같이 내용을 작성한다.\r\n\r\n![](./item-component.png)\r\n\r\n> 이벤트 핸들러를 추가하고, <br/>\r\n>\r\n> TriggerBodyEntity의 Movement 정보를 가져와 캐릭터의 속도(InputSpeed)와 점프력(JumpForce)를 상승시킨다.<br/>\r\n>\r\n> * movement가 없는 Entity가 충돌 될 수도 있으므로 예외처리를 해준다.\r\n>\r\n> Enable을 false로 만들어 아이템을 먹으면 아이템이 사라지게 만든다.\r\n\r\n<br/>\r\n\r\n* Item Entity에  `TriggerComponent`와 방금 만든 `ItemComponent`를 추가한다.\r\n\r\n![](./scene.png)\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n여기까지하면 구현이 끝났다! 결과를 확인해보자\r\n\r\n* 아이템 먹기 전 점프력\r\n\r\n![](./before.png)\r\n\r\n<br/>\r\n\r\n* 아이템 먹은 후 점프력\r\n\r\n![](./after.png)\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"문제 안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.\n\n(뚜벅 뚜벅)\n\n얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~\n\n(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ…","fields":{"slug":"/1620/"},"frontmatter":{"date":"June 29, 2022","title":"백준 1620 나는야 포켓몬 마스터 이다솜","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.\r\n<br/>\r\n(뚜벅 뚜벅)\r\n<br/>\r\n얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~\r\n<br/>\r\n(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ\r\n\r\n> 문제 설명이 엄청나게 긴 관계로 생략합니다... 이렇게 정성있는 문제는 처음이야\r\n> <br/> > <br/>\r\n> . . .\r\n> <br/> > <br/>\r\n> 오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.\r\n\r\n## 풀이\r\n\r\nmap을 사용해 string에 해당하는 index를 빠르게 찾을 수 있도록 한다.\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nint n, m;\r\nmap<string, int> strmap;\r\nstring poke[100001];\r\nstring p;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n >> m;\r\n\tfor (int i = 1; i <= n; i++) {\r\n\t\tcin >> p;\r\n\t\tpoke[i] = p;\r\n\t\tstrmap[p] = i;\r\n\t}\r\n\tfor (int i = 0; i < m; i++) {\r\n\t\tcin >> p;\r\n\t\tauto find = strmap.find(p);\r\n\t\tif (find != strmap.end()) {\r\n\t\t\tcout << strmap[p] << \"\\n\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << (poke[stoi(p)]) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.\n\n예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때,\n\n3 -2 -4 -9 0 3 7 13 8 -3\n\n모든 연속적인 이틀간의 온도의 합은 아래와 같다.\n 이때, 온도의 합이 가장 큰 값은 21이다.\n\n또…","fields":{"slug":"/2559/"},"frontmatter":{"date":"June 29, 2022","title":"백준 2559 수열","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n매일 아침 9시에 학교에서 측정한 온도가 어떤 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 알아보고자 한다.\r\n<br/>\r\n예를 들어, 아래와 같이 10일 간의 온도가 주어졌을 때,\r\n<br/>\r\n3 -2 -4 -9 0 3 7 13 8 -3\r\n<br/>\r\n모든 연속적인 이틀간의 온도의 합은 아래와 같다.\r\n<br/>\r\n\r\n이때, 온도의 합이 가장 큰 값은 21이다.\r\n<br/>\r\n또 다른 예로 위와 같은 온도가 주어졌을 때, 모든 연속적인 5일 간의 온도의 합은 아래와 같으며,\r\n\r\n<br/>\r\n\r\n이때, 온도의 합이 가장 큰 값은 31이다.\r\n<br/>\r\n매일 측정한 온도가 정수의 수열로 주어졌을 때, 연속적인 며칠 동안의 온도의 합이 가장 큰 값을 계산하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n예를 들어, \"Baekjoon Online Judge\"를 ROT13으로 암호화하면 \"Onrxwbba Bayvar Whqtr\"가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 \"Onrxwbba Bayvar Whqtr\"에 다시 ROT13을 적용하면 \"Baekjoon Online Judge\"가 된다.\r\n<br/>\r\n\r\nROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다. 예를 들어, \"One is 1\"을 ROT13으로 암호화하면 \"Bar vf 1\"이 된다.\r\n<br/>\r\n\r\n문자열이 주어졌을 때, \"ROT13\"으로 암호화한 다음 출력하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\n부분합을 모두 구하고 배열 psum에 저장한다.\r\n이후 for문을 통해 K길이만큼의 합을 구하고 그 중 최대값을 출력한다.\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nint n, k, temp, psum[100001], ret = -1000000;\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);cout.tie(NULL);\r\n\tcin >> n >> k;\r\n\tfor(int i = 1; i <= n; i++){\r\n\t\tcin >> temp; psum[i] = psum[i - 1] + temp;\r\n\t}\r\n\tfor(int i = k; i <= n; i++){\r\n\t\tret = max(ret, psum[i] - psum[i - k]);\r\n\t}\r\n\tcout << ret << \"\\n\";\r\n    return 0;\r\n}\r\n```\r\n"},{"excerpt":"에러내용 git 명령어를 쳤는데 에러가 나옴 git repository에서 뭔가 손상된 것 같다... 자세한 이유는 모르겠다 왤까? 해결방법 1 문제가 발생한  파일을 지운다. 를 한다 이후 다시 git 명령어를 치면 에러없이 잘 동작한다! 해결방법 2 시도해보진않았지만 로컬 저장소를 정리하면 해결될수도 있다고 한다... 나중에 똑같은 에러가 발생하면 한…","fields":{"slug":"/git2/"},"frontmatter":{"date":"June 28, 2022","title":"git error: cannot lock ref 'refs/remotes/origin/main': unable to resolve reference 'refs/remotes/origin/main': reference broken 문제 해결","tags":["ERROR"]},"rawMarkdownBody":"\r\n### 에러내용\r\n\r\ngit 명령어를 쳤는데 `error: cannot lock ref 'refs/remotes/origin/main': unable to resolve reference 'refs/remotes/origin/main': reference broken `에러가 나옴\r\n\r\n> git repository에서 뭔가 손상된 것 같다...\r\n>\r\n> 자세한 이유는 모르겠다 왤까?\r\n\r\n\r\n\r\n### 해결방법 1\r\n\r\n```\r\n   rm .git/refs/remotes/origin/main\r\n   git fetch\r\n```\r\n\r\n1. 문제가 발생한 `.git/refs/remotes/origin/main` 파일을 지운다.\r\n\r\n2. `git fetch`를 한다\r\n\r\n이후 다시 git 명령어를 치면 에러없이 잘 동작한다!\r\n\r\n\r\n\r\n\r\n\r\n### 해결방법 2\r\n\r\n시도해보진않았지만 로컬 저장소를 정리하면 해결될수도 있다고 한다...<br/>\r\n\r\n나중에 똑같은 에러가 발생하면 한 번 해봐야겠다 ㅎㅎ\r\n\r\n```\r\ngit gc --prune=now\r\ngir remote prune origin\r\n```\r\n\r\n"},{"excerpt":"문제 n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.\n 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로…","fields":{"slug":"/pg-49189/"},"frontmatter":{"date":"June 27, 2022","title":"프로그래머스 49189 가장 먼 노드","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\nn개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.\r\n<br/>\r\n\r\n노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nbfs를 사용해 구현\r\n\r\n```c++\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n#include<string>\r\n#include<queue>\r\n#include <cstring>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nqueue<int> q;\r\nint cur, answer;\r\n\r\nint solution(int n, vector<vector<int>> edge) {\r\n\tanswer = 0;\r\n\tvector <vector<int>> graph(n + 1);\r\n\tfor (int i = 0; i < edge.size(); i++) {\r\n\t\tgraph[edge[i][0]].push_back(edge[i][1]);\r\n\t\tgraph[edge[i][1]].push_back(edge[i][0]);\r\n\t}\r\n\tq.push(1);\r\n\tvector<int> dist(n + 1, 0);\r\n\tdist[1] = 1;\r\n\r\n\twhile (!q.empty()) {\r\n\t\tcur = q.front();\r\n\t\tq.pop();\r\n\t\tfor (int i = 0; i < graph[cur].size(); i++) {\r\n\t\t\tif (dist[graph[cur][i]] == 0){\r\n\t\t\t\tq.push(graph[cur][i]);\r\n\t\t\t\tdist[graph[cur][i]] = dist[cur] + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tint far = *max_element(dist.begin(), dist.end());\r\n\tfor (int i = 0; i < dist.size(); i++) {\r\n\t\tif (dist[i] == far) {\r\n\t\t\tanswer++;\r\n\t\t}\r\n\t}\r\n\treturn answer;\r\n}\r\n```\r\n"},{"excerpt":"문제 선영이는 이번 학기에 오스트레일리아로 교환 학생을 가게 되었다.\n\n호주에 도착하고 처음 며칠은 한국 생각을 잊으면서 즐겁게 지냈다. 몇 주가 지나니 한국이 그리워지기 시작했다.\n\n선영이는 한국에 두고온 서버에 접속해서 디렉토리 안에 들어있는 파일 이름을 보면서 그리움을 잊기로 했다. 매일 밤, 파일 이름을 보면서 파일 하나하나에 얽힌 사연을 기억하면…","fields":{"slug":"/9996/"},"frontmatter":{"date":"June 26, 2022","title":"백준 9996 한국이 그리울 땐 서버에 접속하지","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n선영이는 이번 학기에 오스트레일리아로 교환 학생을 가게 되었다.\r\n<br/>\r\n호주에 도착하고 처음 며칠은 한국 생각을 잊으면서 즐겁게 지냈다. 몇 주가 지나니 한국이 그리워지기 시작했다.\r\n<br/>\r\n선영이는 한국에 두고온 서버에 접속해서 디렉토리 안에 들어있는 파일 이름을 보면서 그리움을 잊기로 했다. 매일 밤, 파일 이름을 보면서 파일 하나하나에 얽힌 사연을 기억하면서 한국을 생각하고 있었다.\r\n<br/>\r\n어느 날이었다. 한국에 있는 서버가 망가졌고, 그 결과 특정 패턴과 일치하는 파일 이름을 적절히 출력하지 못하는 버그가 생겼다.\r\n<br/>\r\n패턴은 알파벳 소문자 여러 개와 별표(*) 하나로 이루어진 문자열이다.\r\n<br/>\r\n파일 이름이 패턴에 일치하려면, 패턴에 있는 별표를 알파벳 소문자로 이루어진 임의의 문자열로 변환해 파일 이름과 같게 만들 수 있어야 한다. 별표는 빈 문자열로 바꿀 수도 있다. 예를 들어, \"abcd\", \"ad\", \"anestonestod\"는 모두 패턴 \"a*d\"와 일치한다. 하지만, \"bcd\"는 일치하지 않는다.\r\n<br/>\r\n패턴과 파일 이름이 모두 주어졌을 때, 각각의 파일 이름이 패턴과 일치하는지 아닌지를 구하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n예를 들어, \"Baekjoon Online Judge\"를 ROT13으로 암호화하면 \"Onrxwbba Bayvar Whqtr\"가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 \"Onrxwbba Bayvar Whqtr\"에 다시 ROT13을 적용하면 \"Baekjoon Online Judge\"가 된다.\r\n<br/>\r\n\r\nROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다. 예를 들어, \"One is 1\"을 ROT13으로 암호화하면 \"Bar vf 1\"이 된다.\r\n<br/>\r\n\r\n문자열이 주어졌을 때, \"ROT13\"으로 암호화한 다음 출력하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nfind함수와 substr함수를 사용하면 쉽게 구현할 수 있다!\r\n\r\n```c++\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\nstring str, input;\r\nstring prefix;\r\nstring suffix;\r\nint cnt,pos;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> cnt >> str;\r\n\tpos = str.find('*');\r\n\tprefix = str.substr(0, pos);\r\n\tsuffix = str.substr(pos + 1);\r\n\tfor (int i = 0; i < cnt; i++) {\r\n\t\tcin >> input;\r\n\t\tif (input.length() < prefix.length() + suffix.length()) { cout << \"NE\" << \"\\n\"; continue; }\r\n\t\tif (input.substr(0, prefix.length()) == prefix && input.substr(input.length() - suffix.length()) == suffix) {\r\n\t\t\tcout << \"DA\" << \"\\n\";\r\n\t\t}\r\n\t\telse cout << \"NE\" << \"\\n\";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 알파벳 소문자로만 이루어진 단어 S가 주어진다. 각 알파벳이 단어에 몇 개가 포함되어 있는지 구하는 프로그램을 작성하시오.\n 풀이 문자를 정수형으로 바꿔서 카운트한다.","fields":{"slug":"/10808/"},"frontmatter":{"date":"June 25, 2022","title":"백준 10808 알파벳 개수","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n알파벳 소문자로만 이루어진 단어 S가 주어진다. 각 알파벳이 단어에 몇 개가 포함되어 있는지 구하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\n문자를 정수형으로 바꿔서 카운트한다.\r\n\r\n```c++\r\n\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\nint arr[26] = {0,};\r\nint main(){\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tstring s;\r\n\tcin >> s;\r\n\tint n;\r\n\tfor (char a:s){\r\n\t\tn = a - 'a';\r\n\t\tarr[n] = arr[n] + 1;\r\n\t}\r\n\r\n\tfor(int i = 0; i<26; i++){\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오. 팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다. level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.\n 풀이 reverse를 사용한다.","fields":{"slug":"/10988/"},"frontmatter":{"date":"June 25, 2022","title":"백준 10988 팰린드롬인지 확인하기","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.\r\n\r\n팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.\r\n\r\nlevel, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.\r\n<br/>\r\n\r\n## 풀이\r\n\r\nreverse를 사용한다.\r\n\r\n```c++\r\n\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tstring s;\r\n\tcin >> s;\r\n\tstring r = s;\r\n\treverse(r.begin(), r.end());\r\n\tif (r == s) cout << 1;\r\n\telse cout << 0;\r\n}\r\n```\r\n"},{"excerpt":"문제 상근이는 농구의 세계에서 점차 영향력을 넓혀가고 있다. 처음에 그는 농구 경기를 좋아하는 사람이었다. 농구에 대한 열정은 그를 막을 수 없었고, 결국 상근이는 농구장을 청소하는 일을 시작했다. 상근이도 농구장을 청소하면서 감독이 되기 위해 가져야할 능력을 공부해나갔다. 서당개 3년이면 풍월을 읊듯이 상근이는 점점 감독으로 한 걸음 다가가고 있었다. …","fields":{"slug":"/1159/"},"frontmatter":{"date":"June 25, 2022","title":"백준 1159 농구경기","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n상근이는 농구의 세계에서 점차 영향력을 넓혀가고 있다. 처음에 그는 농구 경기를 좋아하는 사람이었다. 농구에 대한 열정은 그를 막을 수 없었고, 결국 상근이는 농구장을 청소하는 일을 시작했다. 상근이도 농구장을 청소하면서 감독이 되기 위해 가져야할 능력을 공부해나갔다. 서당개 3년이면 풍월을 읊듯이 상근이는 점점 감독으로 한 걸음 다가가고 있었다. 어느 날 그에게 지방의 한 프로농구팀을 감독할 기회가 생기게 되었다. 그는 엄청난 지도력을 보여주며 프로 리그에서 우승을 했고, 이제 국가대표팀의 감독이 되었다.\r\n<br/>\r\n내일은 일본과 국가대표 친선 경기가 있는 날이다. 상근이는 내일 경기에 나설 선발 명단을 작성해야 한다.<br/>\r\n\r\n국가대표팀의 감독이 된 이후에 상근이는 매우 게을러졌다. 그는 선수의 이름을 기억하지 못하고, 각 선수의 능력도 알지 못한다. 따라서, 누가 선발인지 기억하기 쉽게 하기 위해 성의 첫 글자가 같은 선수 5명을 선발하려고 한다. 만약, 성의 첫 글자가 같은 선수가 5명보다 적다면, 상근이는 내일 있을 친선 경기를 기권하려고 한다.<br/>\r\n\r\n상근이는 내일 경기를 위해 뽑을 수 있는 성의 첫 글자를 모두 구해보려고 한다.\r\n\r\n> 굉장히 게으르네\r\n\r\n## 풀이\r\n\r\nreverse를 사용한다.\r\n\r\n```c++\r\n\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint n;\r\nint arr[26];\r\nstring output;\r\nstring input;\r\nint idx;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tcin >> n;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tcin >> input;\r\n\t\tidx = input[0] - 'a';\r\n\t\tarr[idx]++;\r\n\t}\r\n\tfor (int i = 0; i < 26; i++) {\r\n\t\tif (arr[i] > 4) output += i + 'a';\r\n\t}\r\n\tif (output.empty()) {\r\n\t\tcout << \"PREDAJA\";\r\n\t}\r\n\telse {\r\n\t\tcout << output;\r\n\t}\r\n}\r\n```\r\n"},{"excerpt":"문제 ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\n 예를 들어, \"Baekjoon Online Judge\"를 ROT13으로 암호화하면 \"Onrxwbba Bayvar Whqtr\"가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 \"Onrxwbb…","fields":{"slug":"/11655/"},"frontmatter":{"date":"June 25, 2022","title":"백준 11655 ROT13","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\nROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.\r\n<br/>\r\n\r\n예를 들어, \"Baekjoon Online Judge\"를 ROT13으로 암호화하면 \"Onrxwbba Bayvar Whqtr\"가 된다. ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다. 앞에서 암호화한 문자열 \"Onrxwbba Bayvar Whqtr\"에 다시 ROT13을 적용하면 \"Baekjoon Online Judge\"가 된다.\r\n<br/>\r\n\r\nROT13은 알파벳 대문자와 소문자에만 적용할 수 있다. 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다. 예를 들어, \"One is 1\"을 ROT13으로 암호화하면 \"Bar vf 1\"이 된다.\r\n<br/>\r\n\r\n문자열이 주어졌을 때, \"ROT13\"으로 암호화한 다음 출력하는 프로그램을 작성하시오.\r\n<br/>\r\n\r\n## 풀이\r\n\r\n아스키코드값을 활용한다.\r\n\r\n> A ~ Z 는 65 ~ 90\r\n> a ~ z 는 97 ~ 122\r\n\r\n```c++\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n#include<string>\r\nusing namespace std;\r\n\r\nchar c;\r\nstring str;\r\nint n;\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tgetline(cin,str);\r\n\tfor (int i = 0; i < str.length(); i++) {\r\n\t\tn = (int)str[i];\r\n\t\tif (n >= 97 && n <= 122) {\r\n\t\t\t// a b c d e f g h i j k l m n o p q r s t u v w x y z\r\n\t\t\tn += 13;\r\n\t\t\tn = (n>122)?n%123 + 97:n;\r\n\t\t\tstr[i] = (char)n;\r\n\t\t}\r\n\t\telse if (n >= 65 && n <= 90) {\r\n\t\t\tn += 13;\r\n\t\t\tn = (n > 90) ? n % 91 + 65 : n;\r\n\t\t\tstr[i] = char(n);\r\n\t\t}\r\n\t}\r\n\tcout << str;\r\n}\r\n```\r\n"},{"excerpt":"문제 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.\n\n아홉 명의 난쟁이는 모두 자신이 \"백설 공주와 일곱 난쟁이\"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해…","fields":{"slug":"/2309/"},"frontmatter":{"date":"June 25, 2022","title":"백준 2309 일곱 난쟁이","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.\r\n<br/>\r\n아홉 명의 난쟁이는 모두 자신이 \"백설 공주와 일곱 난쟁이\"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.\r\n<br/>\r\n아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.\r\n\r\n<br/>\r\n\r\n## 풀이\r\n\r\nnext_permutation함수를 이용하면 쉽게 풀 수 있다.\r\n\r\n> next_permutation함수는 주어진 수들로 만들 수 있는 다음 순열을 반환한다.\r\n\r\n```c++\r\n\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\nint arr[9];\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\tfor (int i=0; i<9; i++) cin >> arr[i];\r\n\tint sum = 0;\r\n\tdo{\r\n\t\tsum = 0;\r\n\t\tfor(int i =0; i<7; i++){\r\n\t\t\tsum = arr[i] + sum;\r\n\t\t}\r\n\t\tif (sum == 100) break;\r\n\t}while(next_permutation(arr, arr+9));\r\n\r\n\tsort(arr, arr+7);\r\n\tfor(int i=0; i<7; i++) cout << arr[i]<<\"\\n\";\r\n}\r\n```\r\n"},{"excerpt":"문제 상근이는 트럭을 총 세 대 가지고 있다. 오늘은 트럭을 주차하는데 비용이 얼마나 필요한지 알아보려고 한다.  상근이가 이용하는 주차장은 주차하는 트럭의 수에 따라서 주차 요금을 할인해 준다. 트럭을 한 대 주차할 때는 1분에 한 대당 A원을 내야 한다. 두 대를 주차할 때는 1분에 한 대당 B원, 세 대를 주차할 때는 1분에 한 대당 C원을 내야 한…","fields":{"slug":"/2979/"},"frontmatter":{"date":"June 25, 2022","title":"백준 2979 트럭주차","tags":["cote"]},"rawMarkdownBody":"\r\n## 문제\r\n\r\n상근이는 트럭을 총 세 대 가지고 있다. 오늘은 트럭을 주차하는데 비용이 얼마나 필요한지 알아보려고 한다. <br/>\r\n\r\n상근이가 이용하는 주차장은 주차하는 트럭의 수에 따라서 주차 요금을 할인해 준다.<br/>\r\n\r\n트럭을 한 대 주차할 때는 1분에 한 대당 A원을 내야 한다. 두 대를 주차할 때는 1분에 한 대당 B원, 세 대를 주차할 때는 1분에 한 대당 C원을 내야 한다.<br/>\r\n\r\nA, B, C가 주어지고, 상근이의 트럭이 주차장에 주차된 시간이 주어졌을 때, 주차 요금으로 얼마를 내야 하는지 구하는 프로그램을 작성하시오.\r\n\r\n<br/>\r\n\r\n## 풀이\r\n\r\n세 대의 트럭이 타임테이블별로 주차하는 것을 표현하면 다음과 같다.\r\n\r\n| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |\r\n| --- | --- | --- | --- | --- | --- | --- | --- |\r\n| 1   | 1   | 1   | 1   | 1   |     |     |     |\r\n|     |     | 1   | 1   |     |     |     |     |\r\n|     | 1   | 1   | 1   | 1   | 1   | 1   |     |\r\n\r\nA, B, C가 각각 5, 3, 1이라면 총 주차비용은 <br/>\r\n\r\n5 + 3\\*2 + 1\\*3 + 1\\*3 + 3\\*2 + 5 + 5 = 33이 된다. <br/>\r\n\r\n이를 가지고 코드를 짜면 다음과 같다.\r\n\r\n```c++\r\n\r\n#include<iostream>\r\n#include<tuple>\r\n#include<vector>\r\n\r\nusing namespace std;\r\n\r\nint arr[105] = { 0, };\r\nint main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tint a, b, c;\r\n\tcin >> a >> b >> c;\r\n\tint s, d;\r\n\tfor (int i = 0; i < 3; i++) {\r\n\t\tcin >> s >> d;\r\n\t\tfor (int j = s; j < d; j++) {\r\n\t\t\tarr[j] = arr[j] + 1;\r\n\t\t}\r\n\t}\r\n\tint sum = 0;\r\n\tfor (int i = 0; i < 105; i++) {\r\n\t\tif (arr[i] > 0) {\r\n\t\t\tif (arr[i] == 1) {\r\n\t\t\t\tsum = sum + a;\r\n\t\t\t}\r\n\t\t\telse if (arr[i] == 2) {\r\n\t\t\t\tsum = sum + b*2;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsum = sum + c*3;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n\tcout << sum;\r\n}\r\n```\r\n"},{"excerpt":"배열 초기화 배열 초기화 fill과 memset을 사용해 배열을 초기화해보자! fill (시작주소, 끝주소, 값) fill은 시작주소부터 끝주소까지를 주어진 값으로 초기화한다. 아래처럼 사용할 수 있다. memset(시작주소, 값, 사이즈) memset은 시작주소부터 사이즈까지를 주어진 값으로 초기화한다. 배열의 모든 값을 초기화하려면 시작주소에 배열의 …","fields":{"slug":"/arr-init/"},"frontmatter":{"date":"June 25, 2022","title":"fill과 memset을 이용해 배열 초기화","tags":["C++","cote"]},"rawMarkdownBody":"\r\n## 배열 초기화\r\n\r\n\r\n\r\n\r\n\r\n## 배열 초기화\r\n\r\nfill과 memset을 사용해 배열을 초기화해보자!\r\n\r\n\r\n\r\n### fill (시작주소, 끝주소, 값)\r\n\r\nfill은 시작주소부터 끝주소까지를 주어진 값으로 초기화한다.\r\n\r\n아래처럼 사용할 수 있다.\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n\tint arr[5];\r\n\tfill(arr, arr+5, 1);\r\n\tfor (int a : arr) cout << a << \" \";\r\n\tcout << \"\\n\";\r\n    // output : 1 1 1 1 1\r\n    \r\n    char str[] = \"hello\";\r\n\tfill(str, str + 3, 'c');\r\n\tfor (char c : str) cout << c << \" \";\r\n    // output : c c c l o\r\n}\r\n```\r\n\r\n\r\n\r\n### memset(시작주소, 값, 사이즈)\r\n\r\nmemset은 시작주소부터 사이즈까지를 주어진 값으로 초기화한다.<br/>\r\n\r\n배열의 모든 값을 초기화하려면 시작주소에 배열의 이름을 넣어도 무방하다. (배열의 이름은 배열의 첫 번째 주소를 가리킨다.) <br/>\r\n\r\n사이즈는 바이트 단위로 `sizeof(배열)` 로 선언할 수 있다.\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n\tint arr[5];\r\n    // sizeof(arr)은 int형 5개가 있으므로 4byte * 5 = 20\r\n\tmemset(arr, 0, sizeof(arr)); \r\n\tfor (int a : arr) cout << a << \" \";\r\n    // output : 0 0 0 0 0\r\n    \r\n    char str[] = \"hello\";\r\n    // c++에서 char은 1byte\r\n    memset(str, 'c', 3);\r\n    for (char c : str) cout << c << \" \";\r\n    // output : c c c l o\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n#### 주의 : memset으로 int배열을 0이 아닌 다른 수로 초기화할 수 있을까?\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n\tint arr[5];\r\n    // memset을 사용해 1로 초기화해보자!\r\n\tmemset(arr, 1, sizeof(arr)); \r\n\tfor (int a : arr) cout << a << \" \";\r\n    // output : 16843009 16843009 16843009 16843009 16843009\r\n}\r\n```\r\n\r\n위처럼 `memset` 은  0이 아닌 다른 수로 초기화할 수 없다.<br/>\r\n\r\n`memset`은 1 byte단위로 값을 초기화한다. 때문에 1을 값으로 넣는다면  `memset`은 1byte단위로 1을 만들게된다.  int형은 4byte로 표현되어야 하므로 알 수 없는 값으로 초기화된다.\r\n\r\n> 0은 1byte로 표현되어도 00000000이기 때문에 동일\r\n>\r\n> char도 1byte이므로 가능\r\n\r\n**즉, memset은 0과 char로만 초기화가 가능하다!**\r\n\r\n\r\n\r\n## 2차원배열 초기화\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    int arr[5][5];\r\n    fill(&arr[0][0], &arr[0][0]+25, 1);\r\n    for(int i=0; i<5; i++){\r\n\t\tfor(int j = 0; j<5; j++) cout << arr[i][j]<<\" \";\r\n\t\tcout << \"\\n\";\r\n\t}\r\n    memset(arr, 0, sizeof(arr));\r\n    for(int i=0; i<5; i++){\r\n\t\tfor(int j = 0; j<5; j++) cout << arr[i][j]<<\" \";\r\n\t\tcout << \"\\n\";\r\n\t}\r\n}\r\n```\r\n\r\n"},{"excerpt":"arr과 &arr의 차이 int arr5가 있을 때 arr과 &arr을 출력해보자 둘 다 같은 주소값으로 배열 의 시작 주소를 가리킨다. arr과 &arr에 1을 더해보자 arr + 1은 기존 주소 에서 4만큼 늘어난 값이다. int는 4byte이므로 즉 arr1의 시작주소를 가리킨다. &arr + 1은 기존주소 에서 20만큼 늘어난 값이다. 20은 4b…","fields":{"slug":"/arr-addr/"},"frontmatter":{"date":"June 25, 2022","title":"arr과 &arr의 차이","tags":["C++"]},"rawMarkdownBody":"\r\n## arr과 &arr의 차이\r\n\r\n* int arr[5]가 있을 때 arr과 &arr을 출력해보자\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int arr[5] = {0, };\r\n    cout << arr << \"\\n\";\r\n    // output : 00F9FB30\r\n    \r\n    cout << &arr << \"\\n\";\r\n    //output : 00F9FB30\r\n}\r\n```\r\n\r\n둘 다 같은 주소값으로 배열 `arr`의 시작 주소를 가리킨다.\r\n\r\n\r\n\r\n* arr과 &arr에 1을 더해보자\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n    int arr[5] = {0, };\r\n    cout << arr+1 << \"\\n\";\r\n    // output : 00F9FB34\r\n\r\n    \r\n    cout << &arr+1 << \"\\n\";\r\n    //output : 00F9FB44\r\n}\r\n```\r\n\r\n* arr + 1은 기존 주소 `00F9FB30`에서 4만큼 늘어난 값이다.\r\n  * int는 4byte이므로 즉 arr[1]의 시작주소를 가리킨다.\r\n* &arr + 1은 기존주소 `00F9FB30`에서 20만큼 늘어난 값이다.\r\n  * 20은 4byte \\* 5이므로 arr[5]의 끝 주소를 가리킨다.\r\n\r\n즉 arr + 1은 arr의 1번째 원소의 시작주소를 가리키고 &arr + 1은 배열 arr자체의 끝 주소를 가리킨다.\r\n\r\n<br/>\r\n\r\n![](./addr.png)\r\n\r\n\r\n\r\n<br/> <br/>\r\n\r\n다른 예시\r\n\r\n```c++\r\nint main() {\r\n    char arr[5] = \"hell\";\r\n    cout <<\"(char) arr: \"<< arr << \"\\n\";\r\n    cout << \"(char) &arr: \" << &arr << \"\\n\";\r\n    cout << \"(char) arr+1: \" << arr+1 << \"\\n\";\r\n    cout << \"(char) &arr+1: \" << &arr+1 << \"\\n\";\r\n\r\n    double arr2[5] = { 0, };\r\n    cout << \"(double) arr: \" << arr2 << \"\\n\";\r\n    cout << \"(double) &arr: \" << &arr2 << \"\\n\";\r\n    cout << \"(double) arr+1: \" << arr2 + 1 << \"\\n\";\r\n    cout << \"(double) &arr+1: \" << &arr2 + 1 << \"\\n\";\r\n}\r\n```\r\n\r\n![](./ex-output.png)\r\n\r\n\r\n\r\n\r\n\r\n| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| 1    | 1    | 1    | 1    | 1    |      |      |      |\r\n|      |      | 1    | 1    |      |      |      |      |\r\n|      | 1    | 1    | 1    | 1    | 1    | 1    |      |\r\n\r\n5 3 1 1 3 5 5 \r\n\r\n5 + 3 + 3 + 3 + 3 + 6 + 5 + 5\r\n\r\n15\r\n\r\n21\r\n\r\n"},{"excerpt":"한글을 한 글자씩 출력해보자! 처음 시도한 방법 : str0, str1... strn 이런식으로 출력하면 한 글자씩 나오지않을까? 출력결과  원하는 출력이 아닌 웬 물음표들이 등장함 영어는 아스키코드에 있어 위 방식으로 해도 출력이 잘 되지만 한글은 아스키코드에 없어서 출력이 되지않음 영어는 한 글자당 1byte(char)이지만 한글은 1byte보다 크기…","fields":{"slug":"/kr-str/"},"frontmatter":{"date":"June 24, 2022","title":"[c++] 한글을 한 글자씩 출력하기","tags":["C++"]},"rawMarkdownBody":"\r\n## 한글을 한 글자씩 출력해보자!\r\n\r\n* 처음 시도한 방법 : str[0], str[1]... str[n] 이런식으로 출력하면 한 글자씩 나오지않을까?\r\n\r\n```c++\r\nstring str = \"한글이에요\";\r\n\r\n// 이렇게 하거나\r\nfor (char c : str) {\r\n\tcout << c << \" \";\r\n}\r\ncout << \"\\n\";\r\n\r\n// 저렇게 하면 되겠지?\r\nfor (int i = 0; i < (int)str.size(); i++) {\r\n\tcout << str[i] << \" \";\r\n}\r\n```\r\n\r\n* 출력결과\r\n\r\n![](./output1.png)\r\n\r\n\r\n\r\n원하는 출력이 아닌 웬 물음표들이 등장함<br/>\r\n\r\n영어는 아스키코드에 있어 위 방식으로 해도 출력이 잘 되지만 한글은 아스키코드에 없어서 출력이 되지않음\r\n\r\n> 영어는 한 글자당 1byte(char)이지만 한글은 1byte보다 크기때문에 출력이 제대로 되지않는다.\r\n\r\n\r\n\r\n## 그럼 어떻게 출력해야할까?\r\n\r\n* 한글의 크기를 구해보자!\r\n\r\n```c++\r\ncout << (int)str.size();\r\n```\r\n\r\n위 코드를 통해 str `\"한글이에요\"`의 사이즈를 출력해보면 `10`이 나오는 것을 볼 수 있다.<br/>\r\n\r\n즉, 한글 한 글자의 크기는 2byte이다.\r\n\r\n> CP949와 EUC-KR은 한글 한 글자를 2byte로 저장하고, UTF-8은 한글 한 글자를 3byte로 저장한다.\r\n>\r\n> UTF-8이었다면 위 코드를 돌렸을 때 한 글자당 3byte이므로 15가 나온다.\r\n\r\n\r\n\r\n* 즉, 한글을 한 글자씩 출력하려면 다음과 같이 하면 된다!\r\n\r\n```c++\r\n// 한 글자당 2byte이므로 두 개씩 출력\r\nfor (int i = 0; i < (int)str.size(); i += 2) {\r\n\tcout << str.substr(i, 2)<<\" \";\r\n}\r\n\r\n// 한 글자당 3byte라면 이렇게\r\nfor (int i = 0; i < (int)str.size(); i += 3) {\r\n\tcout << str.substr(i, 3)<<\" \";\r\n}\r\n```\r\n\r\n코드를 실행하면 `\"한 글 이 에 요\"`로 잘 출력되는 것을 볼 수 있다.\r\n\r\n\r\n\r\n* char 배열에 담을 때도 한글의 크기를 고려해서 공간을 할당한다.\r\n\r\n```c++\r\n//출력이 잘 되지않음\r\n//char c[6] = \"안녕하세요\";\r\n\r\n//출력이 잘 됨\r\nchar c[11] = \"안녕하세요\";\r\n\r\n\r\nfor (int i = 0; i < (int)sizeof(c) / 2; i++) {\r\n    cout << i+1 << \"번째 글자입니다.\\n\";\r\n    cout << c[i * 2] << c[i * 2 + 1] << \"\\n\";\r\n}\r\n```\r\n\r\n"},{"excerpt":"tuple? tuple은 두 개 이상의 값을 순서대로 담을 때 사용됩니다. 보통 두 개만 담을 땐 pair를 사용하고 세 개 이상을 담을 땐 tuple을 사용! tuple 선언 위 처럼 꺽쇠안에 원하는 자료형을 선언하면 된다. 차례대로 <int, char, string>이라는 원소를 가진 test라는 tuple이 생성된다. tuple 생성 tuple을 생…","fields":{"slug":"/tuple/"},"frontmatter":{"date":"June 24, 2022","title":"c++로 tuple 만들기","tags":["C++","cote"]},"rawMarkdownBody":"\r\n\r\n\r\n## tuple?\r\n\r\ntuple은 두 개 이상의 값을 순서대로 담을 때 사용됩니다.\r\n\r\n> 보통 두 개만 담을 땐 pair를 사용하고\r\n>\r\n> 세 개 이상을 담을 땐 tuple을 사용!\r\n\r\n\r\n\r\n## tuple 선언\r\n\r\n```c++\r\ntuple<int, char, string> test;\r\n```\r\n\r\n위 처럼 꺽쇠안에 원하는 자료형을 선언하면 된다.<br/>\r\n\r\n차례대로 <int, char, string>이라는 원소를 가진 test라는 tuple이 생성된다.\r\n\r\n\r\n\r\n## tuple 생성\r\n\r\ntuple을 생성했으니 원하는 값을 tuple에 넣어보자!\r\n\r\n```c++\r\ntest = make_tuple(1,'a',\"hi\");\r\n```\r\n\r\ntest는 위 `tuple 선언`에서 선언한 tuple이다.<br/>\r\n\r\n`make_tuple`이라는 함수를 사용해서 tuple에 값을 할당할 수 있다.\r\n\r\n\r\n\r\n## tuple 값 가져오기\r\n\r\n튜플에 할당한 값을 가져와보자\r\n\r\n```c++\r\nget<0>(test); // 1\r\nget<1>(test); // 'a'\r\nget<2>(test); // \"hi\"\r\n```\r\n\r\n`get`을 사용해 튜플의 값을 불러올 수 있다.<br/>\r\n\r\n꺽쇠안에는 불러오고 싶은 값의 `index`를 넣고 괄호안에는 어떤 튜플에서 값을 불러올 것 인지를 명시한다.\r\n\r\n\r\n\r\n## tuple끼리 값을 서로 바꾸기\r\n\r\n```c++\r\n// 형태가 똑같은 두 튜플 tl과 test가 있다고 할 때\r\nswap(tl, test);\r\n```\r\n\r\n`swap`을 사용해 두 튜플의 값을 서로 바꿀 수 있다.\r\n\r\n\r\n\r\n## tuple의 값을 다른 변수에 할당하기\r\n\r\n```c++\r\nint myint;\r\nchar mychar;\r\nstring mystr;\r\n\r\ntie(myint, mychar, mystr) = test;\r\n```\r\n\r\n`tie`를 사용해 변수에 튜플의 값을 할당한다.<br/>\r\n\r\ntest는 <int, char, string> 형태이므로 tie 괄호안의 변수에 차례대로 할당된다.\r\n\r\n\r\n\r\n## tupe 사용 예시\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint main(){\r\n\ttuple<int, int, int> tl;\r\n\tint a, b, c;\r\n\tchar d;\r\n\t\r\n\tpi = {1, 2};\r\n\ttl = make_tuple(1,2,3);\r\n\ttie(a,b) = pi;\r\n\tcout << a <<\", \" <<b<<\"\\n\";\r\n\t\r\n\ttie(a,b,c) = tl;\r\n\tcout << a <<\", \" <<b<< \", \"<< c <<\"\\n\";\r\n\t\r\n    // tuple 선언\r\n\ttuple<int, int, char> tl;\r\n    tuple<int, int, char> tl2;\r\n    \r\n    // tuple 생성 : make_tuple\r\n\ttl = make_tuple(1,2,'a');\r\n    tl2 = make_tuple(3,4,'b');\r\n    \r\n    // tuple 값 가져오기 : get\r\n    cout << get<2>(tl) << \"\\n\";\r\n    cout << get<2>(tl2) << \"\\n\";\r\n    \r\n    // tuple 값 서로 바꾸기\r\n    swap(tl,tl2);\r\n    \r\n    // tuple 값 다른 변수에 저장\r\n\tint a, b;\r\n    char c;\r\n    tie(a,b,c) = tl;\r\n}\r\n```\r\n\r\n"},{"excerpt":"vector? 동적으로 요소를 할당할 수 있다. 동적할당이란? 실행 시간 동안 사용할 메모리 공간을 할당하는 것을 의미한다. 쉽게 말해서 정적 배열인 array의 경우 미리 얼만큼 사용할 것인지 크기를 결정하고 사용한다. 그러나 동적으로 할당한다면 상황에 따라 원하는 크기만큼의 메모리가 할당되고 이미 할당된 메모리라도 언제든지 크기 조정이 가능하다. 즉,…","fields":{"slug":"/vector/"},"frontmatter":{"date":"June 24, 2022","title":"c++로 vector 만들기","tags":["C++","cote"]},"rawMarkdownBody":"\r\n\r\n\r\n## vector?\r\n\r\n동적으로 요소를 할당할 수 있다.\r\n\r\n> 동적할당이란?\r\n>\r\n> 실행 시간 동안 사용할 메모리 공간을 할당하는 것을 의미한다.\r\n>\r\n> 쉽게 말해서 정적 배열인 array의 경우 미리 얼만큼 사용할 것인지 크기를 결정하고 사용한다.\r\n>\r\n> 그러나 동적으로 할당한다면 상황에 따라 원하는 크기만큼의 메모리가 할당되고 이미 할당된 메모리라도 언제든지 크기 조정이 가능하다.\r\n>\r\n> **즉, 어떤 배열이 필요한데 그 배열의 크기를 정확히 알 수 없을 때 사용할 수 있다.**\r\n>\r\n> 그렇다면 동적 할당이 정적 할당보다 더 좋은게 아닌가?\r\n>\r\n> * 꼭 그렇다고 할 수 만은 없다!\r\n> * 동적할당은 메모리 누수가 일어날 수 있기 때문에 사용하지 않을 땐 메모리를 해제해줘야한다.\r\n\r\n\r\n\r\n## vector 인터페이스\r\n\r\n| 기능                       | 형식                      | 예시                                               |\r\n| -------------------------- | ------------------------- | -------------------------------------------------- |\r\n| 생성                       | vector<자료형> name       | vector<int> v                                      |\r\n| n만큼 할당 후 0으로 초기화 | vector<자료형> name(n)    | vector<int> v(5)                                   |\r\n| 값 미리 초기화             | vector<자료형> name = {}  | vector<int> v = {1, 2, 3}                          |\r\n| 벡터 시작점 주소값         | v.begin()                 |                                                    |\r\n| 벡터 끝부분+1 주소값       | v.end()                   |                                                    |\r\n| i번째 요소 접근            | v.at(i)                   | v.at(0)                                            |\r\n| 첫 번째 요소 접근          | v.front()                 |                                                    |\r\n| 마지막 요소 접근           | v.back()                  |                                                    |\r\n| 맨 뒤에 요소 추가          | v.push_back(값)           | v.push_back(2)                                     |\r\n| 맨 뒤에 요소 제거          | v.pop_back()              |                                                    |\r\n| 요소 삽입                  | v.insert(위치, 값)        | v.insert(v.begin()+1, 100)                         |\r\n| 요소 삭제                  | v.erase(시작위치, 끝위치) | v.erase(v.begin), v.erase(v.begin, v.begin+5)      |\r\n| 모든 요소 삭제             | v.clear()                 |                                                    |\r\n| 벡터 사이즈 조정           | v.resize(사이즈)          | v.resize(10) : 사이즈가 커지면 0으로 값이 추가된다 |\r\n| 벡터 swap                  | v.swap(벡터)              | v1.swap(v2)                                        |\r\n| 벡터가 비었는지 확인       | v.empty()                 |                                                    |\r\n| 벡터 사이즈 반환           | v.size()                  |                                                    |\r\n\r\n\r\n\r\n## vector 사용 예시\r\n\r\n```c++\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n// vector선언 : 꺽쇠안에 자료형을 명시\r\nvector<int> v;\r\nint main(){\r\n    // vector 값 할당 - push_back\r\n    // : vector의 맨 뒤에 요소를 추가한다.\r\n    v.push_back(0);\r\n    v.push_back(1);\r\n    for(int i = 1; i <= 10; i++)v.push_back(i);\r\n    \r\n    // vector 값 삭제1 - pop_back\r\n    // : vector의 맨 뒤에 값을 삭제한다.\r\n    v.pop_back();\r\n    \r\n    // vector 값 삭제2 - erase\r\n    v.erase(v.begin(), v.begin()+2);\r\n    \r\n    // vector 값 출력\r\n    for (int a:v) cout << a << \" \";\r\n    cout << \"\\n\";\r\n    \r\n    // vector 값 탐색 - find\r\n    auto a = find(v.begin(), v.end(), 100);\r\n    if (a == v.end()) cout << \"100을 찾을 수 없음.\" << \"\\n\";\r\n    \r\n    // vector 값 채우기 - fill\r\n    fill(v.begin(), v.end(), 10);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"문자를 숫자로 바꾸기 아스키코드를 이용하자! 'A' ~ 'Z' 는 아스키 코드로 65 ~ 90 'a' ~ 'z' 는 아스키 코드로 97 ~ 122 만약 'a' ~ 'z' 사이의 숫자를 입력 받아 숫자 0 ~ 26으로 표현하고 싶다면 사실 이렇게 해도 됨","fields":{"slug":"/char-to-int/"},"frontmatter":{"date":"June 21, 2022","title":"문자형을 숫자로 변환","tags":["C++","cote"]},"rawMarkdownBody":"\r\n\r\n\r\n## 문자를 숫자로 바꾸기\r\n\r\n아스키코드를 이용하자!\r\n\r\n> 'A' ~ 'Z' 는 아스키 코드로 65 ~ 90\r\n>\r\n> 'a' ~ 'z' 는 아스키 코드로 97 ~ 122\r\n\r\n\r\n\r\n* 만약 'a' ~ 'z' 사이의 숫자를 입력 받아 숫자 0 ~ 26으로 표현하고 싶다면\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char c;\r\n    cin >> c;\r\n    cout << (int)c - 97 <<\"\\n\";\r\n    return 0;\r\n}\r\n```\r\n\r\n<br/>\r\n\r\n* 사실 이렇게 해도 됨\r\n\r\n```c++\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main(){\r\n    char c;\r\n    cin >> c;\r\n    cout << (int)c - 'a' <<\"\\n\";\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n"},{"excerpt":"Certivicates 앞의 퍼블릭키 분배 방법은 다 중간에서 누군가 속일 수가 있음 믿을 수 있는 기관을 이용하자! Public key authority E(PRauth, PUb Reauest||T1) PUb가 밥의 퍼블릭키가 맞다는걸 authority가 자신의 프라이빗키로 인증 근데 꼭 authority가 중간에서 매번 전달해줄필요없음. 인증서를 미리…","fields":{"slug":"/2/"},"frontmatter":{"date":"June 15, 2022","title":"14-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Certivicates\r\n\r\n앞의 퍼블릭키 분배 방법은 다 중간에서 누군가 속일 수가 있음\r\n\r\n믿을 수 있는 기관을 이용하자!\r\n\r\nPublic key authority\r\n\r\n* E(PRauth, PUb Reauest||T1)\r\n  * PUb가 밥의 퍼블릭키가 맞다는걸 authority가 자신의 프라이빗키로 인증\r\n\r\n\r\n\r\n근데 꼭 authority가 중간에서 매번 전달해줄필요없음.\r\n\r\n인증서를 미리미리 받아놓자?\r\n\r\n어차피 authority 프라이빗키라 보내는 사람이 조작할 수 없음\r\n\r\n> Issuer name 은 CA의 name\r\n>\r\n> Subject name은 Alice냐 Bob이냐. 누구의 퍼블릭키인지\r\n\r\n\r\n\r\n## X.509 Certificates\r\n\r\n저 인증을... 표준화해놓은거\r\n\r\nX.500이 directory service 표준\r\n\r\n인증서에 관한 디렉토리가 x.509\r\n\r\n각 certificate에는 특정 사용자의 public key가 들어있음. 아이디(user)와 퍼블릭키 쌍에다가 믿을 수 있는 certification authority의 프라이빗키로 위의 쌍이 서명된 형태\r\n\r\n\r\n\r\n## 인증서로 MIM어택 막기\r\n\r\nZ : 지금 보내는 임시공개키 YA가 A가 만든게 맞다는 서명\r\n\r\nC : 퍼블릭키 인증서\r\n\r\n다스가 공격을 성공하려면,\r\n\r\nc와 z중 하나라도 위조할 수 있으면 된다.\r\n\r\n\r\n\r\n* z를 위조하려면 YD1을 넣고 앨리스의 프라이빗키로 서명할 수 있으면 된다.\r\n* 물론 프라이빗키 모름\r\n* C 위조하려면 CA의 프라이빗키 알아야함\r\n\r\n\r\n\r\n## 인증서가 가지는 성질\r\n\r\nCA의 퍼블릭키를 알고있는 누구나 상대방의 퍼블릭키를 확인할 수 있다\r\n\r\nCA외에는 certificate를 조작할 수 없다\r\n\r\n즉, C는 아무나 볼 수 있는 디렉토리에 올려놔도됨\r\n\r\n\r\n\r\n반대로 CA의 공개키가 없으면 인증불가능\r\n\r\n> X.509의 PKI (Public Key Instructure)로 해결 (X.509 CA Hierarchy)ㅣ\r\n\r\n상위 인증 기관\r\n\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"Prediction based 이상탐지 방법 중 하나 RNN 시점상에 예전 데이터 내용을 기억했다가 현재에 영향을 끼치게 하는... 모델 그래프의 파란선이 관찰 초록색이 예측   Reconstruction-based 재구성기반 현재 정상상태를 압축해서 표현 훨씬 낮은 차원의 압축형으로 표현 압축적으로 이렇게 표현하면 되는구나를 배움 계속 강아지로 훈련하다…","fields":{"slug":"/1/"},"frontmatter":{"date":"June 15, 2022","title":"14-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Prediction based\r\n\r\n이상탐지 방법 중 하나\r\n\r\n* RNN\r\n  * 시점상에 예전 데이터 내용을 기억했다가 현재에 영향을 끼치게 하는... 모델\r\n\r\n\r\n\r\n그래프의 파란선이 관찰\r\n\r\n초록색이 예측  \r\n\r\n\r\n\r\n## Reconstruction-based\r\n\r\n재구성기반\r\n\r\n현재 정상상태를 압축해서 표현\r\n\r\n훨씬 낮은 차원의 압축형으로 표현\r\n\r\n압축적으로 이렇게 표현하면 되는구나를 배움\r\n\r\n계속 강아지로 훈련하다가 고양이로 넣으면\r\n\r\n입력받은 고양이와\r\n\r\n고양이 사진을 압축하고 다시 디코드한 고양이 원본하고 달라짐\r\n\r\n압축하고 풀어봤을때 차이가 많이나면 비정상\r\n\r\n\r\n\r\n채점 기준\r\n\r\nReal - 실제로 이상한\r\n\r\nprecision : 얼마나 정확한가. 몇개나맞춘가\r\n\r\nRecall : 찾아야하는 것중 얼마나 찾았나?\r\n\r\n\r\n\r\n## 비트코인\r\n\r\n트랜잭션 : 거래의 흐름\r\n\r\n분산에 기록됨\r\n\r\n기본적으로 타원곡선사용\r\n\r\n트랜잭션을 체인처럼 연결해둠\r\n\r\n잔액이 표현되진않음 거래내역만 확인 가능\r\n\r\n\r\n\r\n가명 = 퍼블릭키 \r\n\r\n 체인을 따라가며 퍼블릭키 확인 가능 : 지급 트랜잭션 완성\r\n\r\n\r\n\r\n블록 : 트랜잭션이 여러 개 들어있는 상자\r\n\r\n블록체인 : 블록들을 차례대로 쌓음\r\n\r\n\r\n\r\nTransaction Chain : 소유권이 어떻게 바뀌어 왔는지 역사\r\n\r\nBlockchain : Transaction Ordering\r\n\r\n* 이전 블록에 대한 hash값\r\n* 전체 트랜잭션들\r\n* nonce\r\n\r\n보는건 누구나 볼 수 있으나 내용을 바꾸려면 위에 블록부터 다 드러내야함\r\n\r\n블록간의 의존관계성립\r\n\r\n\r\n\r\n## 비트코인 네트워크\r\n\r\n분산 네트워크\r\n\r\n비트코인 : db + 네트워크 + 암호\r\n\r\n\r\n\r\n\r\n\r\n비트코인 코어 : 비트코인 네트워크를 돌리는 프로그램\r\n\r\n트랜잭션 풀 : 브로드캐스트로 요청받은 트랜잭션들의 모음\r\n\r\n각자 트랜잭션 풀안에 있는 블록이다름\r\n\r\n누구꺼부터 적용?\r\n\r\n## Mining \r\n\r\n작업증명\r\n\r\nSHA-256수행\r\n\r\n조건을 만족하는 nonce를 찾아야 함\r\n\r\ndifficulty : 채굴의 난이도\r\n\r\n보상이 있어야 체인이 확장됨\r\n\r\n* 코인베이스 트랜잭션\r\n  * 새로운 코인이 생성\r\n* 거래 수수료\r\n  * 트랜잭션 아웃풋의 합이 더 작음\r\n  * 나머지는 수수료\r\n\r\n\r\n\r\n포크되어도 다수결에서 이긴쪽으로 수렴\r\n\r\n\r\n\r\n## NFT\r\n\r\n보통의 암호화폐는 대체5가능하지만 얘는 uniquely identifiable\r\n\r\n체인에 기록하는게 아니라 외부에 저장\r\n\r\n\r\n\r\n* On-chain smart contract : 자동화된 분산네트워크에서 프로그램이 자동으로 돌아감\r\n  * defi, nft\r\n  * 코드상에 버그로 계약을 이상하게 조작해서 악용\r\n  * 버그를 어떻게 자동으로 찾고 해결해줄것이냐\r\n"},{"excerpt":"전자서명 특성&요구조건 특성 누가 언제 보냈는지 확인가능 서명이 일어날 때 그 당시 메세지 콘텐트에 대한 확인 제 삼자에게 증명이 가능함 요구조건 보낸 사람이 부인할 수 없어야함 개인키가 없으면 forgery할 수 없음 서명 생성이 쉬워야함 서명이 있을 때 확인하는 것도 쉬워야함 프라이빗키가 없으면 서명이 생성하는게 어려워야함 이미 있는 서명을 가지고 새…","fields":{"slug":"/2/"},"frontmatter":{"date":"June 14, 2022","title":"13-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n## 전자서명 특성&요구조건\r\n\r\n* 특성\r\n  * 누가 언제 보냈는지 확인가능\r\n  * 서명이 일어날 때 그 당시 메세지 콘텐트에 대한 확인\r\n  * 제 삼자에게 증명이 가능함\r\n* 요구조건\r\n  * 보낸 사람이 부인할 수 없어야함\r\n  * 개인키가 없으면 forgery할 수 없음\r\n  * 서명 생성이 쉬워야함\r\n  * 서명이 있을 때 확인하는 것도 쉬워야함\r\n  * 프라이빗키가 없으면 서명이 생성하는게 어려워야함\r\n  * 이미 있는 서명을 가지고 새로운 서명을 만들어내는게 어려워야함\r\n  * 메시지가 있을 때 거짓된 서명을 만들어내는 것도 어려워야함\r\n\r\n\r\n\r\n> Digital signature generation algorithm : \r\n>\r\n> S = H(M)^d mod n\r\n>\r\n>  Digital signature verification algorithm : H(M) = S^e mod n\r\n\r\n\r\n\r\n\r\n\r\n## DLP and Cyclic Group\r\n\r\nex)\r\n\r\n8^8 mod 19 = 8^2 mod 19\r\n\r\n> 8의 디스크리트 로그는 6제곱하면 다시 1로 돌아옴\r\n>\r\n> 8 mod 6 = 2\r\n\r\n\r\n\r\n## Why subgroups are used?\r\n\r\nDLP based들은 modular exponentiation 사용\r\n\r\n>  x를 주고 값을 구하는게 modular exponentiaion\r\n>\r\n> 나머지를 보고 x를 구하는게 DLP\r\n\r\n지수연산의 복잡도\r\n\r\n* 반복되는 곱셈으로 구성됨. 곱셈의 개수가 지수 x 길이에 대체로 비례한다\r\n* p의 비트길이의 제곱정도에 비례\r\n\r\n> 효율성 측면에선 작은 p를 쓰는게 유리\r\n>\r\n> p가 커지면 퍼포먼스는 떨어지고 안전성은 올라감\r\n\r\n<br/>\r\n\r\n디스크리트를 푸는 대표적 알고리즘 두 가지\r\n\r\n* General Number Field Sieve (GNFS)\r\n\r\n  * mod p로 구성되는 prime field의 대수적인 성질을 이용?\r\n\r\n  * 이 알고리즘의 복잡도는 p의 비트길이가 뭐냐에 따라서 결정된다\r\n\r\n  * ex) 3072bit의 p를 사용할 때 2^128정도의 operations\r\n\r\n  * > 원래 2^2072 정도인데 mod p의 prime field 성질을 이요해서 저 정도로 줄일 수 있다는 뜻인듯\r\n\r\n* Pollard rho\r\n\r\n  * 해시의 충돌을 찾는것처럼 birthday paradox를 사용\r\n  * 디스크리트로그문제뿐만아니라 타원곡선에도 사용됨\r\n  * 이 알고리즘의 복잡도는 x가 몇 가지 정도가 가능하냐에 달려있다\r\n  * ex) 만약 2^256개 정도의 x후보가 있다면 그 것의 루트값인 2^128정도의 operations\r\n  * 굳이 큰 모듈러를 쓸 필요가 없다.\r\n  * q가 x 후보들의 개수가 됨??? (x mod q해서 0~q-1만큼의 후보가 있음)\r\n\r\n두 가지 공격에 대한 대응책\r\n\r\np를 크게하게 q는 적당한 크기로 \r\n\r\n* p는 여전히 크니 GNFS대응\r\n* 2^256개 정도 나오면 괜찮음. 대충 2^256개정도 만들 수 있는 q를 골라서 Pollard rho 대응\r\n\r\n기존 (len(p))^3 => (len(p))^2 x len(q)\r\n\r\n\r\n\r\nL : p\r\n\r\nN : q\r\n\r\n\r\n\r\n타원곡선은 GNFS가 적용이 안됨. 전체 가능한 지수의 개수가 몇 개냐만 공격과 관련이 있음\r\n\r\nxG = Q일 때 x의 종류가 몇 개냐만 관련있음\r\n\r\nq는 프라임이어야하고 폴링 헬만이라는 공격은 q의 인자들을 찾아서 각각에 대해서 따로 공격한다. 즉, q가 프라임이어야함\r\n\r\n\r\n\r\n## Schnorr Identification\r\n\r\nzero knowledge proof protocol (zkp)\r\n\r\n일종의 챌린지 리스폰스 타입의 authentication (사용자인증)\r\n\r\n챌린지 리스폰스? \r\n\r\n> verifier측에서 prover측에게 챌린지를 던짐\r\n>\r\n> ex) 비밀번호에 2를 더한 값을 보내라\r\n>\r\n> 같은 패스워드지만 챌린지에 따라 리스폰스 값이 달라짐\r\n\r\nschonorr는 이 챌린지를 디스크리트 로그 문제를 기반으로 만듦\r\n\r\nex client = Alice, verifier = Bob\r\n\r\nBob은 Alice가 개인키를 알고있는 사람인지 확인\r\n\r\n* alice가 랜덤한 넘버 k를 뽑음 (0부터 q-1사이의 수)\r\n\r\n* k를 사용해 감마를 생성하고 Bob에게 전송\r\n\r\n  * k는 일시적인 프라이빗키, 감마는 일시적인 퍼블릭키\r\n\r\n* Bob이 Alice에게 랜덤한 챌린지 전송\r\n\r\n* Alice는 받은 r을 가지고 y를 생성후 Bob에게 전송\r\n\r\n* Bob은 y를 가지고 수식이 맞는지 확인\r\n\r\n  > v^r은 a^-ar mod p이고\r\n  >\r\n  > a^y = a^k x a^ar mop이므로 둘을 곱하면 a^ar은 상쇄되고 a^k = 감마만 남는다\r\n  >\r\n  > 제너레이터 == 알파\r\n\r\n<br/>\r\n\r\nAlice는 Bob에게 자신의 프라이빗키를 알리고싶지않음\r\n\r\n그러나 계속 인증정보를 주다보면 Bob이 Alice의 프라이빗키를 알 수 있지않을까?\r\n\r\nNo : zero-knowledge proof - 밥한테는 어떤 정보도 주지않음\r\n\r\n(감마, r, y)\r\n\r\n밥이 앨리스하고 얘기하지않고 혼자서 만들어낼 수 있는 순서쌍과 본질적으로 다르지않다. 앨리스로부터 받은 정보가 추가적인 정보라고 보기 힘들다. 제 3자가 보면 똑같은 정보.\r\n\r\n\r\n\r\n## Schnorr Signature\r\n\r\n* schnorr identification은 interactive proof protocol이다\r\n  * 서로 왔다갔다 정보통신\r\n* 인터렉티브 proof protocol을 전자서명으로 바꿔주는 방법 : Fiat-Shamir\r\n\r\n밥이 어떻게 질문을 할 지 미리 앎 : r을 미리 앎\r\n\r\ny도 미리 마음대로 정함\r\n\r\n계산한 감마를 생성\r\n\r\n=> 프라이빗키 a를 모르고도 통신 가능\r\n\r\n=> 왜? 밥이 어떤 질문을 할 지 미리 알아서\r\n\r\n\r\n\r\nr = H(M||감마)\r\n\r\nr을 이렇게 만들면, 위에서 한 r을 먼저만들고 감마를 생성하는 법을 막을 수 있음...\r\n\r\nH가 일종의 랜덤함수 역할\r\n\r\n메시지에 기반해서 만든 r\r\n\r\nAlice가 주는건(감마, y)\r\n\r\nBob이 r을 위의 식으로 만들고 확인\r\n\r\n\r\n\r\n두 번째 서명 방법\r\n\r\n감마가 아니라 (r, y)를 줌\r\n\r\n밥은 r과 y를 사용해 감마'를 만듦\r\n\r\nr = H(M||감마')\r\n\r\n\r\n\r\n## NIST Digital Signature Algorithm\r\n\r\nDSA=DSS\r\n\r\nSHA가 포함됨\r\n\r\n\r\n\r\nSchnorr처럼 p, q를 이용한 서브그룹 구조 사용\r\n\r\np-1의 약수가되는 또 다른 프라임 넘버 : q\r\n\r\nq만큼의 원소를 가지고 있는 서브그룹을 정의...\r\n\r\n지수를 작게 유지하면서 안전성은 해치지않는...\r\n\r\n바깥의 모듈러에는 p를, 지수 모듈러에는 q를 사용\r\n\r\n\r\n\r\ngenerator = g\r\n\r\nx = 개인키\r\n\r\ny = 공개키\r\n\r\n* mod p 하고 또 mod q\r\n  * q는 p보다 훨씬 작은 수\r\n  * 서명의 크기를 줄여준다\r\n\r\n(r, s)를 가지고 서명\r\n\r\n\r\n\r\n\r\n\r\n서명확인?\r\n\r\nw = 두 번째 서명값에 모듈러 역수\r\n\r\nv와 r이 같은지 확인...\r\n\r\n\r\n\r\n공격한다면?\r\n\r\n공개키 y를 가지고 개인키x를 맞출 수 있다면 깨짐 (디스크리트 로그라서 깨기 힘듦)\r\n\r\n\r\n\r\nDSA를 타원곡선버전으로...\r\n\r\n디스크리트 로그는 y = g^x mod p일 때,\r\n\r\nx를 맞추기 어렵다.\r\n\r\n곱하기 연산을 하고 DSA의 경우 q를 사용해 q개 뽑아서 사용. 서브 그룹중에서 몇 번째냐. q번 반복하면 원래값으로 돌아옴\r\n\r\n타원곡선은 dG = Q 일때 d를 맞추기 어렵다. \r\n\r\n지수\r\n\r\n더하기 연산을 하고 1G 2G 3G... nG더하다 보면 원래 값으로 돌아오는 n이 존재.\r\n\r\n상수\r\n\r\n\r\n\r\n## RSA-PSS\r\n\r\n> M^e, C^d이렇게 하면 choosen cipher text attack에 약하다 그러니 OAEP같은 패딩스킴을 쓰자\r\n\r\n얘도 비슷\r\n\r\n랜덤한걸로 패딩 스킴쓰는 그런거 PSS라고 부름\r\n\r\n> 똑같은 메시지를 넣더라도 서명이 그때그때 바뀜\r\n>\r\n> salt가 랜덤화됨\r\n\r\nFIPS 186표준에 포함\r\n\r\n\r\n\r\nH'과 H가 같은지 확인 - 서명\r\n\r\n"},{"excerpt":"Other Security Solutions Virtual Private Network (가상사설망) 사설망 : 외부로부터 분리된 특별한 목적을 가지고 생성된 망 사설망을 모든곳에 깔긴 어려우니 가상으로 생성 IPsec을 가지고 많이 구현함 암호화와 인증 제공 => 터널화 백신, 피씨방화벽 Spam filter Data Loss Prevention(DLP…","fields":{"slug":"/1/"},"frontmatter":{"date":"June 14, 2022","title":"13-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Other Security Solutions\r\n\r\n* Virtual Private Network (가상사설망)\r\n  *  사설망 : 외부로부터 분리된 특별한 목적을 가지고 생성된 망\r\n  * 사설망을 모든곳에 깔긴 어려우니 가상으로 생성\r\n  * IPsec을 가지고 많이 구현함\r\n  * 암호화와 인증 제공 => 터널화\r\n\r\n* 백신, 피씨방화벽\r\n* Spam filter\r\n* Data Loss Prevention(DLP)\r\n  * 민감한 데이터가 분실되거나 악용되는 것을 방지하기위한 툴\r\n  * 기업에서 중요한 데이터를 외부로 빠져나가지 못하게 함\r\n  * 개인 직원이 주요 데이터를 빼돌리는 것 말고도 공격자가 들어와서 중요 데이터를 기업의 이미지를 훼손시키기 위해 빼가는 경우 - 개인 정보가 유출되었기에 패널티를 받음(벌금등)\r\n  * 데이터가 어디에 어떻게 사용되고 어디로 이동했는지에 사용\r\n* Endpoint(Threat) Detection and Respose (EDTR)\r\n  * 단말내에서 이상한 일이 생기는지 탐지하고 대응\r\n  * 랜섬웨어, 멜웨어 등을 막음\r\n  * 원격에 있는 클라우드에서 개인의 pc를 감시\r\n* Security information and event management(SIEM)\r\n  * 로그같은걸 자동분석\r\n  * 이벤트 자동분석\r\n  * 사용자, entity(주체)의 동작을 분석\r\n  * 머신러닝, ai의 도움\r\n* Security orchestration, automation and response (SOAR)\r\n  * 종합관리\r\n  * 일일히 사람이 신경쓰기 어려우니 자동화\r\n  * 공유, 자동화, 조직화, 표준화\r\n\r\n\r\n\r\n\r\n\r\n## CNN\r\n\r\nconvolutional neural network\r\n\r\n* 화면으로 찍은 사진을 가지고 어떤 물체인지 분류하는데 사용\r\n* 특정 영역에 연산을 해서 결과를 얻어냄\r\n* 일부 영역에 대한 특징을 압축해서 나타냄\r\n  * filter라고 부르는 행렬과 곱셈을 수행\r\n  * U = XW + b\r\n  * X : input\r\n  * W : weight vector (filter)\r\n  * b : bias\r\n  * W와 b를 잘만들어내는게 인공지능에서 traning, learning에 해당\r\n\r\n* 활성화 함수\r\n  * ReLU\r\n  * 원소 하나하나에 대해서 독립적으로 적용\r\n* 풀링\r\n* feature vector (final output)\r\n* softmax function\r\n  * feature vector의 각각의 값을 극대화시킴\r\n  * 차이를 극명하게 하기위해 사용\r\n\r\n\r\n\r\nW와 b를 합쳐 세타(파라미터)라고 칭함\r\n\r\n* 빨간 화살표가 에러\r\n* 검은 점이 actual\r\n* 그래프가 target\r\n\r\n에러를 줄이는 방향으로 (Gradient Descent)\r\n\r\ntraining data set을 가지고 모델을 트레이닝\r\n\r\n내가 관찰한 값과 cnn으로 나온 값이 비슷하게 만들어주는 과정\r\n\r\n\r\n\r\n### 적대적 예제\r\n\r\n잘 훈련된 모델을 만듦\r\n\r\n공격자는 입력을 조작함\r\n\r\n그랬더니 함수의 오류가 증가\r\n\r\n경계선을 넘어가 오류가 넘어갈만한 데이터를 입력으로 보냄\r\n\r\n사람에겐 보이지않는 노이즈를 추가해서 기계가 잘못 판단하게\r\n\r\n\r\n\r\n막자!\r\n\r\n## countermeasures to adversarial examples : AI Robustness\r\n\r\n* Adversarial training\r\n  * 노이즈를 집어넣어서 경계선을 더 잘 긋도록 만들자\r\n* Input transformation (Denoiser)\r\n  * 인풋을 바꿔줌\r\n  * 노이즈 섞인 이미지를 그대로 넣지 않고 노이즈가 제거되게 변환을 해줌\r\n* Model Ensemble\r\n  * 분류기를 하나만 쓰지말자\r\n  * 한 분류기가 특정 노이즈한테 약할 수 있음\r\n  * 여러 분류기가 똑같이 분류해야 결과를 내놓겠다!\r\n  * 비용이 많이 들긴함\r\n\r\n## Data Protection and Privacy\r\n\r\n* Strava\r\n  * 중동에 있는 미국기지의 위치를 노출시킴\r\n  * 자기의 위치를 인식시키고 실행시킨 상태에서 운동하면 운동 경로 확인 가능\r\n  * 막는 방법은 데이터를 공유못하게한다!\r\n\r\n* GPT : 자연어 처리하는 모델 중 하나\r\n  * 자연어 처리 모델을 학습하는데 사용된 데이터에서 개인정보 노출\r\n  * GPT는 입력을 주면 그 다음 내용을 예상함\r\n\r\n#### 막는 방법\r\n\r\n* Differential Privacy(차분 privacy)\r\n  * 차이가 있는 privacy\r\n  * 프라이버시를 수학적으로 잘 정의\r\n  * 내 데이터를 넣고 트레이닝 시켰을 때와 빼고 트레이닝 시켰을 때의 쿼리 결과가 구분이 안되면 dffirential privacy를 만족한다고 함\r\n  * 어떤 개인의 데이터 포함 유무에 상관없이 모델의 결과가 바뀌지않을 때\r\n  * 학습의 성능은 최대한 유지하면서 privacy도 보호\r\n* Homomorphic Encryption (동형암호)\r\n  * 어떤 암호문안에 있는 평문의 구조를 유지하는 암호문\r\n  * 암호화를 한 다음에 결과에 대해서 계산을 한 것 = 계산 먼저하고 암호화 한 것\r\n  * AES처럼 완전 랜덤한 것은 이 성질을 만족할 수 없음(랜덤bit가 완전 다른 결과를 만들어냄)\r\n  * RSA textbook에서는 만족\r\n  * 상자에 넣는 과정이 동형암호...\r\n  * 검사 연산이 금세공...\r\n\r\n데이터를 암호화해서 서버에 올림\r\n\r\n서버는 암호화 한 상태에서 연산 수행\r\n\r\n다시 데이터 주인에게 전달해서 암호를 풀어보면 유용한 정보 획득\r\n\r\n서버는 모델을 사용자에게 공유하고싶지않고\r\n\r\n사용자는 자신의 데이터를 서버에 노출시키고 싶지않음\r\n\r\n두 조건을 만족하게 homomorphic encryption\r\n\r\n* 근데 속도가 느림\r\n\r\n\r\n\r\n## Anomaly Detection\r\n\r\n이상탐지\r\n\r\nips(침입방지)  : 공격자의 행위를 분석해서 방지\r\n\r\nsnort : 행위를 시그너처로 만들고 탐지\r\n\r\n알려진 공격에 대해서는 잘찾음\r\n\r\n알려지지않은 공격을 탐지할 때는 정상적인 유저의 행동을 잘학습시키고 벗어나면 이상 탐지\r\n\r\n지도학습, 반지도학습보다는 unsupervised learing이 적합\r\n\r\n훈련할 때는 정상 데이터만? 그냥 데이터 주고 모델은 정상 행동으로 학습\r\n\r\n  "},{"excerpt":"Working-Set Model 어떤 프로세스의 워킹셋은 어떻게 구할까? reference bit을 사용한다 페이지가 접근될때마다 r-bit을 1로 바꿔줌 1인 애들을 모아 워킹셋을 만듦 t1이 지나면 1을 0으로 초기화 워킹셋을 델타시간때마다 구할 수 있다 델타가 커지면 워킹셋을 구하기 애매 ex) 10000일 때 5000time으로 나누고 각 페이지마…","fields":{"slug":"/15/"},"frontmatter":{"date":"June 12, 2022","title":"os 14-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Working-Set Model\r\n\r\n어떤 프로세스의 워킹셋은 어떻게 구할까?\r\n\r\nreference bit을 사용한다\r\n\r\n* 페이지가 접근될때마다 r-bit을 1로 바꿔줌\r\n* 1인 애들을 모아 워킹셋을 만듦\r\n* t1이 지나면 1을 0으로 초기화\r\n\r\n워킹셋을 델타시간때마다 구할 수 있다\r\n\r\n델타가 커지면 워킹셋을 구하기 애매\r\n\r\nex)\r\n\r\n10000일 때 5000time으로 나누고\r\n\r\n각 페이지마다 r-bit 2bit준비\r\n\r\n페이지가 access되면 1st rbit에 1을 넣음\r\n\r\ninterrupt가 들어오면 1st rbit을 2nd rbit에 옮겨 닮고 1st를 초기화\r\n\r\ninterrupt이후 access된 메모리의 1st를 1로 만듦\r\n\r\n1st와 2nd에 있는 애들을 워킹셋에 추가함\r\n\r\n조금 더 작은 단위로 조사할 수 있다...\r\n\r\n\r\n\r\n더 자세하게 하고싶으면 더 세분화로 나눔... + r  bit많이 추가.\r\n\r\n단, 페이지마다 rbit을 관리해줘야해서 비용이 커짐\r\n\r\n\r\n\r\n## Page-Fault Frequency\r\n\r\n허용 가능한 수준의 PFF(page fault frequency)를 사전에 정함\r\n\r\nlocal replacement policy를 통해서 프로세스마다 할당하는 프레임을 변경시킨다\r\n\r\n* actual rate가 낮으면 frame수를 낮춤\r\n* actual page fault rate가 크면 frame수를 높임\r\n\r\n-> PFF가 적절하게 조절될 수 있음\r\n\r\n단점 : 프로세스가 많아지면 모든 프로세스가 가져갈 수 있는 프레임수가 줄어든다\r\n\r\n\r\n\r\n사실 가장 근본적인 해결책은 메인 메모리를 많이 꽂아주는거\r\n\r\n그러나 메인 메모리도 늘어나는데 한계가 있다\r\n\r\n리눅스의 경우, pagefault가 많이 일어나면 특정 프로세스를 죽임 - OOM killer\r\n\r\n* 가장 많은 공간을 얻을 수 있는애를 죽임\r\n* OOM_SCORE : 높을수록 메모리 회수를 많이 할 수 있음\r\n\r\n\r\n\r\n## Allocating Kernel Memory\r\n\r\n커널 메모리는 미리 메모리 풀을 할당해놓음\r\n\r\n왜 커널은 따로 관리?\r\n\r\n커널 메모리 공간중에 일부는 연속적일 필요가 있다.\r\n\r\nex) device io를 위한 메모리공간\r\n\r\n일반적으로 커널은 메모리allocation함수를 자주 호출한다\r\n\r\n allocation할 때마다 internal fregmentation이 많이 발생할수도 \r\n\r\n그래서 커널은 미리 많이 떼어두고 그 안에서 작게 작게 잘라서 준다\r\n\r\n\r\n\r\n어떻게 잘라서 줄까?\r\n\r\n### Buddy System Allocator\r\n\r\n커널을 위해서 연속된 공간을 할당받아둠\r\n\r\n미리 할당 받은 공간을 이진 바이너리 처럼 관리\r\n\r\n특정한 함수가 공간을 할당해달라고 하면 그 공간의 크기가 될때까지 계속 반으로 나눔\r\n\r\nex) 총 256KB인데 32KB 공간을 할당해달라는 요청이오면, 256 -> 128 2개 -> ... 32가 나올때까지 반으로 나눈다 (나머지는 free영역으로 관리)\r\n\r\n\r\n\r\n다음에 어떤 메모리 요청이 오면 그거에 맞는 공간을 할당해주기 쉬움 (여러 크기로 나눠져있는 상태)\r\n\r\n세분화 & 합치는게 빠름\r\n\r\n\r\n\r\ninternal fragmentation이 심할수도\r\n\r\n* 아무리 잘게 쪼개도 2의 제곱 형태\r\n\r\n\r\n\r\n메모리를 항상 2의 제곱형태로 관리\r\n\r\n\r\n\r\n\r\n\r\n### Slab Allocator\r\n\r\n커널은 하나의 큰 메모리 공간을 할당 받음 : kernal mem\r\n\r\nkernal mem을 multiple slab으로 나눔\r\n\r\n각각의 slab은 multiple pages로 구성됨\r\n\r\n* 연속된 contiguous page\r\n\r\nslab마다 다른 size의 object를 관리한다\r\n\r\n\r\n\r\nCache\r\n\r\n* 하나나 그 이상의 slab으로 이루어짐\r\n\r\n* 자주 사용되는 data\r\n* 특정한 사이즈의 오브젝트만 사용할 수 있는 메모리 공간\r\n* 컴퓨터 구조에서 배우는 캐시랑 다른 애임 (slab allocator에서 사용되는 캐시)\r\n* 커널 데이터를 위해 미리 캐시만큼 할당해놓음\r\n* object 생성 요청이 들어오면 해당 크기만큼의 캐시를 찾아 하나 매핑해줌\r\n* 캐시는 처음부터 크게 잡지않음\r\n* 캐시가 꽉차면 빈 slab하나를 더 가져와서 캐시 크기를 늘린다\r\n\r\n\r\n\r\n장점\r\n\r\nfragmentation이 없음\r\n\r\n* slab단위로 캐시에 할당\r\n* 캐시안을 실제 커널에서 사용하는 메모리 사이즈로 줄여둬서 internal fragmentation 안생김\r\n\r\n* external은 있을수도있음\r\n\r\n메모리 request를 할 때도 해당하는 size들이 캐시에서 할당받은 것이기 때문에 그 주소만 받아오면 바로 사용할 수 있다 <뭔소리?\r\n\r\n따라서 fast memory request satisfaction이 가능하다\r\n\r\n\r\n\r\n## I/O Devices\r\n\r\n지금까지는 cpu, 메모리에서 os가 해줘야할거 배움\r\n\r\n  Many I/O device도 있다...\r\n\r\n피씨에 장착이 됨\r\n\r\n\r\n\r\nPort : 디바이스와 프로세스를 연결하는 포인터\r\n\r\n* 포트는 제한적\r\n* 포트에 expansion bus interface를 연결해서 하나의 포트를 여러개로 나눌 수 있음. 나눠진 거에 추가적으로 컴포넌트 연결 가능 (느린 device일 경우 가능)\r\n\r\nBus : 포트들을 프로세스와 연결\r\n\r\n* shared bus\r\n* daisy chain(직렬 연결) : device to device\r\n\r\nController\r\n\r\n* 호스트 어댑터라고도 함\r\n* I/O 디바이스를 컨트롤함\r\n* I/O디바이스 자체에 장착되기도 하고 GPU같은 경우는 메인보드에 별도로 장착\r\n\r\n* 또 다른 작은 컴퓨터, 간단한 프로세싱을 할 수 있는 프로세서와 메모리, 컨트롤러가 있음\r\n\r\n\r\n\r\n### I/O Hardware\r\n\r\n컨트롤러에는 레지스터들이 있다\r\n\r\n* status reg : busy(1bit)\r\n* control reg : 명령어가 들어감\r\n* data -in/ -out : 시스템으로 들어오는/호스트가 디바이스한테 보내주는 데이터\r\n\r\nstatus, control reg같은 경우는 적은 byte에 저장(1-4), data-in, out같은 경우는 여러 개의 데이터를 FIFO buffer를 이용해서 여러 개의 데이터를 동시에 보관\r\n\r\n큰 동작\r\n\r\ncpu가 status reg 값 확인(놀고있나 일하고있나)\r\n\r\n놀고있으면 control reg한테 일해달라고 요청\r\n\r\ncpu한테 전달할 data가 있으면 data-in reg에 값을 써둠\r\n\r\n레지스터들을 통해서 디바이스와 호스트 프로세스간의 소통이 이루어짐\r\n\r\n각각의 레지스터를 지칭할 주소가 필요\r\n\r\n주소는 어떻게 관리?\r\n\r\nMemmory-mapped I/O - 메모리를 따로 빼두고 씀\r\n\r\n* 사용하는 레지스터 공간이 클 때 사용\r\n* 일반적으로 port- mapped io 사용\r\n\r\nPort-mapped I/O - 포트별로 관리\r\n\r\n\r\n\r\n\r\n\r\n## Polling and Interrupt\r\n\r\n### Polling\r\n\r\n호스트가 일을 시키는데 아이오 디바이스가 일을 완료하는데 시간이 오래걸림\r\n\r\n디바이스가 직접 알려주지않고 호스트가 매번 일이 됐는지 확인하는게 폴링\r\n\r\n\r\n\r\nhandshaking\r\n\r\n* host cpu는 io device controller 한테 일을 시키기전에 busy bit 확인\r\n  * 1이면 기다림 0이면 일을 시킬 수 있음 (지속적으로 확인) <- polling\r\n  * 디바이스가 느리면 자주 확인해야함\r\n  * 확인하는 정도를 잘 조절해야함\r\n\r\n* controller reg한테 read인지 write요청인지 써둠 (write일 경우 어떤 data가 나가는지도 data-out reg에 함께 써둠, 주소도 같이 전달)\r\n* 일을 시키고자 하는 정보들이 전부 전달이 됐으면 command-ready bit을 1로\r\n* i/o컨트롤러는 커맨드 레디 비트가 1이되면 busy bit을 1로 만들어줌\r\n* 커맨드에 해당하는 transfer를 수행\r\n* 모든 data transfer이 끝나면 busy bit, error bit, command-ready bit 을 0으로\r\n\r\n\r\n\r\n### Interrupts\r\n\r\n> 폴링은 하는데 3개의 명령어만 필요\r\n>\r\n> * status reg로부터 값을 읽음\r\n> * 읽은 bit중에 ready bit에 해당하는 부분만 &를 사용해서 뽑음\r\n> * 1인지 0인지 판단\r\n\r\n간단하지만 문제는 이걸 자주 해야함\r\n\r\n\r\n\r\n그래서 interrupt 사용\r\n\r\ninterrupt는 디바이스 컨트롤러가 호스트한테 직접 알려줌\r\n\r\ninterrupt가 들어오면 cpu는 자기가 하던 instruction을 마치고 interrupt에 해당하는 interrupt handler를 불러서 수행\r\n\r\n핸들러가 끝나면 원래 하던 일을 복구\r\n\r\n\r\n\r\n만약에 디바이스 드라이버가 I/O를 초기화하는데 I/O의 크기가 매우 크면\r\n\r\nex) 10MB 짜리 파일을 메모리에 저장해야할 때\r\n\r\n* 10MB = 4KB x 2560\r\n* I/O가 2560번의 초기화를 해야함\r\n\r\n\r\n\r\n\r\n\r\n### DMA (Direct Memory Access)\r\n\r\nio가 cpu한테 4kb보내주면  cpu가 그걸 메모리에 쓰는게 아니라 중간에 DMA가 존재\r\n\r\nDMA가 4KB 데이터를 메모리에 직접 쓰게 하자\r\n\r\n10MB다 끝나면 DMA가 알려주자\r\n\r\n* large data movement같은 경우엔 DMA가 대신 일을 해줘서 cpu의 부담을 줄임\r\n* cpu를 bypass해서 바로 io에서 memory로 데이터를 써주는 효과를 내자\r\n* cpu는 처음 초기화할 때만 관여\r\n* DMA가 mem에 데이터 저장\r\n* 일이 다 끝나면 DMA가 cpu한테 알려줌 dma가 인터럽트를 보냄\r\n\r\n\r\n\r\ncpu 는 dma한테\r\n\r\n작업의 크기\r\n\r\n어떤 명령어인지\r\n\r\nsrc, dest의 주소등을 알려줌\r\n\r\n\r\n\r\n"},{"excerpt":"Demand Paging 프로세스가 필요할 때마다 그 때 그 때 올려놓는다 Valid-Invalid Bit v : 메모리에 있는 페이지다~ vs i : 없어서 HDD가야한다~ i인 경우 두 가지 유효하긴 한데 메모리에 지금 없음 진짜로 무효; (stack과 힙사이 비어있는 공간) i인것만보고 두 가지 중 무엇인지 알 순 없음 하드웨어 MMU는 i인걸보면 …","fields":{"slug":"/1/"},"frontmatter":{"date":"June 12, 2022","title":"os 14-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Demand Paging\r\n\r\n> 프로세스가 필요할 때마다 그 때 그 때 올려놓는다\r\n\r\n### Valid-Invalid Bit\r\n\r\nv : 메모리에 있는 페이지다~ vs i : 없어서 HDD가야한다~\r\n\r\n* i인 경우 두 가지\r\n\r\n  * 유효하긴 한데 메모리에 지금 없음\r\n\r\n  * 진짜로 무효; (stack과 힙사이 비어있는 공간)\r\n  * i인것만보고 두 가지 중 무엇인지 알 순 없음\r\n\r\n하드웨어 MMU는 i인걸보면 그냥 page fault라는 정보만 전함\r\n\r\nOS는 page fault에 대한 동작(대응)을 함\r\n\r\n\r\n\r\n### Page Table Example\r\n\r\nswap space(HDD, backing store)\r\n\r\nOS는 page fault를 받으면 HDD에서 해당 정보를 가져와 physical memory의 빈 공간에 위치시킨다\r\n\r\n\r\n\r\n\r\n\r\n### Page Fault\r\n\r\ni이면, OS에게 Page Fault라는 트랩을 발생시킴\r\n\r\n1. OS는 i가 실제 Invalid라서 난건지 그냥 메모리에 없는건지 판단함 (Invalid라면 abort)\r\n   * 어떻게 앎?\r\n   * PCB와 함께 table을 만들어서 관리한다\r\n\r\n2. Find free frame\r\n3. 디스크 오퍼레이션에게 스케줄링을 시켜서 디스크에서 해당 페이지 내용을 가져옴\r\n4. valid-invalid bit를 v로 바꾸고 페이지를 업데이트\r\n5. 메모리 요청을 한 인스트럭션을 restart\r\n\r\n\r\n\r\n### Demand Paging의 특성\r\n\r\n프로세스 시작할 때 메모리에 아무것도 없음\r\n\r\n프로세스의 첫 번째 인스트럭션 자체가 메모리에 없음\r\n\r\n처음부터 페이지 폴트 발생\r\n\r\n모든 첫 번째 access에서는 page fault가 발생한다\r\n\r\n\r\n\r\n하나의 인스트럭션이 여러 개의 메모리에 접근을 요청한다면?\r\n\r\n* multiple page faults 발생\r\n* 로컬리티때문에 자주 발생하진않음\r\n\r\n\r\n\r\n### Instruction Restart\r\n\r\n> 만약 b = ++a; 라는 코드를 처음 실행할 때\r\n>\r\n> a와 b가 다른 페이지에 있어 page fault가 두 번 발생한다면 \r\n>\r\n> 1. a를 읽어옴 <- page fault\r\n> 2. a에 1을 더해서 a에 저장\r\n> 3. b에 a값을 저장 <- page fault\r\n>\r\n> 2까지 하고 b를 위해 page fault를 하고 다시 2다음부터 수행한다?\r\n>\r\n> * 어려움. 하나의 instruction이므로 atomic 해야 함\r\n> * 아예 재시작 : 2번에서 a값 늘렸는데 어떻게... 되돌리죠?\r\n\r\n그럼 인스트럭션 중간에 page fault가 발생한다면 어떻게 해야할까?\r\n\r\n* auto increment/decrement : 하드웨어 서포트가 필요\r\n  1. instruction시작전에 page fault 검사\r\n  2. 수행하다가 page fault 발생하면 해당 instruction이 바꾼 내용을 전부 원상복구\r\n\r\n\r\n\r\n## TLB Fault\r\n\r\n모든 페이지 펄트는 티엘비 펄트를 항상 유발 (당연히 TLB에도 정보 없음)\r\n\r\nPage Fault가 나면?\r\n\r\n1. MMU가 OS에게 trap걸어줌\r\n2. OS는 기존에 수행하던 유저 레지스터와 프로세스 state를 저장함\r\n3. 방금 온게 page fault였는지를 다시 판단함\r\n4. Invalid인지 단순 mem에 없는건지 확인\r\n5. 디스크의 어디에 이 페이지가 있는지 찾는다\r\n   * 아예 처음시작이에 프로그램 파일에 적힌 코드나 데이터면 swap space에도 없음. 1. program file에 있음\r\n   * 한 번 불렸다가 쫓겨난 애거나 빈 스택이면 2. swap space\r\n6. free frame에 가져옴 (디스크한테 요청보냄 I/O)\r\n7. I/O를 기다리는동안엔 cpu에서 다른 프로세스가 실행될수도있음\r\n8. I/O interrupt를 받으면 돌던 프로세스의 레지스터와 스테이트를 저장\r\n9. 인터럽트가 디스크에서 온건지 확인\r\n10. 페이지 테이블을 수정하고 메모리에 있다고 표시해줌\r\n11. cpu가 해당 프로세스를 다시 시작할 수 있게 기다림\r\n12. restart instruction\r\n\r\n\r\n\r\n\r\n\r\n* 오래 기다려야함\r\n* 퍼포먼스에 안좋은 영향을 끼칠수도\r\n* 이미 page에 있는애 쫓아낼 때도 I/O발생\r\n* 다시 시작하려면 레지스터그런거 컨텍스트 스위칭\r\n\r\nEAT \r\n\r\n> TLB때보다 더 큼 \r\n\r\n* 프로세스를 바꾸고 다시 넣고하는 비용. 레지스터 대피 비용. state저장 비용 이런거 다 합친게 page fault overhead\r\n* swap page out : free frame이 없으면 victim page가 swap space에 다시 써지는데 걸리는 시간\r\n* swap page in : 사용하고 싶은 page가 disk로부터 읽어 들어와지는 시간\r\n\r\n\r\n\r\n### Key Issues\r\n\r\n* Page selection\r\n  * 언제 어떤 페이지를 가져올까?\r\n\r\n* Page replacement\r\n  * 언제 어떤 페이지를 내보낼까?\r\n* Page frame allocation\r\n  * 각 프로세스에게 프레임을 얼마나 할당해줄까?\r\n\r\n\r\n\r\n### Page Selection\r\n\r\nPage Selection Policies\r\n\r\n* Demand paging\r\n  * 시작할 때 아무것도 없고 page fault가 일어나면 그 때 가져옴\r\n* Prepaging\r\n  * HDD에서 한 번 가져올 때 인접한 공간에 있는 것도 같이 가져오자\r\n  * 인접할 경우도 ... 많은 건 아님? 예언자가 있어야...\r\n\r\n* Request paging\r\n  * 직접적으로 요청\r\n  * 유저가 직접 나 이 페이지 필요하니까 미리 읽어줘~\r\n  * 어려움. \r\n\r\n그냥... 디맨드 페이징 사용함\r\n\r\n\r\n\r\n### Copy-on-write\r\n\r\n첫 프로세스를 제외하고는 기존 프로세스를 복제\r\n\r\n새로 만드는게 아니라 기존의 것을 재활용하자\r\n\r\n실질적으로 데이터를 바꿔쓰는 write은 데이터를 바꿀때 시작됨\r\n\r\nfork : 똑같은 페이지지만 별도의 영역에 복사\r\n\r\nvfork : 프레임에 있는 같은 페이지를 가리키게 함\r\n\r\n* 동일한 pagetable\r\n\r\n요즘은 그냥 fort써도 vfork처럼 동작;;;\r\n\r\n\r\n\r\n## Page Selection\r\n\r\n* exec()하거나 코드가 달라져서 데이터를 수정하게 되면 그제서야 실제 page fault일으키고 데이터를 가져와서 프레임에 채운다\r\n\r\n\r\n\r\n## Page Replacement\r\n\r\nEAT를 줄일 수 ㅇㅆ는 가장 중요한 요소\r\n\r\n프레임이 꽉 차있다면 누군가를 아웃시켜야함\r\n\r\n만약 A가 변경됐다면 victim frame을 반드시 hdd에 write해줘야함\r\n\r\n* 변경이 안됐으면 어차피 hdd에 저장되어있으니까 그냥 삭제만 하면됨\r\n\r\nEAT를 줄이는 방법\r\n\r\n1. victim을 고를 때 non-dirty 를 swap out( 다시 write안해도 됨)\r\n2. 다시 swap-in 될 page는 가급적으로 swap-out에서 배제\r\n"},{"excerpt":"Page Replacement 어떤 페이지를 내쫓을 것인가 reference string : 페이지가 access 되는 순서대로 페이지를 나열해둔 string Random : 생각보다 잘 동작하지만 optimal은 아님 FIFO : 들어온지 가장 오래된 frame을 내쫓음 Optimal : 미래를 예측해서 앞으로 가장 참조되지 않을 것 같은 페이지를 내쫓…","fields":{"slug":"/2/"},"frontmatter":{"date":"June 12, 2022","title":"os 14-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Page Replacement \r\n\r\n어떤 페이지를 내쫓을 것인가\r\n\r\nreference string : 페이지가 access 되는 순서대로 페이지를 나열해둔 string\r\n\r\n* Random : 생각보다 잘 동작하지만 optimal은 아님\r\n* FIFO : 들어온지 가장 오래된 frame을 내쫓음\r\n* Optimal : 미래를 예측해서 앞으로 가장 참조되지 않을 것 같은 페이지를 내쫓음 - 예측이 어려움\r\n* LRU : 가장 오랫동안 사용되지않은 페이지를 내쫓음, 가장 optimal에 가까움\r\n\r\n\r\n\r\n### FIFO\r\n\r\nBelady's Anomaly\r\n\r\n* frame을 늘렸는데 page fault가 더 많이 일어나는 현상\r\n\r\n\r\n\r\n### Optimal\r\n\r\n사실상 쓰이진않고 알고리즘을 비교할 때 사용됨\r\n\r\n\r\n\r\n### LRU\r\n\r\nBelady's Anomaly가 발생하지않음\r\n\r\n* stack algorithm를 항상 만족하므로 증명 (Belady's Anomaly와 반대)\r\n* n개 프레임이 있는 메모리가 있을 때 n프레임을 사용하는 페이지 set들은 항상 n+1프레임을 사용하는 페이지의 subset이다\r\n* 왜?\r\n  * LRU는 내쫓는 순서가 항상 똑같다?\r\n  * n이든 n+1이든 항상 참조된지 오래된 애를 내쫓음\r\n  * 참조되는 순서도 똑같으니 내쫓기는 순서도 똑같다 (n+1이면 그냥 한 박자 늦게 쫓겨나는 것일뿐...)\r\n  * fifo는 쫓겨나는 순서가 다시 들어오는 순서에 영향을 미치기 때문에 항상 일치하지않는다\r\n\r\nLRU의 단점 : Implementation이 어렵다\r\n\r\nSW적인 해결방법\r\n\r\n* Counter implementation\r\n  * 언제 참조됐는지를 기록\r\n  * 모든 페이지의 entry에 counter를 두고 참조될때마다 시간을 기록한다\r\n  * 단점 : 페이지를 내쫓을 때 모든 페이지들의 참조시간을 비교해봐야하므로 다 뒤져봐야함\r\n  * 페이지 엄청 많은데 언제... 다 뒤져?\r\n  * 실행 어려움\r\n* Stack implementation\r\n  * 페이지가 참조되는 순서대로 linked list를 만듦\r\n  * search가 필요하지않음\r\n  * update 비용이 큼 (포인터 끊고... 옮기고)\r\n  * 오버헤드가 큼\r\n  * linked list 하드웨어로 구현하기 힘듦\r\n\r\n\r\n\r\n## LRU Approximations\r\n\r\n위처럼 구현이 어려워서 LRU를 완벽하게 구현하지않고 비스무리하게 만든다\r\n\r\n* 하드웨어 support를 받음\r\n  * reference bit(1bit)\r\n  * 처음 page가 access되면 0\r\n  * page가 다시 access되면 1\r\n  * 0인 애들부터 내쫓음\r\n\r\n1bit로 판단하기에는 부족\r\n\r\n더 발전된 방법들은 아래에\r\n\r\n\r\n\r\n### Additional-Reference\r\n\r\nreference bit + 8bit register사용\r\n\r\n* 각 페이지마다 9bit의 data를 가지고있음\r\n\r\n주기적으로 [r-bit + 8bit]를 오른쪽으로 shift한다\r\n\r\n* r-bit에는 0을 채운다\r\n* 1이 앞에 있을수록 최근에 접근됨\r\n* 1이 제일 뒤에 등장하는 애를 교체함\r\n\r\nTime interval 형태로 LRU를 체크하는 형태\r\n\r\n* 동작 자체에는 오버헤드 없음\r\n* 0을 1로 바꾸고 shift하기만 함\r\n\r\n단점\r\n\r\n* 모든 페이지들의 bit를 비교해야함\r\n* 모든 페이지마다 9bit씩 할당해야해서 오버헤드 발생 가능\r\n\r\n\r\n\r\n### Second-Chance Algorithm\r\n\r\nclock algorithm이라고도 부름\r\n\r\nr-bit 하나 쓰는건 동일하나 FIFO와 결합됨\r\n\r\n* 참조된지 가장 오래된 page를 찾음 : circular linked list이기 때문에 바로 찾음\r\n* 해당 page의 r-bit을 찾음\r\n  * 0이면 바로 교체\r\n  * 1이면 second chance를 줌 : r-bit를 0으로 바꾸고 다음 순서를 탐색\r\n\r\n* low overhead\r\n* 1bit만 사용해서 여전히 불안정\r\n* 모든 페이지의 r-bit이 1이면 fifo와 동일해짐 : 0을 만날 때까지 한 바퀴 돌아야 함\r\n\r\n\r\n\r\n\r\n\r\n### Enhanced Clock Algorithm\r\n\r\n* 탐색의 비용을 줄이는 방법은 아니고 정확도를 높이는 방법\r\n\r\n> victim을 고를 때 \r\n>\r\n> * 미래에 있을 page fault를 줄이는 것이 중요\r\n> * 수정이 된 애면 swap을 할 때 disk에 기록해야함\r\n> * 수정이 된 애가 아니면 disk에 기록할 필요가 없음\r\n> * 즉 수정이 안된 애를 내쫓는게 이득\r\n\r\n(reference bit,  dirty bit)\r\n\r\n교체 순위순\r\n\r\n1. (0, 0) : 교체 일순위\r\n\r\n2. (0, 1) : 최근에 access되진않았지만 modify는 된 애\r\n3. (1, 0) : 최근에 access되어서 금방 다시 사용될지도\r\n4. (1, 1) : 최근에 access까지 됐고 수정해서 교체 비용도 큼\r\n\r\n\r\n\r\n(0, 0)을 만날때까지 탐색...\r\n\r\n(0, 0)이 없으면 다음 순위인 (0,1)\r\n\r\n최악의 경우에는 여러번 circular queue를 돌아야함\r\n\r\n\r\n\r\n### Counting-Based Algorithm\r\n\r\n잘 사용되지않음\r\n\r\n각 페이지마다 counter를 줌\r\n\r\n아까 걔는 시간을 기록하고 얘는 페이지가 access됐던 횟수를 기록\r\n\r\n두 가지 알고리즘을 적용할 수 있음 (둘 다 common한 방법은 아님, 실질적으로 사용되는건 clock algorithm정도)\r\n\r\n* LFU (smalles count를 교체)\r\n* MFU (max count를 교체)\r\n  * smallest count는 메모리에 들어와서 오래되지않은애 . 최근에 참조됐으니까 재참조가 되지않을까 하는 가정에서 수행\r\n\r\n\r\n\r\n## Page Frame Allocation\r\n\r\n각각의 프로세스한테 프레임을 개별적으로 할당해줄지, shared 영역으로 보고 할당해줄 것인지\r\n\r\n각각의 프로세스에게 얼마나 많은 프레임을 할당해줄 것 인가?\r\n\r\n\r\n\r\n#### Fixed Allocation\r\n\r\n* Equal allocation이라고도 부름\r\n  * 각각의 프로세스한테 동일한 숫자의 frame을 제공한다\r\n  * 독립된 영역이면서 동일하게 할당\r\n  * 프로세스마다 사용하는 양이 다른데 동일하게 할당하는건 불공평\r\n\r\n* Proportional allocation\r\n  * 프로세스가 사용하는 size를 보고 그에 맞춰서 할당해줌\r\n\r\n\r\n\r\n* Priority Allocation\r\n  * 사이즈가 아니라 priorities를 보고 \r\n\r\n\r\n\r\n#### Global allocation\r\n\r\n* 공유해서 쓰자~\r\n* 모든 프레임을 공동으로 사용\r\n* 프로세스에게 딱히 딱딱 잘라서 나눠주지않음\r\n* page fault를 많이 일으키는 하나가 있다면 다른애들도 성능에 영향을 받을 수 있음\r\n* 그러나 공유를 해서 효율성 증가 : throughput증가\r\n* 일반적으로 쓰이는 방법\r\n\r\n\r\n\r\n#### Local allocation\r\n\r\n* 각자 쓰자~\r\n\r\n\r\n\r\n\r\n\r\n## Thrashing\r\n\r\n프로세스가 많이 돌아가고 있어서 페이지 개수는 많은데 메모리양이 작다면 page fault가 많아짐\r\n\r\n계속 page fault나서 부르고 교체하는걸 thrashing이라함\r\n\r\nphysical memory가 프로세스들의 logical memory보다 훨씬 부족해서 page fault가 지나치게 많이 발생하는 것을 의미\r\n\r\n페이지를 swapping하는데 시간을 다 씀\r\n\r\ndegree of multiprogamming을 하면 cpu utilization이 높아지지만 너무 많은 프로세스를 한 번에 돌리면 thrashing발생 위험이 있다\r\n\r\n\r\n\r\n* 디맨드 페이징이 효과가 있는 이유\r\n  * 로컬리티가 있어서\r\n  * 같은 페이지가 참조될 확률이 높기때문에 page fault가 덜 일어남\r\n\r\n* 왜 thrashing이 발생?\r\n  * 각 프로세스들의 로컬리티 부분의 합이 total memory(physical) size보다 커짐\r\n  * 만약 global이 아니라 local allocation을 했다면 프로세스마다 각자 공간을 할당받기 때문에 좀 줄어들긴함 (근데 일반적으로 global 사용)\r\n\r\n\r\n\r\n쓰레싱을 어떻게 막을까?\r\n\r\n\r\n\r\n## Working-Set Model\r\n\r\nworking set : 로컬리티 영역 (각 프로세스마다 자주 사용되는 메모리 공간) , 주어진 시간동안 사용되는 페이지들의 집합\r\n\r\n* working set window : 페이지가 참조되는 시간을 나타냄\r\n  * ex) 10000 instruction \r\n\r\n* working set window가 커짐 : 로컬리티 영역도 커지고 working set size도 커짐\r\n* working set window가 작아짐 : 로컬리티도 작아짐 - 담을 수 있는 페이지 수가 작아짐\r\n\r\n\r\n\r\nD : 각 프로세스들의 working set size 합 \r\n\r\n* 이게 frame의 요구량이 됨\r\n* D > m(실제 메모리 크기)이면 Thrashing 발생\r\n* D > m인 상황이 발생하면 프로세스중 하나를 죽이거나 완전히 swap out시\r\n  켜서 공간을 확보한다\r\n"},{"excerpt":"Address Translation logical -> physical로 바꾸는 것 <p, d> p : page number (20bit) = 최대 2.5MB d : page offset (12bit) = 2^12 = 4KB 총 32bit internal fragmentation 이 발생하지만 크진않다 프로세스마다 페이지테이블 1개 프로세스마다 필요한 페…","fields":{"slug":"/1/"},"frontmatter":{"date":"June 11, 2022","title":"os 13-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Address Translation\r\n\r\nlogical -> physical로 바꾸는 것\r\n\r\n<p, d>\r\n\r\np : page number (20bit) = 최대 2.5MB\r\n\r\nd : page offset (12bit) = 2^12 = 4KB\r\n\r\n총 32bit\r\n\r\n> internal fragmentation 이 발생하지만 크진않다\r\n\r\n <br/>\r\n\r\n프로세스마다 페이지테이블 1개\r\n\r\n프로세스마다 필요한 페이지 개수가 다르기때문에 페이지 테이블 크기도 다름\r\n\r\n<br/>\r\n\r\n페이지 테이블들은 메인 메모리안에 있다.\r\n\r\nPCB에는 PTBR, PTLR이 있음\r\n\r\n* PTBR : 메인 메모리 안에 있는 프로세스의 페이지 테이블 시작점을 가리킴\r\n\r\n* PTLR : 페이지 테이블의 길이\r\n\r\n\r\n\r\n## TLB\r\n\r\n자주 사용하는 <페이지 넘버:프레임 넘버>를 저장해서 MMU에 바로 전달\r\n\r\nTLB를 통해서 메인 메모리의 페이지 테이블에 갈 필요없이 메모리 access가능 \r\n\r\n\r\n\r\nTLB에는 이전 프로세스가 사용하던 p:f가 저장되어있음\r\n\r\n* 이전 프로세스의 것은 다 지원주든지\r\n* valid bit을 추가할 것인지 : 0이면 무의미한 번호\r\n\r\nvalid bit(ASIDs) : 유의미한 TLB정보인가\r\n\r\n1. load/store instruction \r\n2. tlb search\r\n   1. tlb hit => mmu translation => physical memory access\r\n   2. tlb miss => mmu에서 ptbr을 가지고 page table에서 원하는 page number에 대한 frame번호를 읽어옴 => translation => physical mem access\r\n\r\n\r\n\r\n페이지 테이블은 페이지 넘버에 대한 프레임 넘버를 기본적으로 가지고 있다\r\n\r\n* 추가적으로 read-only등을 나타내는 protection bit을 가지고 있을수도 있다 (segmentation과 함께 사용 가능. 세그먼트별로 서로 다른 기능 제공)\r\n\r\n\r\n\r\n페이지의 길이를 PTLR로 표시할 수도 있지만 어떤 시스템에서는 무조건 0~2^20-1까지 전부 가져갈 수 있게한다.\r\n\r\n* 페이지 테이블내에 사용하지않는 페이지가 있을수도있음 - valid bit으로 사용여부를 알려줌\r\n\r\n* 실질적으로 쓰이지않는 6, 7번 페이지\r\n\r\n\r\n\r\n## Shared Pages\r\n\r\n페이지 테이블에 있는 수는 실제 frame번호들\r\n\r\n페이지 테이블을 같은걸 지정해놓으면 페이지 공유 가능.\r\n\r\n물리적으로 같은 주소를 가리킴\r\n\r\n32bit주소 \r\n\r\n주소는 0 ~ 2^32-1까지의 수로 표현 가능\r\n\r\npage(p) 는 0 ~ 2^20-1개 생김\r\n\r\n페이지 테이블은 frame번호를 기록\r\n\r\n* frame(f) 번호 : 20bit\r\n\r\npage table은 250MB인데 > 하나의 페이지가 4KB\r\n\r\n* 페이지 테이블이 여러 개의 페이지에 저장된다는걸 의미\r\n* PTBR하나로만 페이지 테이블을 가리키기 쉽지않음\r\n* hierarchical page table을 통해 해결\r\n\r\n\r\n\r\n"},{"excerpt":"Hierarchical Page Tables 페이지 테이블이 여러개 (ptbr이 여러개) outer page table : main page table의 시작점을 관리 (main) page table p1 : outer page table에서 어떤 인덱스를 검색할지 1024개의 entry  각 엔트리가 4B일 때 전체 4KB 온전히 하나의 프레임에 들어갈…","fields":{"slug":"/2/"},"frontmatter":{"date":"June 11, 2022","title":"os 13-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Hierarchical Page Tables\r\n\r\n페이지 테이블이 여러개 (ptbr이 여러개)\r\n\r\n* outer page table : main page table의 시작점을 관리\r\n* (main) page table\r\n\r\np1 : outer page table에서 어떤 인덱스를 검색할지\r\n\r\n* 1024개의 entry \r\n* 각 엔트리가 4B일 때 전체 4KB\r\n* 온전히 하나의 프레임에 들어갈 수 있음\r\n\r\np2 : 실제 frame이 있는 위치\r\n\r\n* 1024개의 entry\r\n\r\nd : 오프셋. 실제 frame이 있는 위치에서 오프셋만큼 건너 뛴 곳에 찾고자하는 리소스가 있음\r\n\r\n\r\n\r\n* PTBR -> outer page table의 시작주소를 가리킴 \r\n\r\n> PTBR -> outer page table -> page table -> physical memory\r\n\r\n\r\n\r\n> 계층화 구조라고 TLB까지 다단계가 되진않음\r\n\r\n\r\n\r\n## Intel 32 and 64-bit Architectures\r\n\r\n실제 사용 예시를 봐보자!\r\n\r\n### IA-32\r\n\r\n인텔의 32bit 구조\r\n\r\n* 세그멘테이션 한 번 하고 페이징 한 번 하고\r\n\r\n  \r\n\r\n`segmentation unit`이 또 다른 logical address인 linear address를 만듦\r\n\r\n\r\n\r\n* 하나의 프로세스당 최대 16K개의 세그먼트로 나눌 수 있다.\r\n  * 16K = 2^10 x 2^4 = 14bit\r\n\r\n* 각각의 세그먼트는 최대 4GB이다.\r\n  * 2^2 x (2^10)^3 = 32bit\r\n\r\n세그먼트를 크게 두 분류로 나눔\r\n\r\n* LDT (local descriptor table) - 8K\r\n  * private process\r\n  * 다른 프로세스와 공유하지않는 공간\r\n* GDT (global descriptor table) - 8K\r\n  * 공유 가능\r\n\r\n\r\n\r\n![](./ia-32.png)\r\n\r\nlogical address = (selector, offset)\r\n\r\nselector는 16bit이다 (segment를 표현)\r\n\r\n* 14bit + protection bit(2)\r\n\r\noffset 은 32bit. \r\n\r\n로지컬 어드레스는 총 48bit\r\n\r\n\r\n\r\n* 셀렉터를 보고 descriptor테이블을 찾음\r\n  * g는 GDT인지 LDT인지\r\n  * descriptor table에서 s만큼 떨어진 segment descriptor를 찾음 \r\n  * 찾은 segment와 offset을 더해서 32bit linear address를 만듦\r\n\r\n* linear address를 가지고 페이징을 한다\r\n  * Hierarchical paging과 동일\r\n* Page directory\r\n  * page table들의 시작주소와 4MB 페이지의 시작 주소를 모아둠\r\n  * 인텔 32에서는 4KB뿐만아니라 4MB 페이지도 지원\r\n  * 모두 작은 사이즈로 하면 페이지 테이블의 사이즈가 매우 커짐\r\n  * 큰 페이지에 저장해야할 경우도 있어서 4MB도 지원...\r\n  * 4MB에서는 \r\n    * P1(page num), d (page offset)\r\n\r\n\r\n\r\n64bit은?\r\n\r\n계층이 더 나눠짐\r\n\r\nP1, P2, P3, P4, P5 ...\r\n\r\n\r\n\r\n## Virtual Memory\r\n\r\n로지컬메모리를 virtual memory라고 부름\r\n\r\nvirtual memory가 왜 생겨났나?\r\n\r\n> 어떤 프로그램이 실행되면 프로그램에 필요한 코드가 전부 메모리에 올라옴\r\n>\r\n> 비효율적\r\n>\r\n> 전부 올라와야할 필요가 있을까...?\r\n>\r\n> Error code, unusual routines\r\n>\r\n> * Partially-loaded 하자!\r\n>   * 피지컬 메모리 limit가 줄어든다\r\n>   * 더 많은 프로세스가 동시에 메모리를 사용가능\r\n>   * degree of multiprogramming이 올라감\r\n>   * response time증가하지않음\r\n\r\n\r\n\r\n 프로그램의 부분만 메모리에 올리자\r\n\r\n* logical addr 이 physical addr보다 커져도 됨\r\n\r\n\r\n\r\n### Virtual address space\r\n\r\n> 기존 방법은 처음에 다 올려놓고 필요없는걸 뺐다면 이번에는 필요할 때 올린다.  요구할 때 페이징 수행\r\n\r\n차이 : \r\n\r\n한 번도 요구된적이 없는거라 physical memory에 없을수도있음\r\n\r\n그럴땐 HDD에 접근해서 가져와야함\r\n\r\n* virtual address space는 0번부터 max까지 있음\r\n  * 상위에는 stack 하위에는 code\r\n\r\n\r\n\r\n## Demand Paging\r\n\r\nvirtual memory의 핵심적인 차이점!\r\n\r\n페이지를 필요할 때 가져다놓자!\r\n\r\n> 불필요한 I/O가 줄어든다\r\n>\r\n> 메인 메모리를 더 적게 차지\r\n\r\n스와핑을 하는 페이징 시스템과 유사\r\n\r\n\r\n\r\n"},{"excerpt":"Memory System registers - (main) -cache - Memory - Storage(disk) Registers 프로세스에서 사용하는 data Memory DRAM 프로세스의 정보(state, 코드) Storage SSD, HDD 프로그램 코드, 파일 영구적으로 유지. 전원이 꺼져도 유지. 프로그램 관련 (메모리와 레지스터는 전원이 …","fields":{"slug":"/1/"},"frontmatter":{"date":"June 11, 2022","title":"os 12-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Memory System\r\n\r\nregisters - (main) -cache - Memory - Storage(disk)\r\n\r\n> Registers\r\n>\r\n> - 프로세스에서 사용하는 data\r\n>\r\n> Memory\r\n>\r\n> - DRAM\r\n> - 프로세스의 정보(state, 코드)\r\n>\r\n> Storage\r\n>\r\n> - SSD, HDD\r\n> - 프로그램 코드, 파일\r\n> - 영구적으로 유지. 전원이 꺼져도 유지. 프로그램 관련 (메모리와 레지스터는 전원이 켜져야함. 프로세스 관련이라고 보면 됨)\r\n\r\n- 프로그램이 수행될 때는 disk에서 memory로 가져와야함\r\n\r\n- 메인 메모리와 레지스터는 CPU가 직접 접근할 수 있는 유일한 공간\r\n- 메모리에는 주소와, 주소를 읽고 주소에 쓰는 요청만 감\r\n- 레지스터는 one CPU clock안에 접근할 수 있다\r\n- memory는 many cycle 을 소요. stall을 유발함\r\n  - stall - 기다리는거,\r\n  - stall등을 최소화하기위해 Cache등장\r\n- Memory의 Protection 필요\r\n\r\n\r\n\r\n## Hardware Address Protection\r\n\r\n메모리안에서 A프로세스에게 할당된 공간을 B 프로세스가 건드리지않게 Protection이 필요함\r\n\r\n- base와 limit을 가지고 해결\r\n\r\nCPU는 address를 받으면 base\r\n\r\n\r\n\r\n### Address Binding\r\n\r\n- 소스코드에서는 address가 symbolic(변수명)하게 나타남 (주소를 직접 명시하지않음) int a;\r\n\r\n- 컴파일 단계에서 relocatable address부여\r\n  - 14bytes from beginning of this module\r\n- 링커 단계에서 absolute address부여 (logical address : cpu에서 바라보는 주소)\r\n  - 74014\r\n\r\n\r\n\r\n### Logical vs Physical Address\r\n\r\n- Logical address\r\n  - CPU에 의해서 생성. virtual address라고도 함\r\n- Physical address\r\n  - physical = logical + base\r\n  - 실제 메모리의 물리적 주소\r\n\r\n\r\n\r\n### MMU (Memory-Management Unit)\r\n\r\n- logical에서 physical로 매핑시켜주는 하드웨어 디바이스\r\n- OS가 MMU의 relocation register에 값(base)을 써줘야함\r\n\r\n메모리 구역을 분리하는건 알겠는데 어떤 프로세스를 어떤 구역에 둬야할까?\r\n\r\n\r\n\r\n## Contiguous Memory Allocation\r\n\r\n초기 - 연속적 할당\r\n\r\n메인 메모리는 이 안에서 두 개의 파티션으로 나뉨\r\n\r\n![](./conti-mem-all.png)\r\n\r\n- low : os\r\n- 나머지 공간은 User Process가 통으로 들어감\r\n- high\r\n\r\n- physical 주소 변환에 복잡함이 없음\r\n\r\n![](./conti-allo.png)\r\n\r\nprocess A는 0부터 알파까지\r\n\r\n알파 = limit\r\n\r\n- Base = physical address의 smallest value\r\n- Limit = logical address의 range\r\n- os가 limit과 relocation에 값을 써줌(dispatcher가 cpu 스케줄링할 때)\r\n\r\n\r\n\r\n### multiple-partition allocation\r\n\r\n메모리에 몇 개의 프로그램이 올라갈 수 있는가\r\n\r\n파티션 크기 자체는 가변적 : 프로세스마다 limit이 다를 수 있음\r\n\r\nHole : 메모리안의 비어진 공간\r\n\r\n- 각 프로세스마다 base, limit 관리\r\n- 새 프로세스가 들어올 때 새 프로세스의 base와 limit을 정함\r\n- allocated P, free P (hole) 관리\r\n\r\n\r\n\r\n### First-fit\r\n\r\nallocate할 수 있는 첫 번째 hole에 할당\r\n\r\n빈 홀 검색은 처음부터 할 수도 있고 바로 이전 탐색 이후부터 할 수도 있다\r\n\r\n빠름\r\n\r\n\r\n\r\n### Best-fit\r\n\r\nallocate할 수 있는 가장 small한 hole\r\n\r\n공간효율\r\n\r\n\r\n\r\n### Worst-fit\r\n\r\n가장 큰 hole에\r\n\r\n가장 큰 공간이기때문에 할당해주고 남은 공간도 클 것이다 - fragmentation을 낮춤\r\n\r\n그러나 성능, 효율이 떨어짐\r\n\r\n\r\n\r\n### Fragmentation\r\n\r\n- External fragmentation\r\n  - 전체 메모리 스페이스 request한 것을 다 담을 수 있을만큼 있으나 연속적이지 않아서 문제\r\n  - 1크기의 홀이 10개, request는 5크기 요청. 공간은 있으나 연속적이지 않아서 담을 수 없음\r\n  - 50-percent rule : fitst-fit으로 한 분석 결과 0.5의 블록은 fragmentation으로 사용불가능\r\n- Internal fragmentation\r\n  - 18648B의 여유공간이 있는데 18646B request가 옴. 2B가 남음 (사실상 못쓰임)\r\n  - 저 2B를 홀로 관리해줘야함\r\n  - 이걸 막기위해 그냥 18648B를 할당해버림\r\n  - 실질적으로 2B는 사용안하는 공간\r\n"},{"excerpt":"Contiguous Allocation Compaction hole들을 모음 external fragmentation 해결 문제 : I/O를 발생시킴 큰 메모리 카피를 일으킴 - 오버헤드 지금은 쓰이지않음 Swapping fragmentation을 해결한건 아니고 여유공간 자체를 늘려줌 Backing store : 스왑되는 공간. 기존에 있는 프로세스 메…","fields":{"slug":"/2/"},"frontmatter":{"date":"June 11, 2022","title":"os 12-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Contiguous Allocation\r\n\r\n### Compaction\r\n\r\nhole들을 모음\r\n\r\nexternal fragmentation 해결\r\n\r\n문제 : I/O를 발생시킴\r\n\r\n큰 메모리 카피를 일으킴 - 오버헤드\r\n\r\n지금은 쓰이지않음\r\n\r\n### Swapping\r\n\r\nfragmentation을 해결한건 아니고 여유공간 자체를 늘려줌\r\n\r\nBacking store : 스왑되는 공간. 기존에 있는 프로세스 메모리 공간 하나를 디스크로 백업해놓음\r\n\r\n- 백업을 시키고 free.\r\n- free한 공간에 새 프로세스 할당\r\n\r\n근데 오버헤드는 compaction과 비슷;\r\n\r\n- 데이터를 빼오고 이동시키는 시간이 길다\r\n- 그러나 여유공간이 많은 것 처럼 보여줌 Degree of Multi programming을 늘림\r\n- but, disk에 있는 애들을 위한 ready queue를 추가로 관리해줘야함\r\n\r\n### Context Switch Time Including Swapping\r\n\r\n컨텍스트 스위칭을 할 때 Swapping을 같이하자!\r\n\r\n- 디스크에 옮겨놓는 일은 시간이 오래걸림\r\n- Context switch time이 커질 수 있다\r\n- Standard swapping은 쓰이지 않음(이후 Paging과 함께 쓰이긴 함)\r\n- 모바일 os에서는 swap이 사용되지않음\r\n  - 메모리에 있는 data를 디스크로 옮김\r\n  - 모바일은 디스크가 없음\r\n  - Flash memory based임\r\n  - 플래시 메모리는 write cycles가 제한되어있음 ( 같은 공간에 쓰기 횟수가 제한)\r\n  - 모바일 os에서는 refresh : 백그라운드에 있는 애들의 정보를 계속 유지할 수 없음. 최소한의 정보만 저장해두고 free시킴\r\n\r\n## Contiguous Allocation의 문제\r\n\r\n모든 데이터를 통째로 관리\r\n\r\n코드는 여러 프로세스가 공유될 수 있음\r\n\r\n한 번 만들어진 코드는 변하지않음. read-only\r\n\r\n그러나 데이터, stack, heap섹션은 일반적으로 공유되지않음- read-write\r\n\r\n즉, 특성이 다른 영역들이 존재\r\n\r\n> 프로세스의 모든 공간(stack, heap, data, code)를 전부 이어붙여 저장하지말고 따로따로 저장할 순 없을까?\r\n>\r\n> -> Segmentation\r\n\r\n\r\n\r\n## Segmentation\r\n\r\n메모리 area를 여러 개의 area로 나누자\r\n\r\n- segment마다 개별적으로 base와 limit 값을 가지고있어야함\r\n  - 두 개의 protection bit가 필요(read write가 가능한지 표시하는)\r\n  - ex) 10이면 read만 가능\r\n\r\nMMU가 할 일\r\n\r\n1. 지금 요청이 온게 어느 seg에 속하는 것인가\r\n2. 해당 seg의 limit을 검사\r\n3. 해당 seg의 base를 더함\r\n\r\n어느 seg에 속하는지 어떻게 알 수 있을까?\r\n\r\n- logical address의 상위 bit을 세그먼트를 구분하는데 쓰자\r\n- 인스트럭션 자체에서 구분을 해보자\r\n  - ex) stack에 푸쉬하는 인스트럭션이니 stack에 가야겠구나!\r\n  - 인스트럭션마다 명확하게 나뉘는게 아니라 어려움\r\n\r\n세그먼트별로 리밋과 베이스를 어떻게 관리할까?\r\n\r\nsegment table\r\n\r\n## Segmentation Architecture\r\n\r\n- 로지컬address에서 바라보는 주소를 다음과 같이 만듦\r\n\r\n  - <segment-number, offset>\r\n  - 상위 bit : 어떤 seg에 속하는지\r\n  - 하위 bit : seg안에서의 주소\r\n\r\n- Segment table\r\n\r\n  - 각각의 seg에 할당된 base와 limit을 관리\r\n  - s : seg의 번호\r\n  - d : = offset, seg안에서의 addr\r\n\r\n![](../../../../../../inha-image/segtable.png)\r\n\r\nbase : physical addr의 starting을 담고있음\r\n\r\nlimit : 해당 seg의 length\r\n\r\n레지스터 두 개가 필요\r\n\r\n- Segment-table base register(STBR)\r\n  - physical memory안의 세그먼트 테이블의 실제 위치\r\n  - seg-table의 base\r\n- Segment-table length register(STLR)\r\n  - 해당 seg table의 length를 구하는 테이블\r\n  - seg-table의 limit\r\n\r\nProcess의 수 x segment의 수만큼 레지스터가 필요함\r\n\r\n- high overhead\r\n- 레지스터로 관리하긴 힘들고 메모리 안에 위치시킴\r\n- 어떤 addr에 request가 들어오면 그 addr이 속하는 seg table정보를 읽어옴\r\n- seg table의 정보를 읽어보면 그걸 바탕으로 limit검사하고 base를 더함\r\n- 실제 physical addr로 변환\r\n- 세그먼트 테이블의 정보도 메모리에 있어서 읽어와야함. 메모리에 STBR, STLR 저장 (세그먼트 테이블의 base와 limit) : 한 번 요청하면 두 번 읽어와야함\r\n- 메모리 access 횟수가 두 배가 됨\r\n\r\n각 seg마다 base와 limit이 다름.\r\n\r\n여러 seg로 나눠도 여전히 큼\r\n\r\n큰 애들을 메모리에 할당\r\n\r\n그런 상태에서 할당과 해제를 반복하면 hole이 불균형하게 생기고 못쓰는 hole이 많이 생김\r\n\r\n여전히 external fragmentation 많이 생김\r\n\r\n그래서 나온게 Paging\r\n\r\n## Paging\r\n\r\nModern OS\r\n\r\n> segmentation은 여전히 external fragmentation이 심함\r\n\r\n메모리 fragmentation을 줄이자\r\n\r\n스와핑을 좀 더 효율적으로\r\n\r\n<br/>\r\n\r\n메모리 공간을 균등한 사이즈로 나눔\r\n\r\n- fragmentation이 발생하는 이유는 프로세스가 사용하는 메모리 공간이 서로 불균형하니까 작은 애들이 free, allocation을 반복하다보면 큰 공간이 점점 작게 나눠지고 홀이 불균등하게 생김\r\n- 큰 요청이 들어왔을때 들어갈 공간이 없음\r\n- 페이징은 모든 공간을 고정된 사이즈의 frame으로 나눔\r\n- 프레임의 크기는 2^n으로 나눔 (os에서는 기본적으로 4KB)\r\n- 4KB는 하드디스크의 블록 사이즈. 한 번에 단위별로 가져오게 하려고 맞춤\r\n\r\n<br/>\r\n\r\n- 로지컬 addr을 똑같은 사이즈로 자름 ( page라고 부름 )\r\n- segmentation하듯이 할당함. page별로 frame에 매핑해줌.\r\n\r\n  - ex) 15KB짜리 프로그램을 4KB인 4개의 프레임에 할당\r\n\r\n- 사용 가능한 free frame들을 전부 체크해야함\r\n- page -> frame의 정보를 관리하는 정보가 커짐...\r\n- 여전히 internal fragmentation존재\r\n  - 15KB프로그램에 16KB할당\r\n"},{"excerpt":"버퍼 오버 플로우 방어 방법? Exploit Protection DEP (Data Execution Prevention) : 데이터 실행 방지 (데이터 영역에 있는건 실행시키지 않겠다) ASLR CFG (Control Flow Guard) : 제어흐름보호 DEP (Data Execution Prevention) 하드웨어에서도 지원 메모리에 이상한 일이 벌…","fields":{"slug":"/1/"},"frontmatter":{"date":"June 10, 2022","title":"12-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n버퍼 오버 플로우 방어 방법?\r\n\r\n## Exploit Protection\r\n\r\nDEP (Data Execution Prevention) : 데이터 실행 방지 (데이터 영역에 있는건 실행시키지 않겠다)\r\n\r\nASLR\r\n\r\nCFG (Control Flow Guard) : 제어흐름보호\r\n\r\n### DEP (Data Execution Prevention)\r\n\r\n하드웨어에서도 지원\r\n\r\n메모리에 이상한 일이 벌어지는지 체크\r\n\r\nwmic\r\n\r\n- 2- optin : 디폴트값 - 검사대상을 내가 지정 (윈도우시스템즈, 중요기능에만 적용되어있음)\r\n- 3-optout : 모든 프로세스에 dep적용 - 안하고싶은애는 따로 설정\r\n- 1-alwayson : 항상키기\r\n- 0-alwaysout\r\n\r\n### ASLR (Address space layout randomization)\r\n\r\n주소 공간의 배치를 랜덤화함\r\n\r\n- 메모리를 분배시켜서 메모리를 공격하는 것을 막아줌\r\n- 공격자가 메모리 상에 실행가능한 특정 자리쪽으로 튀는 것을 막기위해서 aslr적용\r\n- 프로세스가 사용하는 중요한 영역의 랜덤으로 바꿈\r\n- 스택 위치, 힙 위치, 동적 라이브러리 위치 다 바꿈\r\n- 이걸 깨는 공격들이 또 나옴\r\n\r\n### CFG (Control Flow Guard)\r\n\r\n방금 나온 DEP, ASLR을 포함, 확장한 개념\r\n\r\n최근에 나옴\r\n\r\nOS만 가지고 되는게 아니고 Visual studio랑 협업해야함\r\n\r\n- VS 2015에 중간중간 체크하는 코드가 들어가있음\r\n\r\n컴파일하고 런타임서포트를 합침\r\n\r\n컴파일은 컴파일러가 런타임 서포트는 윈도우즈 커널이 함\r\n\r\n호출하는 instruction의 위치를 포인터로 받음 - 이런걸 포함하고 있는 소스코드가 있다면 컴파일 타임에 확인함,\r\n\r\n컴파일러는 간단한 체크 코드를 집어넣음 : Instrumentaion\r\n\r\nindirect call, 함수가 콜 됐을때 콜의 대상이 될 수 있는 위치를 다 적어둠 - 유효한 목표 주소점을 가지고있음\r\n\r\n실제 실행시킬 때 위에서 컴파일러가 적어둔 곳으로 간다고 하면 okay, 컴파일러가 적어둔 곳이 아니면 이상함을 감지 - isValid target인가?\r\n\r\n#### Instrumentation\r\n\r\n> 동적으로 실행시키는 상황에서 분석\r\n\r\n위에서 한거는 Source instrumentation\r\n\r\n- 컴파일러가 소스 단계에서 뭔갈 집어넣음\r\n\r\nBinary instrumentaion\r\n\r\n- source를 안가지고있고 (컴파일러가 아닌 그냥 커널)\r\n- 바이너리 코드(기계어) 상에서 이것 저것 집어넣음\r\n  - intel Pin - 툴이라기보단 가상환경에 가까운데 컴퓨터 아키텍처를 분석하는 용도로 쓰였음. 메모리 분석하는 용도로도 쓰이는중\r\n  - Valgrind - 메모리 디버깅용으로 나온 툴. 디폴트 : Memcheck\r\n\r\nex\r\n\r\n동적할당해놓고 free 안해둠 - 메모리안에 갈비지값 생김 - Memcheck가 이런거 체크해줌\r\n\r\nreturn 0; 하는 순간 400byte의 공간을 여전히 사용하고있음을 알려줌\r\n\r\n## Format String Attack\r\n\r\nFormat string에서 %사용 가능 - 길이가 가변적인 파라미터를 받을 수 있음.\r\n\r\nex)\r\n\r\nprint(argv[1])하면\r\n\r\nprint(Hello World %p %p %p ...)가 되어버림\r\n\r\n즉 %p의 개수만큼 인자가 있어야함. (%p는 정수값출력-보통 포인트값을 출력해줌 16진수8자리)\r\n\r\n스택 주변에 있는 값들을 그냥 프린트해버림 - 주변의 스택값 출력 : 스택의 일부영역 노출\r\n\r\n보통 폴맷스트링어택과 버퍼오버플로우가 같이 쓰임\r\n\r\n## Security Systems\r\n\r\n방어하기 위해 보통 사용하는 시스템\r\n\r\n보안 기능을 제공하는 하드웨어 기능\r\n\r\n방화벽\r\n\r\nIDS, IPS\r\n\r\n### Hardware Support for Security\r\n\r\n#### TPM (Trusted Platform Module)\r\n\r\ncoprocessor - cpu를 도와주는 보조장치\r\n\r\n암호와 관련된 기능을 도와줌\r\n\r\n대부분의 상용화된 pc, 서버, 스마트폰에 다 들어있음\r\n\r\n하드웨어 보안 관련\r\n\r\n메인 기능\r\n\r\n- 암호 키를 생성하거나 저장\r\n- 디바이스 자체를 인증, 식별 (전자서명으로 확인)\r\n- 플랫폼 무결성 확인 (secure boot같은거 사용)\r\n  - 커널코드를 H함수로 돌리고 사인(개인키) - 서명\r\n  - OS는 저 커널이 제대로 된 커널인지 확인하고 어플리케이션을 실행해야함\r\n  - 덮어쓰기가 안되는 영역(ROM)에 서명된 결과와 공개키를 저장해둠\r\n  - 공개키를 가지고 인증 확인\r\n- 사용자가 쓰고있는 데이터 중 중요한 데이터를 저장 -NVRAM(비휘발성램) - 안전한 플래시메모리 영역\r\n- 2.0버전을 주로 씀\r\n\r\n#### TEE (Trusted Execution Environment)\r\n\r\n신뢰 실행 환경\r\n\r\ncpu안에 있는 논리적인 영역\r\n\r\ncpu안에 구현된 기능\r\n\r\ncpu안의 영역을 분리해서 특정 부분에 키를 할당에 놓음\r\n\r\nnormal world/ secure world\r\n\r\n시큐어 월드에 있는 프로세스 상태나 데이터를 노멀월드에서는 볼 수 없음. 서로 다른 cpu처럼 작동\r\n\r\n무결성, 기밀성\r\n\r\n부트스트랩 코드 같은 특정 코드에 한정됨\r\n\r\nremote attenstation : 외부에서 cpu가 잘 동작하고 있는지 확인 가능\r\n\r\nex) ARMCPU, SGX\r\n\r\n#### HSM(Hardware Security Module)\r\n\r\n밖에서 물리적으로 조작이 불가능(Tamper-resistant)\r\n\r\n카드형태로 꽂던가 ...\r\n\r\n값이 비쌈\r\n\r\n앞에 애들보다 고성능\r\n\r\n어떤 연산을 안전하게 수행해줌\r\n\r\n## Firewall\r\n\r\n시스템 보호\r\n\r\n로컬시스템보호, 시스템들이 연결된 네트워크 보호, 외부, 내부적 위험에서 보호\r\n\r\n- 양방향 네트워크 서비스, 접근 제어\r\n\r\n  - 바깥에서 오는 트래픽 필터링\r\n  - 프록시 소프트웨어\r\n  - 서버 자체로 작동하기도\r\n\r\n- 사용자 제어\r\n- 근접 제어\r\n- 로그를 남기고 검사\r\n\r\n### Firewall Types\r\n\r\n대표적 종류 두 개\r\n\r\n#### Packet filter\r\n\r\n패킷을 필터링\r\n\r\naccess control list를 유지하면서 소스, 데스트의 IP주소, port, protocol을 필터\r\n\r\ntcp, ip 네트워크 트랜스포트 계층에서 패킷의 모양만 가지고 함. 페이로드(내용)은 관심없음\r\n\r\n#### Application Firewall\r\n\r\n페이로드도 봄\r\n\r\n프록시 형태로 제공되는 경우가 많음\r\n\r\nApplication level gateway라고 부르기도 함\r\n\r\n프록시가 외부 서버에서 데이터 받고 정상적이면 로컬 네트워크의 pc에 전달. 정상적이지 않으면 전달하지않음\r\n\r\nWAF에 따라 다르지만 DPI를 하는 경우도 있음\r\n\r\n- DPI (Deep Packet Inspection)\r\n  - 패킷의 헤더뿐만아니라 내용까지 봄\r\n  - 암호화된 트래픽은 볼 수 없음\r\n\r\n## IDS\r\n\r\n침입자를 색출해내는게 목표\r\n\r\n공격자의 행동은 정상적인 유저의 행동과 다를것이다라고 가정\r\n\r\n오용탐지 (Misuse detection)\r\n\r\n- rule or signature기반\r\n- 알려져있는 공격을 규칙으로 사용\r\n- 공격의 자취를 저장\r\n- 패킷을 검사하다가 저장해둔 자취와 비슷하면 공격자라고 판단\r\n- 정확도는 높지만 제로데이와 같이 알려지지않은 공격에 취약\r\n\r\n이상탐지\r\n\r\n- 평소에 정상적인 시스템의 상대를 학습시킴\r\n- 머신러닝이나 통계기술이 많이 사용됨\r\n- 학습시킨 시스템에서 벗어난 행동을 하면 공격자라고 판단\r\n\r\n구현되는 위치로 구분\r\n\r\nHost-based IDS\r\n\r\n- 컴퓨터안에 os하고 같이 설치\r\n\r\nNetwork-based IDS\r\n\r\n- 컴퓨터들은 따로 따로 있는데 그 네트워크에 별도로 설치\r\n- 여러대의 컴퓨터를 동시에 확인 가능\r\n- IP 주소가 없어서 공격하기 어려움\r\n\r\n## IPS\r\n\r\nIDS보다 발전\r\n\r\nIDS : 공격 탐지, 그러나 어떻게 해결할 것인지는 애매함\r\n\r\nIPS : 발전된 형태의 아이디에스, 네트워크를 이상한 행동을 하는지 지속적으로 모니터링을 하면서 막기위해 어떤 행동(reporting, blocking, dropping)을 취한다\r\n\r\n최근에는 시스템이 발전하면서 IPS = IDS + Firewall이라고 부르기도 함 (경계가 애매)\r\n\r\nex) snort : opensource\r\n\r\nPCRE : reqular expression : \\s+, \\n 0x22... 이런애들. 규칙을 정해놓고 규칙에 맞는지 확인\r\n\r\n"},{"excerpt":"Message Authentication Code 맥의 요구조건, 기능 Masquerade - 상대인척 속임 메시지 변조, 없는 메시지 생성, 메시지 순서 변경, 시간값 변조등을 막기위해 맥을 사용 인증가 무결성을 동시에 제공하는 것이 MAC! 크게 보면 입력은 두 가지 존재 message와 secret key 보통의 암호화L와 비슷 아웃풋이 암호문이면 …","fields":{"slug":"/2/"},"frontmatter":{"date":"June 10, 2022","title":"12-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Message Authentication Code\r\n\r\n맥의 요구조건, 기능\r\n\r\nMasquerade - 상대인척 속임\r\n\r\n메시지 변조, 없는 메시지 생성, 메시지 순서 변경, 시간값 변조등을 막기위해 맥을 사용\r\n\r\n인증가 무결성을 동시에 제공하는 것이 MAC!\r\n\r\n> 크게 보면 입력은 두 가지 존재\r\n>\r\n> message와 secret key\r\n>\r\n> 보통의 암호화L와 비슷\r\n>\r\n> 아웃풋이 암호문이면 암호화, 무결성을 체크하기위한 코드값이 나오면 맥\r\n>\r\n> 인증을 위해 뒤에 덧붙이는 값을 authenticator라고함\r\n\r\n정해진 길이의 인증자(인증 태그) 생성\r\n\r\nMac = keyed hash\r\n\r\n![](./three-example.png)\r\n\r\nC는 블록 싸이퍼의 CBC모드일수도 해시함수일수도 있음\r\n\r\n## HMAC\r\n\r\n해시기반으로 만든 맥\r\n\r\n안전성에서 큰 차이가 없다면 DES말고 더 빠른 해시함수쓰자~\r\n\r\nIP security - transport층에서 사용자 보호(TES) 그 아래의 네트워크 계층에서 가장 많이쓰이는 IP 프로토콜을 보호하는 표준 프로토콜\r\n\r\n니스트 표준\r\n\r\n### 절차\r\n\r\n- K를 블록으로 나눔\r\n  - 만약 K와 블록의 사이즈가 같다면 그냥 바로 함\r\n  - K가 더 크면 L byte string이 되도록 해시를 해줌. 나눴는데 L byte가 B에 비해 모자라면 0으로 채워줌 (B-byte가 되게)\r\n  - 더 작으면 0을 붙여서 B-byte가 되게 함\r\n- K0은 B와 크기가 같음. ipad와 xor\r\n\r\n  - ipad : 상수, 16진수로 36, 1바이트\r\n\r\n- text를 붙임\r\n  - text : MAC을 생성할 대상\r\n- 해시 돌림\r\n- K0과 opad xor\r\n  - opad : 5c라는 바이트 값을 쭉 반복한 값\r\n- 두 개를 붙이고\r\n- 붙인걸 또 해시\r\n\r\n\r\n\r\n## CMAC\r\n\r\ncbc 모드를 가지고 맥을 만들 수 있다\r\n\r\n- 그걸로 나온게 DAA\r\n\r\ncbc의 initial vector빠짐\r\n\r\n문제\r\n\r\n만약 K와 플레인텍스트 X를 넣는데 X가 한 블럭짜리라면\r\n\r\n- 공격자가 임의로 MAC을 만들어낼 수 있음\r\n- 두 블럭짜리 플레인텍스트를 만든다\r\n  - 첫번째 플레인텍스트 블록 : X\r\n  - 두 번째 : X xor T\r\n- cbc-mac 연산 돌리면 똑같이 T나옴\r\n\r\n이걸 해결한게 CMAC\r\n\r\n마지막(두 번째) 부분에 대한 CBC를 돌릴 때는 다른 키를 더 써서 xor을 한 번 더 시킴\r\n\r\n> M의 길이가 작아 패딩이 있는 블록이라면, (패딩 : 1하나빼고 다 0)\r\n>\r\n> K1이 아니라 K2라는 다른 키를 적용\r\n>\r\n> K1과 K2는 처음 입력받은 K를 가지고 유도\r\n\r\nK를 0만 있는 것과 암호화 (B byte string)\r\n\r\nL x X = L의 비트를 왼쪽으로 옮김\r\n\r\n\r\n\r\n## Authenticated Encryption\r\n\r\nconfidentiality와 authentication을 둘 다 제공\r\n\r\n하는 방법\r\n\r\n- Encryption 한 다음에 해시 : 안전성 보장 안됨\r\n- 인증(맥)후 암호화 : 앞에서 나옴\r\n- 암호 따로 인증 따로 등등...\r\n\r\n### CCM (Counter with CBC-MAC)\r\n\r\n카운터 모드 Encryption\r\n\r\n사실 CBC맥 안쓰고 CMAC사용\r\n\r\n인크립션과 맥을 따로따로 하고 붙임\r\n\r\nAES 암호 알고리즘 사용\r\n\r\n암호화와 맥에 같은 key를 쓰도록 되어있음\r\n\r\n세 가지 데이터 종류\r\n\r\n- 인증도 하면서 암호화도 해야하는 데이터 : 페이로드가 되는 데이터 블록\r\n  - ex) IP패킷. 페이로드 내용은 중요해서 암호화되어야하지만 IP 주소 정보같은건 암호화 되면 주소 못찾음;; 페이로드만 암호화 필요\r\n- 암호화할 필요는 없지만 인증이 필요 : associated data\r\n- replay 어택을 막기위해 매번 보낼때마다 바뀌는 값을 만들어줌(nonce)\r\n  - reply 어택 : 실제 사용자가 여러번보낸건지... 공격자가 복제해서 여러번 보낸건지..\r\n  - data가 같은데 nonce까지 같으면 비정상적인 메시지\r\n\r\n![](./ccm.png)\r\n\r\n인증\r\n\r\n세 가지 데이터를(nonce, ass.data, plaintext) CMAC을 돌려서 Tag를 얻음\r\n\r\n암호화\r\n\r\nplaintext에만 암호화 필요\r\n\r\n카운터사용\r\n\r\n막판에 인증과 암호화 아웃풋 합침(Tag xor MSB(Tlen))\r\n\r\n인증과 암호화를 독립적으로 적용, 완료후 합침\r\n\r\n- MSB 만약 CMAC에서 특정 길이 아웃풋을 준다면 MSB에서 most, 최상위비트부터 잘라서 전달\r\n\r\n### GCM (Galois Counter Mode)\r\n\r\nCCM은 병렬화가 안된다는 성능상의 문제가 존재(카운터모드는 병렬화 가능, CMAC은, CBC모드는 안됨. 앞에 값을 뒤에 전달.)\r\n\r\nGCM은 앞과 뒤의 연관 관계를 만들어주면서도 병렬화가 가능\r\n\r\n- CTR모드로 암호화\r\n\r\n- 암호문을 key material로 authenticator tag생성\r\n\r\n  - 암호화 이후 태그를 붙여주는 방식(갈루아필드사용)\r\n\r\n  > 근데 사실 맥만 만들수도있음. 카운터 모드 빼고 맥으로만 (GMAC)\r\n\r\n두 가지 모드 사용\r\n\r\n- GHASH - MAC용으로 사용, keyed hash function\r\n\r\n- 카운트 모드를 살짝 바꾼 GCTR - 연산 하나 증가할 때마다 하나씩 증가\r\n\r\n![](gcm.png)\r\n\r\n> H는 128bit의 암호문\r\n>\r\n> H를 GF(2^128)의 원소로 본다\r\n>\r\n> 플레인 텍스트인 X역시 원소로 봄\r\n>\r\n> (127차까지 가능한 다항식이 됨)\r\n>\r\n> CBC모드와의 차이 : 키를 사용하는 Block Cipher Encryption 대신에 k를 사용해 생성한 H(keyed hash)를 곱하는걸로 바뀜\r\n\r\n병렬이 안되는 것 처럼 보이지만 병렬이 가능(H를 곱하므로 인수분해처럼 빼서 병렬 가능)\r\n\r\nGCTR\r\n\r\n마지막 블록은 정해진 블록 사이즈 크기보다 작을 수 있기에 MSB 적용\r\n\r\n전체적으로 암호화 -> 인증 구조\r\n\r\n## GCM and intel CPU\r\n\r\n빨리 돌리기위해 연산을 하드웨어로 구현해서 제공하고 있음\r\n\r\n최근에 나오는 cpu는 PCLMULQDQ라는 instruction을 제공한다 - 캐리를 위로 올리지않는 곱셈- 두개의 64 오퍼랜드를 받아서 캐리없이 연산해줌 - binary field 연산\r\n\r\n1. 타원곡산연산 점의 계산에서 바이너리 필드를 사용할 때 사용 - 그러나 최근 바이너리필드를 사용하는 타원곡선의 약점 발견..., 프라임필드를 쓰는 추세\r\n2. GCM Mode : GCM 빨리 돌리기 가능\r\n\r\n## 암호 모듈 검증 제도\r\n\r\nKCMVP라고 부름\r\n\r\n> 공공기관에 납품되는 암호품은 여기서 검사받고 검증되어 들여져야함\r\n\r\nnis.go.kr에서 자세히 확용 가능\r\n\r\n블록암호 : AES없음(우리나라)\r\n\r\nLSH - 국산 해시 함수\r\n"},{"excerpt":"bash에서 vi/vim하려는데 \"bash: vi: command not found\" vi명령어 없다고 할 때 1차 시도 \n2차 시도","fields":{"slug":"/bash/"},"frontmatter":{"date":"June 09, 2022","title":"bash: vi: command not found","tags":["bash"]},"rawMarkdownBody":"\r\nbash에서 vi/vim하려는데 \"bash: vi: command not found\" vi명령어 없다고 할 때\r\n\r\n1차 시도\r\n\r\n```bash\r\nsudo apt-get install vim\r\n```\r\n\r\n<br/>\r\n결과 : E: Unable to locate package vim\r\n\r\n<br/><br/>\r\n2차 시도\r\n\r\n```bash\r\napt-get update && apt-get install apt-file -y && apt-file update && apt-get install vim -y\r\n```\r\n\r\n<br/>\r\napt-get을 업데이트하고 했더니 잘된다!\r\n"},{"excerpt":"공개키암호 응용 방식 Encrption & Decryption 메시지암호화 Digital Signature 전자서명 Key exchange 암호화에 사용되는 세션키 전달 용도 하이브리드 방식 - key encapsulation src가 메시지 암호화하는것처럼 세션키를 암호화해서 보내면 dest가 세션키 확인 가능 Discrete logarithm 디스크리…","fields":{"slug":"/other-public-key/"},"frontmatter":{"date":"June 06, 2022","title":"10-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## 공개키암호 응용 방식\r\n\r\n* Encrption & Decryption\r\n\r\n  * 메시지암호화\r\n\r\n* Digital Signature\r\n\r\n  * 전자서명\r\n\r\n* Key exchange\r\n\r\n  * 암호화에 사용되는 세션키 전달 용도\r\n\r\n  * 하이브리드 방식 - key encapsulation\r\n\r\n  * src가 메시지 암호화하는것처럼 세션키를 암호화해서 보내면 dest가 세션키 확인 가능\r\n\r\n    \r\n\r\n## Discrete logarithm\r\n\r\n디스크리트 로그 문제\r\n\r\n![](discrete.png)\r\n\r\n> a가 2일때 몇 번 제곱하면 15가 나올까?\r\n>\r\n> 답 : 11\r\n\r\n\r\n\r\n## Diffie-Hellman Key Exchange\r\n\r\n> 디스크리트 로그 문제가 어렵다는 것을 응용\r\n\r\n![](./dh-key-exchange.png)\r\n\r\n> p가 19, 알파가 2\r\n\r\n* Alice와 Bob의 p와 알파를 공유한다 (퍼블릭함)\r\n\r\n* Alice는 랜덤키 XA(pr)를 생성\r\n\r\n* Bob도 랜덤키 XB(pr) 생성\r\n\r\n* 각자 YA와 YB 생성(pb)\r\n\r\n* YA와 YB를 서로 공유\r\n\r\n* 받은 상대의 퍼블릭키를 자신의 프라이빗키로 제곱한 후 mod q를 하면 둘은 동일한 값의 키 K를 얻을 수 있다\r\n\r\n  > 어떻게 두 K가 같을 수 있는가?\r\n  >\r\n  > * YB 는 `알파의 XB제곱`\r\n  > * Alice는 YB에 XA 제곱을 해야하니 결국  `알파의 XB제곱`에 XA제곱을 하는 셈\r\n  > * Bob또한 YA에 XB  제곱을 하니 결국 `알파의 XA 제곱` XB제곱을 하는 셈\r\n  > * 즉 둘의 K는 알파^(XA x XB) mod q로 값이 같다\r\n\r\n  <br/>\r\n\r\n* 여기서 왜 디스크리트 로그 문제가 중요한걸까?\r\n\r\n  > 모두에게 알파, q, YA, YB 값이 공개됨\r\n  >\r\n  > 프라이빗키인 XA는 YA를 구할 때 알파의 지수로 사용되므로 디스크리트 로그 문제를 쉽게 풀 수 있다면 프라이빗키인 XA도 알아낼 수 있음\r\n\r\n* 결론은, 디피헬먼 알고리즘에서 안전성을 보장하려면  XA와 XB를 알아낼 수 없어야함\r\n* 만약 Alice가 XA를 잘못 생성하면 공격가능\r\n  * XA는 랜덤으로 생성됨 - 난수발생기의 성능이 중요\r\n  * 만약 Alice가 시간값같은걸로 랜덤 시드를 발생시킨다면 위험. 공격자가 시간대를 추측가능\r\n  * seed가 뭐냐에 따라서 안전성이 걸림\r\n  * 위에서 YA와 q, 알파값으로 XA를 추측해내는 방법이 아니라 가능성 높은 XA들을 추측해서(ex. 시간대) 모든 XA후보들로 계산을 해서 진짜 XA를 맞춰버릴수도있음\r\n\r\n\r\n\r\n## RSA vs DH : Forward Secrecy\r\n\r\nRSA : Key Encapsulation 해서 한 쪽이 세션키 전달\r\n\r\nDH : 양쪽에서 공유\r\n\r\n둘의 차이는 Forward Secrecy\r\n\r\n\r\n\r\n### RSA\r\n\r\n**두 개의 세션이 있다고 가정**\r\n\r\n>  앨리스가 세션키를 밥의 퍼블릭키를 사용해서 암호화하면,\r\n>\r\n> 밥이 자신의 프라이빗키로 암호문을 복호화해서 세션키 획득\r\n>\r\n> 둘은 세션키를 가지고 AES 알고리즘을 써서 메시지 주고받음\r\n\r\n* 만약 세션 2때 해킹으로 밥의 프라이빗키가 노출된다면?\r\n* 공격자또한 밥의 프라이빗키로 세션키 획득이 가능해짐! (세션 1의 키와 세션 2의 키 모두 획득 가능)\r\n* 메시지의 AES 알고리즘을 세션키로 풀 수 있어서 공격자는 세션1,2의 메시지 내용을 전부 볼 수 있음\r\n* 즉, 한 번 프라이빗키가 뚫리면 모든 세션의 메시지가 노출됨\r\n\r\n\r\n\r\n### DH\r\n\r\n**두 개의 세션이 있다고 가정**\r\n\r\n> 각자 프라이빗키인 XA, XB를 만들고 그걸로 퍼블릭키인 YA, YB를 생성해서 공유\r\n>\r\n> 공유한 퍼블릭키로 세션키 생성\r\n>\r\n> **세션키를 생성했다면 XA와 XB는 필요가 없으니 삭제해도 됨**\r\n\r\n* 만약 세션 2때 해킹으로 밥의 프라이빗키가 노출된다면?\r\n* 공격자는 XB를 사용해서 세션 2의 세션키를 획득 가능\r\n* 그러나 세션 1때 사용한 XB는 이미 삭제되었기 때문에 세션 1때 주고받은 메시지는 훔쳐볼 수 없음\r\n* 즉, 이전 세션의 메시지는 안전함\r\n\r\n\r\n\r\n### Forward Secrecy\r\n\r\n앞 쪽은 안전하다는 말\r\n\r\n* RSA와 DH의 차이는 Forward Secrecy다\r\n\r\n> RSA는 프라이빗키가 뚫리면 모든 세션의 메시지가 노출된다\r\n>\r\n> DH는 프라이빗키가 뚫리면 해당 세션의 메시지만 노출되지만 이전 세션의 메시지는 안전하다\r\n\r\n\r\n\r\n#### RSA도 Forward Secrecy 할 수는 없을까?\r\n\r\n* DH에서 사용한 XA, XB를 삭제해버려 이전 세션의 키를 복구할 수 없게 만든것처럼, RSA의 프라이빗키인 d도 사용하면 삭제하고 매 세션마다 다시 새로 만들자!\r\n\r\n  > 근데 키페어 만드는 과정이 개 복잡함. 추천하지않는 방법. 비효율적\r\n\r\n* 그냥... DH쓰자...^^\r\n\r\n  * TLS 1.3에서는 아예 RSA의 key exchange지원안함 (1.2까지만 지원)\r\n\r\n\r\n\r\n## Man in the Middle (MitM) Attack\r\n\r\n* 중간에서 src or dest 인척 속임\r\n\r\n* 공격자인 다스는 앨리스에겐 밥인척 YD1을 보냄\r\n\r\n* 밥에겐 앨리스인척 YD2를 보냄\r\n\r\n* 사실상 앨리스 - 다스, 밥 - 다스 사이 정상적인 DH가 작동되긴했지만 상대가 다스라는게 문제\r\n\r\n* 다스가 중간에서 메시지를 정상적인척 전달해주기때문에 앨리스와 밥은 중간에 다스가 있는지 모름\r\n\r\n  > dest는 받은 퍼블릭키 Y가 src가 보낸 Y가 맞는지 확인할 방법이 없기 때문에 발생하는 문제\r\n\r\n  * 공인 인증서로 해결 가능\r\n\r\n\r\n\r\n## ElGamal Encryption\r\n\r\n디스크리트 로그 문제에 기반한 또 다른 암호임\r\n\r\n* 퍼블릭한 파라미터 q와 알파 생성\r\n\r\n#### Key Generation by Alice\r\n\r\n* DH처럼 XA 랜덤으로 생성\r\n* XA로 YA생성\r\n  * DH와의 차이 : DH는 세션키 생성을 위해 X와 Y를 임시로 만들지만 Elgamel은  이렇게 생성한 키페어를 지속적으로 사용함\r\n\r\n#### Encryption by Bob (with Alice의 PB)\r\n\r\n* 밥은 랜덤한 정수 k를 생성\r\n\r\n* 밥은 앨리스의 퍼블릭키 YA와 k를 가지고 K를 생성\r\n* 알파와 k를 가지고 C1생성\r\n* K와 평문M을 가지고 C2생성\r\n* 두 개의 암호문 C1, C2를 앨리스에게 전달!\r\n\r\n#### Decryption by Alice (with Alice의 PR)\r\n\r\nC1 - 밥의 임시 공개키라고 볼 수 있음\r\n\r\n* 앨리스는 자신의 프라이빗키와 C1을 가지고 K를 복원\r\n* 앨리스는 복원한 K와 C2를 가지고 본래의 메시지로 복호화\r\n\r\n> DH와 OTP을 합친거라고 볼 수 있음\r\n>\r\n> One Time Pad (랜덤키)\r\n>\r\n> 메시지와 같은 길이의 랜덤키 K를 생성 - OTP의 키처럼 사용\r\n\r\n\r\n\r\n## Elliptic Curve Arithmetic\r\n\r\n타원곡선암호\r\n\r\n3072 bit의 RSA와 128bit AES의 안전성이 비슷함\r\n\r\n> 큰 비트수의 암호를 쓰면 계산도 많이 해야하고 메모리도 많이 사용하고...\r\n\r\n그 대안이 ECC (Elliptic Curve Arithmetic)\r\n\r\n* 공개키 암호의 표준 IEEE P1363a에 타원곡선 암호가 포함됨\r\n* 자동차 환경 무선통신(WAVE) 표준 IEEE 1609에서 rsa는 배제되어있고 타원곡선만 언급됨\r\n* 대부분의 공개키암호 표준에서는 디피헬만, rsa, 타원곡선암호 다 포함되어있음. 최근에 나오는 특정 표준에서는 타원 곡선 암호만 포함하게 하는 경우도 있음\r\n* 같은 안전성을 주기위해서 훨씬 짧은 키를 써도 된다 (같은 키 길이를 쓰면 ECC가 훨씬 안전함)\r\n* 자동차의 경우 패킷 길이가 길면 그 사이 차가 슝 지나가 통신 범위에서 멀어져 전송을 못할수도있다. 즉, 패키 길이가 짧은게 중요\r\n* 패킷 길이가 작아야하는데 3072bit인 RSA는 적합하지않음 (타원곡선 암호는 256bit로 같은 안전성을 보여줌)\r\n\r\n\r\n\r\n## Comparable Security Strengths\r\n\r\n타원곡선암호와 기존 공개키 암호의 비교\r\n\r\nNIST에서 표준화한 키 관리 권고사항에 대한 표준 (가장 최근의 Revision 5)\r\n\r\n보안강도 : 공격자가 성공적으로 키를 복구하기위해 어느정도의 작업을 해야하는가? - 클수록 좋음\r\n\r\n> 80이라고하면 공격자의 작업량이 2^80이라는 뜻\r\n>\r\n> 128과 256을 비교하면, bit수는 두 배가 됐지만 공격자의 작업량은 2^128배만큼 늘어남\r\n\r\nrsa나 디스크리트 로그 계열 암호들은 모듈러스에 비해 훨씬 적은 안전성을 제공하게 된다\r\n\r\n타원곡선은 공격자에게 요구되는 비트수의 두 배정도되는 숫자를 키로 쓰면 안전하다\r\n\r\n같은 비트 (Security Strength)안전성을 봤을 때 RSA에 비해 타원곡선에게 요구되는 비트의 수가 훨씬 적다. 증가하는 속도도 더 낮음.\r\n\r\n\r\n\r\n## Abelian Group\r\n\r\n아래 조건들을 만족하는 원소들의 집합\r\n\r\n\r\n\r\n## Cyclic Group\r\n\r\n어떤 제너레이터가 그룹 안의 모든 원소를 생성해낼 수 있는 그룹.\r\n\r\n\r\n\r\n## 타원 곡선\r\n\r\n> y에 대해서는 2차식이고 x에 대해서는 3차식으로 되어있는 곡선\r\n\r\n* 두 가지 형태 존재\r\n\r\n  * 타원이 있고 나머지는 곡선으로 떨어져있는 형태\r\n\r\n  * 곡선 하나로 다 이어져있는 형태\r\n\r\n\r\n\r\n### ECDLP(Elliptic curve discrete logarithm problem)\r\n\r\n> 타원곡선 암호는 ECDLP에 기반하고있다\r\n\r\n그래프 내 어떤 점 P와 ,Q를 이어서 직선을 그으면 또 다른 점, -(P+Q)와 만난다 (3차 그래프이기때문)\r\n\r\nx 중심축을 기준으로 -(P+Q)와 대칭되는 점이 (P+Q)이다\r\n\r\n> 서로 다른 점 P+Q외에 같은 점 P와 P를 더한 2P도 얻을 수 있다.\r\n>\r\n> * 두 점 P와 Q를 이어서 그은 직선이 아닌 P를 접하는 직선을 그음\r\n> * 위 방법으로 2P, 3P, 4P ... 계속 구하기 가능 (계속 더 하다 보면 언젠가 자기자신 P로 돌아옴)\r\n> * 즉, P하나로 모든 원소를 생성하는 Cyclic Group을 나타낼수도있음\r\n\r\n<br/>\r\n\r\n* 디스크리트 로그 문제와 비슷하게 활용할 수 있음\r\n  * `kP = Q` 일 때, \r\n  * k와 P가 주어지면, square & multiply처럼 덧셈과 2배연산을 반복해서 Q를 계산해낼수있다\r\n  * 그러나 반대로 P와 Q가 주어졌을 때 k를 알아내기는 힘들다\r\n\r\n* 타원곡선의 Addition이 finite field의 modular mulitiplication처럼 작동할 예정\r\n* Multiple addition이 modular exponentiaion처럼 작동함\r\n* 디스크리트 로그문제보다 더 어려움\r\n\r\n\r\n\r\n### ECDH (Elliptic Curve Diffie-Hellman) Key Exchange\r\n\r\n기존의 지수연산을 타원곡선 점들간의 몇 배 연산으로 대체할 수 있음\r\n\r\n즉, 디스크리트 로그 상에서 정의되는 여러가지 프로토콜들을 그대로 사용할 수 있다\r\n\r\n> 디피헬먼도 타원곡선 버전으로 만들 수 있음\r\n\r\n![](./ecdh.png)\r\n\r\n> E : 타원 곡선식\r\n>\r\n> G : 제너레이터. 어디서부터 시작할 것인지\r\n>\r\n> n : G로 만들 수 있는 가장 큰 값\r\n\r\n#### User A Key Generation\r\n\r\n> n보다 작은 nA(PR)를 랜덤하게 뽑는다\r\n>\r\n> nA x G 를 해서 PA(PU)를 구한다\r\n\r\n#### User B Key Generation\r\n\r\n> 위와 마찬가지로, \r\n>\r\n> n보다 작은 nB(PR)를 랜덤하게 뽑는다\r\n>\r\n> nB x G 를 해서 PB(PU)를 구한다\r\n\r\n* 둘은 PA와 PB를 서로에게 공유한다\r\n\r\n* 둘은 받은 상대의 퍼블릭키(P)와 자신의 프라이빗키(n)를 곱해 K를 만든다\r\n\r\n<br/>\r\n\r\n> 공격자는 E, G, PA, PB를 알아도\r\n>\r\n> nA, nB를 추측해내기 어렵다.\r\n>\r\n> 여기서 사용하는 nA, nB가 이전에 했던 XA, XB보다 작은 bit의 수이다. 훨씬 효율적!\r\n\r\n\r\n\r\n### Security of Elliptic Curve Cryptography\r\n\r\nECDLP를 깨는 가장 효율적인 알고리즘은 `Pollard rho method`, DLP에도 똑같이 적용됨\r\n\r\nDLP는 `Pollard rho method`처럼 일반적인 방법보다 더 빨리 문제를 풀 수 있는 알고리즘이 존재 (팩토링이랑 비슷?)\r\n\r\n보통 키길이가 비슷하면, rsa나 dh나 타원곡선암호든 계산량이 비슷함. \r\n\r\n키의 길이가 작으면 계산량이 작다는 뜻\r\n\r\n그럼, 비슷한 시큐리티를 가정했을 때 타원곡선쪽이 다른 방법보다 더 적은 계산량을 제공하고 효율성을 자랑한다."},{"excerpt":"Hash Function 자료구조의 해시테이블이랑 비슷한 개념 인풋으로 길이가 변할 수 있는 블록 M을 받는다 아웃풋으로 정해진 길이의 해시값을 출력한다 h = H(M) 주로 데이터 무결성(Integrity)를 보장하는데  사용됨 일종의 압축함수라고 생각할 수 있다 Crptographic hash 함수의 조건 h를 주면 M을 찾기 어려워야함 the one…","fields":{"slug":"/2-hash-func/"},"frontmatter":{"date":"June 06, 2022","title":"11-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## Hash Function\r\n\r\n> 자료구조의 해시테이블이랑 비슷한 개념\r\n\r\n* 인풋으로 길이가 변할 수 있는 블록 M을 받는다\r\n* 아웃풋으로 정해진 길이의 해시값을 출력한다\r\n* h = H(M)\r\n\r\n* 주로 데이터 무결성(Integrity)를 보장하는데  사용됨\r\n* 일종의 압축함수라고 생각할 수 있다\r\n\r\n> Crptographic hash 함수의 조건\r\n>\r\n> * h를 주면 M을 찾기 어려워야함\r\n>   * the one-way property : 단방향적, M에서 h를 찾긴 쉽지만 그 반대는 어렵다\r\n> * the collision-free property : 같은 hash value를 아웃풋으로 가지는 인풋 데이터 쌍을 찾기 어렵다\r\n\r\n\r\n\r\n### 해시 함수의 다섯가지 용도\r\n\r\n* MAC : keyed hash\r\n* digital signature\r\n* password protection\r\n* system integrity 보호\r\n* PRF / PRNG 수도 랜덤 함수, 수도 랜덤 넘버 제너레이터\r\n\r\n\r\n\r\n### Data Integrity 용도\r\n\r\n* src는 데이터 뒷부분에 해시값을 붙여서 보냄\r\n* dest는 받은 데이터의 앞부분에 해시함수를 적용하고 그 값이 데이터 뒷부분의 해시값과 일치하는지 확인\r\n* 같다면 전송과정에서 오류가 없는것\r\n\r\n\r\n\r\n만약 다스가 중간에서 공격한다면? (Man in the middle attack)\r\n\r\n원래 데이터의 해시값인지 변조된 해시값인지 구별이 불가능\r\n\r\n왜 이 방법이 가능한가?\r\n\r\n* 다스가 변조된 데이터에 대해서 자기 나름대로 해시값을 쉽게 계산할 수 있기 때문\r\n* 해쉬값을 쉽게 계산 못하게하자!\r\n\r\n\r\n\r\n### MAC \r\n\r\n* keyed hash function이라고도 한다\r\n* key를 넣고 hash를 돌리겠다! (앞의 허술한 hash와는 다르다!)\r\n* key는 src와 dest가 미리 공유한 비밀키\r\n\r\n> 인풋으로 시크릿 키와 데이터 블록을 받는다 - MAC으로 작용\r\n>\r\n> * 무결성을 점검해보려면 \r\n> * src는 원래 메시지 데이터에 MAC을 붙여서 보냄\r\n> * dest는 자기가 알고있는 keyed hash를 돌려서 받은 MAC과 비교\r\n>\r\n> 공격자는 key가 없어서 MAC값을 변조할 수 없다\r\n\r\n![](./mac-procedure.png)\r\n\r\n|| : 붙인다는 뜻\r\n\r\n* Message에다가 Secret key를 비트 스트링으로 뒤에 붙임\r\n* 이걸 해시로 돌림\r\n* Message에 해시값을 붙여서 보냄\r\n* dest는 받은 Message부분에 해시함수를 돌려서 받은 MAC과 자신이 만든 MAC이 같은지 비교\r\n* integrity와 authentication 둘 다 수행\r\n\r\n\r\n\r\n### Digital Signature\r\n\r\nMAC에서의 역할과 비슷\r\n\r\nnonrepudation\r\n\r\n메시지의 해시값에 서명할 것\r\n\r\n\r\n\r\n> RSA에서의 디지털 서명\r\n>\r\n> src의 프라이빗키인 d로 M을 암호화한 S를 M에 붙여서 dest에게 보냄\r\n>\r\n> dest는 S를 src의 퍼블릭 키로 복호화하고 M과 일치하는지 확인\r\n>\r\n> * 그러나 RSA는 암호화에 mod n을 적용하기 때문에 메시지인 M이 n보다 작아야함\r\n> * 그러나 엄청 긴 메시지를 보내려면...?\r\n> * M을 블록처럼 나누고 서명해서 여러개를 보낸다?\r\n> * 그럴 필요 없음!\r\n> * 누군가가 조작하지않았다는 것만 보장하면 되기때문에 굳이 길이에 집착할 필요 없음 해시를 대신 적용하자!\r\n\r\n* M을 해시함수에 돌려 H를 얻는다\r\n* H를 src의 프라이빗키로 암호화한 E(sign)를 얻는다\r\n* M에 E를 붙여 전송한다\r\n* dest는 받은 M에 해시함수를 돌린 값과 받은 E를 퍼블릭키로 복호화한 값이 같은지 확인\r\n\r\n\r\n\r\nOther Hash Function Uses\r\n\r\n### one-way password\r\n\r\n유저의 아이디와 패스워드를 저장할 때\r\n\r\n* id : password\r\n\r\n이런식으로 저장하지않고\r\n\r\n* id : H(password)\r\n\r\n를 저장한다\r\n\r\n\r\n\r\n#### 오프라인 딕셔너리 어택\r\n\r\n공격자는 자주 사용되는 패스워드에 대응하는 해시 값을 딕셔너리 형태로 미리 만들어둠  \r\n\r\n해킹을 해서 user의 H(password)를 알아내고 H(password)와 일치하는 값이 미리 만들어둔 딕셔너리에 있는지 탐색\r\n\r\n \r\n\r\n이걸 막기위해\r\n\r\n해시를 쓸 때 그냥 쓰는게 아니라 salt라는 값을 쓴다\r\n\r\nsault 값이 12345라면,\r\n\r\nH(password || 12345 )를 한다.\r\n\r\n공격자는 사전을 만드려면 패스워드에 여러 salt값까지 추가로 붙여야하기때문에 salt 크기만큼 사전의 크기도 늘어난다\r\n\r\n공격자의 리소스 사용을 늘림\r\n\r\n\r\n\r\n### intrusion and virus detection\r\n\r\nF = file\r\n\r\n파일을 해시함수로 돌려서 저장\r\n\r\n이후 똑같은 파일을 해시 함수로 돌렸는데 해시값이 바뀌면 파일이 변조된것\r\n\r\n* 공격방법은 아까와 동일하게 공격자가 해시값을 생성해서 변조된 해시값을 붙이는 것\r\n* 막는 방법은 해시값을 안전한 곳에 보관하거나 key를 추가로 사용\r\n\r\n\r\n\r\n### PRF, PRNG\r\n\r\n해시함수의 요구 조건\r\n\r\nPreimage\r\n\r\n* x를 해시함수에 돌렸는데 h가 나옴 (h = H(x)) 이때 x를 h의 preimage라고 부름\r\n* 해시함수는 일반적이로 다대일 매핑\r\n* h 결과값에 대응하는 원래 인풋들이 많음\r\n\r\nCollision\r\n\r\n* 공격자가 변조된 데이터를 보냈는데\r\n* 변조된 데이터의 해시값과 원본 데이터의 해시값이 일치하면 무결성을 보증할 수 없기때문에 안됨\r\n\r\n\r\n\r\n## 해시 함수를 어떻게 만들어야할까?\r\n\r\n#### 이렇게 만들면 안됨!\r\n\r\n노안전 사례\r\n\r\n* 입력을 n bit단위의 여러 블록으로 자름\r\n* 한 블록을 한 번에 하나씩 해시 함수로 돌림\r\n\r\n\r\n\r\n* 비트 단위로 xor - 패리티비트 생성\r\n\r\n\r\n\r\n* 단순히 xor이 아니라 다음 블록으로 넘어갈때마다 한 비트를 circular shift해서 비트 xor\r\n\r\nPreimage랑 Collision 특징 충족못함\r\n\r\n* oneway : 결과물을 가지고 인풋을 임의로 만들어낼 수 있다\r\n* collision : 같은 xor결과값을 만들어낼 수 있다\r\n\r\n\r\n\r\n## Attacks on Hash Functions\r\n\r\n### Brute-Force Attack\r\n\r\n막 던져봄\r\n\r\n아웃풋 길이가 길수록 공격하기 어려움 -> 그만큼 시도수가 늘어나니까\r\n\r\n\r\n\r\n### Cryptanalysis\r\n\r\n알고리즘의 취약점을 찾는다\r\n\r\nex. 아까 위에서는 xor을 만든다는 특징을 이용해서 공격. 0,0 -> 1,1로 바꿔서 다른 input 같은 결과도출\r\n\r\n\r\n\r\n### Collision Resistant Attacks\r\n\r\nbirthday paradox\r\n\r\nm bit짜리 아웃풋의 인풋을 맞춰보려면 2^m + 1만큼 시도해야함\r\n\r\n그러나 그 반인 2^(m/2) 번의 시도로도 1/2이상의 확률로 충돌을 찾을 수 있다\r\n\r\n\r\n\r\n## Secure Hash Algorithm(SHA)\r\n\r\n해시 함수를 잘 설계해야한다!\r\n\r\nNIST에서 해시 함수 안전 표준 알고리즘을 제안\r\n\r\nSHA-0 : 1993 : 표준화는 안됨\r\n\r\nSHA-1 : 1995, 해시 함수 MD(message digest = hash func)4에 기반, 160bit의 해시 값, 근데 깨짐\r\n\r\nSHA-2 : 256, 384, 512 bit\r\n\r\nSHA-3 224, 256, 384, 512 bit\r\n\r\n\r\n\r\nSHA 는 역방향 계산안됨~ 블럭암호와 해쉬암호의 차이\r\n\r\n\r\n\r\n뒤에 10분정도 다시 듣기\r\n\r\n\r\n\r\n"},{"excerpt":"상호 암호제품의 국방 활용 암호 제품이란? 좁은 의미 정보의 기밀성, L무결성, 인증 및 부인 방지를 제공하기 위해 암호기술을 적용하여 개발, 생상, 유통되는 제품 넓은 의미 최근 ICT 융합 서비스가 확대되고 IoT 기기, GW등에 암호기술이 적용. 정보, 물리보안제품 및 암호, 인증 기술을 적용한 ICT제품까지 포함 발생 가능 문제점 작전용 활용시 발…","fields":{"slug":"/1/"},"frontmatter":{"date":"June 06, 2022","title":"11-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 상호 암호제품의 국방 활용\r\n\r\n암호 제품이란?\r\n\r\n* 좁은 의미\r\n  * 정보의 기밀성, L무결성, 인증 및 부인 방지를 제공하기 위해 암호기술을 적용하여 개발, 생상, 유통되는 제품\r\n\r\n* 넓은 의미\r\n  * 최근 ICT 융합 서비스가 확대되고 IoT 기기, GW등에 암호기술이 적용. 정보, 물리보안제품 및 암호, 인증 기술을 적용한 ICT제품까지 포함\r\n\r\n\r\n\r\n### 발생 가능 문제점\r\n\r\n작전용 활용시 발생가능 문제점\r\n\r\n* 드론 탐지 시스템\r\n\r\n> ex\r\n>\r\n> DJI 드론 탐색 가능\r\n>\r\n> 기체의 비행경로 및 조종자(부대) 위치를 알아낼 수 있음\r\n>\r\n> 통신 링크 가로채서 작동\r\n\r\n* 통신상 보안문제\r\n  * 상대의 휴대전화로 위치 파악\r\n\r\n암호 제품을 사용할 때 검증이 중요\r\n\r\n* 검증 체계 : KCMVP\r\n* 국내용, 국제용 적합성 평가 존재\r\n\r\n\r\n\r\nex) 군 도입 상용 드론\r\n\r\n드론을 구입해올때 KCMVP 암호 인증을 거친걸 가져옴\r\n\r\n* 그 외, IC칩 정보 노출\r\n  * IC칩 정보를 육안으로 확인할 수 있으면 해당 제품사의 제품 특징으로 드론의 정보를 얻을 수 있기에 위험\r\n* 펌웨어 덤프\r\n  * 디버깅 포트 연결하면 펌웨어 덤프도 가능\r\n  * 내부 시스템 상태 노출 위험ㅌ\r\n* 디버그 포트 접속\r\n  * 디버깅 포트를 이용해 내부 파일 시스템에 접근 가능\r\n* 부채널 대응 기술 부재\r\n\r\n등의 문제가 있는지 또 검사\r\n\r\n\r\n\r\n<br/>\r\n\r\n이외에 암호적으로도 검사\r\n\r\n* 암호 구현 오류\r\n  * 동일 평문에 대해 보안에 취약한 블록암호 운영모드 사용(ECB같은거 하면 안됨)\r\n* 암호키 평문 저장\r\n* 무결성 검증키 노출\r\n* 기기인증 기능 x\r\n* 환경설정 파일 임의 수정\r\n\r\n\r\n\r\n보안을 위해 국방 드론 보안 가이드라인을 만들어서 군 내에서 배포\r\n\r\n\r\n\r\n진짜 설마 군무원, 경채에서 문제 내겠냐? ...\r\n\r\n코드에서 문제가... 나올까?\r\n\r\n\r\n\r\n\r\n\r\n## Buffer Overflow\r\n\r\n> 메모리를 직접 만지는 함수때문에 생기는 문제\r\n>\r\n> ex) strcpy\r\n\r\n* 잘못 수행하면 메모리의 데이터가 차지하는 영역이 망가짐.\r\n* 바운더리를 체크하지않았기때문\r\n* 오버플로우 되어서 원하지않는곳에 데이터가 쓰여짐\r\n* 버퍼 overrun이라고 부르기도함\r\n* 코드 자체를 공격하는 공격법중에 가장 많이 사용되는 방법\r\n* c 나 c++처럼 메모리세이프하지않은 언어들에게서 생기는 문제. python같이 메모리를 다루지않는 언어에서는 문제가 발생하지않음\r\n* 스택오버플로우와 힙오버플로우 존재\r\n\r\n\r\n\r\n### Stack Buffer Overflow\r\n\r\n> 공격자가 데이터를 제어하면서 데이터가 쓰여져야하는 영역 너머로 벗어나면서 어떤 함수의 return address를 덮어씌우면서 발생하는 문제\r\n\r\n예시코드를 보면 \r\n\r\n`strcpy(c, bar)`에서 strcpy가 몇 글자를 붙여넣을건지 정의가 안되어있음(오버플로우 가능 - 12글자가 넘어도 카피)\r\n\r\n오버플로우가 된 세 번째 사진을 보면 return address가 저장되는곳까지 덮어씌워짐\r\n\r\n잘못된 return address로 가게됨 (잘못된 것을 실행 - x-08~가 실행됨)\r\n\r\n* 만약 리턴 어드레스가 유효하지않는 주소라면 윈도우라면 프로세스 죽음, 맥,리눅스라면 segmentaiton fault\r\n* 실제 공격에선 프로그램이 그 영역으로 가도록(return address 수정), Shellcode가 실행되게 됨\r\n\r\n* Shellcode\r\n  * 길면안됨 - 짧은 코드\r\n  * 명령어 인터페이스를 띄워줌 (shell을 만듦)\r\n  * 만들어진 shell에 공격자가 또 다른 공격을 가할 수 있음\r\n* 그럼 공격자가 어느 부분의 코드가 return address에  쓰여지는지 어떻게 추측할 수 있을까?\r\n\r\n#### NOP sled\r\n\r\nnop : 아무것도 안하는 명령\r\n\r\nsled : 썰매\r\n\r\nnop막 해두고 점프하게 해둠. 점프점프 하다가 shell code에 갈 수 있게 ^^\r\n\r\n\r\n\r\n### 막는 방법\r\n\r\n#### safe coding\r\n\r\n코딩 단계에서 막는 방법\r\n\r\n메모리 직접 안만지는 언어 쓰자! ㅎㅎ\r\n\r\n성능때문에 메모리 만지는 언어 써야할 때\r\n\r\n* safe libraries를 쓰자\r\n* strcpy, gets ... 쓰면 안됨\r\n* scanf_s 써라!\r\n* 예전에 모리스웜이 finger protocol사용해서 악용\r\n\r\n\r\n\r\n#### OS, compiler단계에서 막기\r\n\r\n* IDS, IPS에서 들어오는 패킷 분석 - 특정 코드 패턴이 있는지 확인 (nop많은가?)\r\n* 그걸 또 공격자가 알아채면 자연스러운nop로 공격 더하기연산 하고 답은 안씀\r\n* 그걸 또 방어자가 알면 규칙을 업데이트하는...\r\n*  스택 사용 불가능\r\n* 스택 이상하게 되면 체크\r\n\r\n\r\n\r\n###  취약점 찾는 방법\r\n\r\n정적 분석 : 실행안하고 확인\r\n\r\n* strcpy썻네 안돼!\r\n* 데이터 플로우 분석\r\n  * cotrol flow graph : 4개의 코드블록 + 분기  - 원래 가야하는 분기가 아닌 엉뚱한 분기로 갔는지 체크\r\n  * Taint analysis : 얼룩, 뭔가가 묻었는지 확인, 오염 전파된 변수 찾음\r\n\r\n, 동적 분석 - 실행을 시키면서\r\n\r\n* Instrumentation\r\n  * 원래 바이너리 코드 사이사이에 임의로 체크하는 코드를 집어 넣음\r\n\r\n"},{"excerpt":"Event란? Event는 \"행동을 실행해야 할 주체\"에서 무엇을 할 것인지 결정한다. 일반 로직의 경우 \"행위가 일어난 주체\"에서 일을 처리한다. 그러나 이벤트는 \"행동을 실행해야 할 주체\"에서 일을 처리한다. 행위가 일어난 주체에서는 행위가 일어났을 때 행동에 필요한 정보와 타이밍만 알려주고 뭘 해야 할지는 각각 행동을 실행해야 할 주체에서 결정한다.…","fields":{"slug":"/4-event-basic/"},"frontmatter":{"date":"June 04, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 4주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## Event란?\r\n\r\n- Event는 \"행동을 실행해야 할 주체\"에서 무엇을 할 것인지 결정한다.\r\n\r\n> 일반 로직의 경우 \"행위가 일어난 주체\"에서 일을 처리한다.\r\n>\r\n> 그러나 이벤트는 \"행동을 실행해야 할 주체\"에서 일을 처리한다. 행위가 일어난 주체에서는 행위가 일어났을 때 행동에 필요한 정보와 타이밍만 알려주고 뭘 해야 할지는 각각 행동을 실행해야 할 주체에서 결정한다.\r\n>\r\n> 즉, 행동을 실행할 주체들은 행위가 일어날 시점을 \"구독\"하고 이벤트 상황 자체만 공유한다. 그 상황들을 Event로 만들어서 전송하게 되면 Event는 하나의 데이터 셋이라고 보면 된다.\r\n>\r\n> 각각의 주체는 해당 이벤트를 받을 때 내부적으로 정해진 행동을 수행한다.\r\n\r\n### Event System의 구성\r\n\r\n- Event : 로직 상에서 어떤 사건의 발생을 의미함. Event의 종류의 식별 정보 및 추가 정보 등을 들고 있는 자료형.\r\n- Handler : 해당 Event를 받았을 때 처리하는 행동의 주체. 특정 이벤트가 불렸을 때 실행되는 함수라고 생각하시면 편하다.\r\n- Sender : 이벤트를 발송하는 객체.\r\n\r\n### Event를 쓰는 이유는?\r\n\r\n- 설계나 구조적인 측면에서 이득\r\n- native 컴포넌트와 제작한 스크립트 컴포넌트가 분리되어있음. native 코드는 수정할 수 없음. 분리가 되어있는 환경에서 통신을 할 수 있게 해주는게 Event.\r\n\r\n### Entity Event System\r\n\r\n> MOD에서는 이벤트 시스템을 쉽게 활용할 수 있도록 제공되는 API가 존재한다.\r\n>\r\n> Entity Event System을 통해 Event를 핸들링할 수 있다.\r\n\r\n- 각각의 컴포넌트는 엔티티를 통해 Handler를 동록한다.\r\n\r\n  ![](./handler-register.png)\r\n\r\n  <br/>\r\n\r\n- Sender 역시 엔티티를 통해서 이벤트를 발생할 수 있다.\r\n\r\n  ![](./sender-register.png)\r\n\r\n<br/>\r\n\r\n- 기본적으로 자기 자신의 엔티티에 연결하는 경우가 대부분이지만, 상황에 따라 다른 엔티티로 연결하는 것도 가능하다. (특히 Map Entity와 World Entity는 서로 간에 이벤트를 주고 받는 겨우가 많다.)\r\n\r\n![](./entity-to-entity.png)\r\n\r\n<br/>\r\n\r\n### 이벤트 생성\r\n\r\n- MyDesk에서 이벤트 타입의 스크립트를 생성한다.\r\n\r\n![](./create-event.png)\r\n\r\n<br/>\r\n\r\n> 예시로 SunriseEvent를 받으면 Vampier와 Hunter 엔티티의 상태가 변하는 이벤트를 생성해보자!\r\n>\r\n> Sunrise 상태이면 Hunter는 Hp를 회복하고 Vampire는 Hp가 감소하는 동작을 한다고 해보자\r\n\r\n<br/>\r\n\r\n- 이벤트 작성\r\n\r\n![](./sunriseevent.png)\r\n\r\n- 이벤트를 만들었다면, 이벤트를 처리할 컴포넌트와 엔티티를 생성한다.\r\n\r\n![](./create-comp.png)\r\n\r\n![](./create-entity.png)\r\n\r\n- 엔티티에 컴포넌트를 등록해준다.\r\n\r\n![](./register-comp.png)\r\n\r\n- 컴포넌트의 `Entity Event Handler`에 앞서 생성한 이벤트를 등록한다.\r\n\r\n![](./register-event.png)\r\n\r\n> Sunrise Event는 map에 의해 발생되므로 중계 엔티티를 self에서 map01로 변경한다.\r\n\r\n![](./event-handler-entity.png)\r\n\r\n<br/>\r\n\r\n- 핸들러를 추가했다면 이제 SunriseEvent를 받을 수 있다!\r\n- 이제 각자 받은 SunriseEvent를 처리하는 로직을 각 컴포넌트에 추가해준다.\r\n\r\n\\# Hunter Component\r\n\r\n```lua\r\nProperty :\r\n    [Sync]\r\n    boolean isSunrise = false\r\n    [Sync]\r\n    number Hp = 0\r\n\r\nMethod :\r\n    [server Only]\r\n    void OnUpdate (number delta)\r\n    {\r\n        if self.isSunrise == true then --해가 떴는지 체크합니다.\r\n            self.Hp = self.Hp + delta --해가 떠 있을 동안 Hp가 증가합니다.\r\n            log(\"Hunter Hp : \"..self.Hp) --현재 체력을 Console 창에 표시합니다.\r\n            if self.Hp >= 200 then self.Hp = 200 end --Hp가 200까지 증가했다면 증가를 멈춥니다.\r\n        end\r\n    }\r\n\r\nEntity Event Handler :\r\n    entity map01 (/maps/map01)\r\n    HandlerSunriseEvent(SunriseEvent event)\r\n    {\r\n        -- Parameters\r\n        local isSunrise = event.isSunrise\r\n        self.isSunrise = isSunrise\r\n    }\r\n```\r\n\r\n<br/>\r\n\r\n\\# Vampire Component\r\n\r\n```lua\r\nProperty :\r\n    [Sync]\r\n    boolean isSunrise = false\r\n    [Sync]\r\n    number Hp = 0\r\n\r\nMethod :\r\n    [server Only]\r\n    void OnUpdate (number delta)\r\n    {\r\n        if self.isSunrise == true then --해가 떴는지 체크합니다.\r\n            self.Hp = self.Hp - delta --해가 떠 있을 동안 Hp가 감소합니다.\r\n            log(\"Vampire Hp : \"..self.Hp) --현재 Hp를 Console 창에 표시합니다.\r\n            if self.Hp < 0 then self.Hp = 0 end --Hp가 0까지 감소했다면 감소를 멈춥니다.\r\n        end\r\n    }\r\n\r\nEntity Event Handler :\r\n    Entity map01 (/maps/map01)\r\n    HandlerSunriseEvent(SunriseEvent event)\r\n    {\r\n        -- Parameters\r\n        local isSunrise = event.isSunrise\r\n        self.isSunrise = isSunrise\r\n    }\r\n```\r\n\r\n## 컴포넌트 확장\r\n\r\n상속처럼 기존 컴포넌트를 확장해서 쓸 수 있다\r\n\r\n- 메소드 오버라이드 가능\r\n\r\n참고 문서\r\n\r\nhttps://mod-developers.nexon.com/docs/?postId=176\r\n"},{"excerpt":"Semaphore disable/enable interrupt wait()와 signal()이 실행중일때 다른 프로세스가  S value에 접근하는 것을 막기위해 를 수행한다 아래 사진 잘못됨 >=  싱글 cpu에서만 사용되는 방법. 멀티 cpu에서는 안됨 멀티 cpu에서는 TAS를 사용하는 방법이 있음 근데 사실 TAS쓰면 busy waiting초래해서…","fields":{"slug":"/sync-exam/"},"frontmatter":{"date":"June 02, 2022","title":"os 10-2 Synchronization Examples","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n## Semaphore\r\n\r\n### disable/enable interrupt\r\n\r\n* wait()와 signal()이 실행중일때 다른 프로세스가  S value에 접근하는 것을 막기위해 `disable/enable interrupt`를 수행한다\r\n\r\n\r\n\r\n아래 사진 잘못됨 >=\r\n\r\n![](./wait-signal.png)\r\n\r\n* 싱글 cpu에서만 사용되는 방법. 멀티 cpu에서는 안됨\r\n  * 멀티 cpu에서는 TAS를 사용하는 방법이 있음\r\n  * 근데 사실 TAS쓰면 busy waiting초래해서 크리티컬 섹션에 진입을 많이하면 cpu 오버헤드가 발생할 수도 있음\r\n\r\n* wait()와 signal()은 커널레벨에서 실행중\r\n\r\n>  근데 커널 레벨에서는 어차피 컨텍스트 스위칭이 안되는게 아닌가? 왜 disable/enable interrupt를 할까?\r\n>\r\n> 시스템콜 : 소프트 레벨 인터럽트 - 하던일을 멈추고 os한테 권한이 넘어감. \r\n>\r\n> * 어떤 프로세스가 시스템콜을 호출하면 모드가 커널모드로 바뀌는 것 뿐. os한테 작업이 넘어가는건 아니고 os의 권한을 빌려서 시스템콜에 대응되는 작업을 하는 것뿐임. 커널의 권한을 가지는 것.\r\n> * 그래서 disable/enable interrupt해줘야함\r\n\r\n\r\n\r\n### Semaphore의 단점\r\n\r\n* 구조화 되어있지않음\r\n  * wait -> signal 을 해야하는데\r\n  * 저 방식으로 안하고 엉뚱하게 해도 체크하지못한다 (signal -> wait, wait -> wait)\r\n  * 잘못 설계하더라도 알아챌 방법이 없다\r\n  * 이 문제를 monitor가 해결해줄 수 있다!\r\n* 데드락과 starvation이 생길 수 있다\r\n\r\n\r\n\r\n## Monitor\r\n\r\n* 동기\r\n  * Semaphore는 unstructured - too low level, bug 유발가능\r\n  * 좀 더 high level의 mutual exclusion 필요\r\n\r\n* OS가 제공하는건 아니고 언어, 랭귀지 - 컴파일러레벨에서 지원\r\n\r\n* Abstract data type (ADT)\r\n  * 함수에 의해서만 안에 있는 변수들에 접근 가능\r\n* 모니터안에서는 하나의 프로세스만 active될 수 있다\r\n\r\n\r\n\r\n구조\r\n\r\n![](./monitor-structure.png)\r\n\r\n두 가지 제약 조건이 있는 class라고 생각하면 됨\r\n\r\n1. **함수에 의해서만 내부 변수에 접근 가능**\r\n\r\n2. **외부에서 하나의 프로세스만 들어올 수 있음**\r\n\r\n<br/>\r\n\r\n* entry queue : 모니터로 들어고자하는 thread의 queue\r\n* condition variable - type이 condition인 value\r\n  * waiting queue의 일종\r\n\r\n<br/>\r\n\r\n**# Monitor with condition variables**\r\n\r\n![](./monitor-structure2.png)\r\n\r\n* condition variable인 x와 y가 존재\r\n* x라는 이름의 waiting queue와 y라는 이름의 waiting queue 존재\r\n* x.wait() - 다른 누군가가 x.signal()을 해주기전까지 기다림\r\n* x.signal() - wait한 애를 깨워줌\r\n\r\n\r\n\r\n### Code Example\r\n\r\n![](./example.png)\r\n\r\n* boolean busy - 리소스가 현재 사용중인지 아닌지\r\n  * 초기화값은 false\r\n\r\n* acquire \r\n  * busy가 false이면 busy를 true로 바꾸고 바로 크리티컬 섹션 진입\r\n  * busy가 true이면 wait()하고 signal()로 깨어나면 busy를 true로 바꾸고 크리티컬 섹션 진입\r\n* release\r\n  * signal을 날려서 x를 깨워줌\r\n\r\n* 유저가 유저레벨에서 동기화 코드를 작성한게 됨\r\n  * disable/enable같은 툴 안쓰고 유저레벨에서 동기화 문제 해결 가능\r\n\r\n\r\n\r\n### Condition variable choices\r\n\r\nex) 만약 Process P가 x.signal()을 하고 Process Q가 x.wait()를 했었다면 어떻게 해야할까?  \r\n\r\n**1. Signal and wait**\r\n\r\n* P는 Q가 자신의 일을 마치고 나올때까지 기다린다 (우리는 이걸로 한다고 가정)\r\n\r\n**2. Signal and Continue**\r\n\r\n* 반대로 P는 계속 주어진 일을 마저 하고 P가 모니터를 빠져나와서야 Q가 시작된다\r\n\r\n\r\n\r\n### Monitor Implementation\r\n\r\n세 개의 큐가 필요 + 각각의 큐에 들어가기 위해 큐를 컨트롤하는 세마포어 lock이 존재 \r\n\r\n* monitor queue - monitor 출입 관리 (= entry queue)\r\n  * monitor lock\r\n\r\n* condition var의 queue - 특정 공유 변수 접근 권한을 갖기위한 큐\r\n  * x_sem\r\n* signal and wait 를 할 때 signal()을 하고 기다릴 프로세스의 대기 queue\r\n  * sig_lock\r\n\r\n![](./lock-example.png)\r\n\r\n* wait(monitor_lock)\r\n  * 누군가 모니터락을 해제하기전까지는 대기\r\n  * 모니터락이 false면 다음라인(body) 수행\r\n\r\n* 모니터락에서 누군가 일을 끝내면 기다리고있는 다음 순번을 깨워준다. 다음 순번은 sig_lock에 있는애가 되거나 모니터락에 있는 애가 될 수 있다.\r\n\r\n* if (sig_lock_count > 0)\r\n\r\n  * 시그 락 카운트가 양수라면 수행하다가 signal()을 호출해서 쫓겨난 프로세스가 있다는 의미. 얘네를 먼저 깨워줌\r\n  * 시그 락 카운트가 0보다 작거나 같다면 모니터락에 있는 애를 깨워준다\r\n\r\n  \r\n\r\n\\# 위 사진의 body는 아래 그림을 의미\r\n\r\n![](./body.png)\r\n\r\n![](./monitor-example.png)\r\n\r\n\r\n\r\n#### condition variable lock\r\n\r\n* x_count : 초기값 - 0\r\n  * x에 접근하기 위해서 대기하고 있는 스레드 수\r\n* x_sem : 초기값 - 1\r\n  * x semaphore value(자원이 몇 개 있냐)\r\n\r\n![](./con-var-lock.png)\r\n\r\n* wait() : 기다렸다가 lock검 - 어떤 스레드가 자원 쓰려는데 이미 누가 쓰고있으면 대기큐에 들어가서 기다리게하는 함수. 다 기다리면 크리티컬 섹션 진입 가능? (자원 쓰고있는 애 없으면 아무일도 안함. 바로 크리티컬 섹션 진입 가능)\r\n* signal() : 해당 lock을 풀어줌 - 어떤 스레드가 자원 다 써서 크리티컬 섹션 나가려는데 나가려는 김에 리소스 쓰려고 대기하는 애가 있다면 겸사 겸사 깨워주는 함수\r\n* x_wait : 어떤 스레드가 x라는 자원을 사용하고싶다고하면 대기시킴, 대기하는동안 다른 애들 실행하는듯 (x.signal()이 오면 풀려남)\r\n  * x_count++ : x 사용할 스레드 늘어남! 나 x쓸거임! 근데 그 전에 깨워줘야할 애들 있음;ㅎㅎ\r\n  * sig_lock된 애 부터 깨워줌\r\n  * 없으면 monitor 큐에서 대기하는 애 깨워줌\r\n  * 앞에 애들 다 확인했으니까 x하려고 기다리고 있는애 wait()해줌?\r\n* x_signal : 어떤 스레드가 x라는 자원을 기다리고있다면 사용하도록 허락 (= **x.wait()한 프로세스가 있다면 걔 다시 시작함**), 기다리는 애 없으면 아무 일도 안함\r\n  * x_count가 양수라면 x를 사용하기위해 대기중인 스레드가 있다는 말 (너 x 써라!)\r\n  * sig_lock_count++ : x_signal()을 호출한 스레드는 자리를 양보해줘야함. 호출한 애는 sig_lock되어있어라~\r\n  * signal(x_sem) : x_signal해서 x사용할 애 깨워줘야하니까 x_sem에 있는애한테 얼른 쓰라고 깨워줌\r\n  * wait(sig_lock) : x_signal() 호출한 애는 쫓겨나서 기다려야함. 나중에 x.wait() 누가 해주면 깨어날 수 있음\r\n  * 위에다 끝나면 sig_lock_count 다시 마이너스\r\n\r\n\r\n\r\n## 리눅스에서 제공하는 Synchronization 기법\r\n\r\n2.6버전 이후 초창기에는 짧은 크리티컬 섹션에서는 인터럽트를 막고 푸는 기법을 썼다\r\n\r\n최근에는 fully preemptive한 기법을 사용(누군가 중간에 치고 들어올 수 있는)\r\n\r\n* 대부분이 시스템이 멀티프로세서이기 때문\r\n* TAS를 사용해서 spin lock(busy waiting)이 걸리는 형태로\r\n\r\n\r\n\r\nSemaphores 제공\r\n\r\nAtomic integers 제공 : 사용자 수준에서 TAS를 사용하기쉽게 변수 타입과 함수들 제공 - atomic 오퍼레이션을 통해서 접근을 하면 다른 애들은 접근을 못하게하는 기능 제공, 간단한 크리티컬 섹션 제어에 사용(변수 하나), 동시에 여러 개의 변수 권한을 설정하려면 세마포어 사용\r\n\r\natomic_t  : 동시에 여러명이 접근할 수 없는 integer이다\r\n"},{"excerpt":"스크립트의 이해 MOD는 스크립트 에디터를 사용해서 크리에이터가 원하는 컴포넌트나 로직을 만들 수 있다. 스크립트의 문법은 Lua Script를 사용하면 다양한 MOD API를 지원한다 스크립트 컴포넌트 추가방법  Workspace의 MyDest에서  -> 를 통해 스크립트 컴포넌트를 생성할 수 있다 Logic이나 Script등 다양한 형태의 스크립트를 …","fields":{"slug":"/3-script-basic/"},"frontmatter":{"date":"May 30, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 3주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n## 스크립트의 이해\r\n\r\n> MOD는 스크립트 에디터를 사용해서 크리에이터가 원하는 컴포넌트나 로직을 만들 수 있다.\r\n>\r\n> 스크립트의 문법은 Lua Script를 사용하면 다양한 MOD API를 지원한다\r\n\r\n\r\n\r\n### 스크립트 컴포넌트 추가방법\r\n\r\n![](./create-script.png)\r\n\r\nWorkspace의 MyDest에서 `Create Scripts` -> `Create Component`를 통해 스크립트 컴포넌트를 생성할 수 있다\r\n\r\n* Logic이나 Script등 다양한 형태의 스크립트를 생성할 수 있지만 스크립트 컴포넌트가 가장 많이 사용된다\r\n* 스크립트 로직의 경우 맵에서 단 하나 존재하며 디버깅등에서 사용된다\r\n\r\n\r\n\r\n### 스크립트 작성\r\n\r\n![](./comp-structure.png)\r\n\r\n예시로 `HelloMapleWorld`라는 이름을 가진 스크립트 컴포넌트를 생성해보자\r\n\r\n컴포넌트안에는 프로퍼티와 메소드, 이벤트 핸들러를 등록할 수 있다.\r\n\r\n<br/>\r\n\r\n이번에는 간단하게 콘솔에 \"Hello Maple World\"를 찍어내는 로그를 생성해보도록 한다\r\n\r\n![](./comp-func.png)\r\n\r\n`Function`옆의 `+` 버튼을 클릭하면 함수 리스트가 보인다\r\n\r\n이번에는 `OnBeginPlay` 함수를 등록한다. `OnBeginPlay` 함수는 스크립트 컴포넌트가 실행될 때 처음 한 번 실행된다.\r\n\r\n<br/>\r\n\r\n![](./func-log.png)\r\n\r\n생성한 `OnBeginPlay`함수 안에 로그를 작성해준다\r\n\r\n\r\n\r\n\r\n\r\n### 작성한 스크립트를 엔티티에 등록\r\n\r\n스크립트 컴포넌트를 작성했다면 엔티티에 추가해줘야한다\r\n\r\n위에서 작성한 `HelloMapleWorld` 컴포넌트를 `DefaultPlayer` 엔티티에 추가해보자\r\n\r\n<br/>\r\n\r\n![](./workspace.png)\r\n\r\n`Workspace`에서 `DefaultPlayer`를 눌러 `DefaultPlayer`의 `Property`를 확인할 수 있다.\r\n\r\n<br/>\r\n\r\n![](./player-prop.png)\r\n\r\n하단의 `Add Component` 버튼을 눌러 앞서 생성한 `HelloMapleWorld` 컴포넌트를 추가해보자!\r\n\r\n<br/>\r\n\r\n엔티티에 컴포넌트를 등록하는 것 까지 마쳤으니 실제로 등록한 컴포넌트가 잘 실행되는지 확인해보자.\r\n\r\n<br/>\r\n\r\n![](./log.png)\r\n\r\n상단의 플레이버튼을 누르면 작성한대로 \"Hello Maple World\"라는 로그가 콘솔에 뜨는 것을 볼 수 있다.\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n### 스크립트 컴포넌트 예시\r\n\r\n스크립트 예시를 하나 더 보자!\r\n\r\n<br/>\r\n\r\n![](./ex-script.png)\r\n\r\n위는 예시로 생성한 `MyFirstComponent` 이다.\r\n\r\n* 컴포넌트내 프로퍼티와 메소드는 `self`를 통해서 호출할 수 있다.\r\n\r\n  ```lua\r\n  -- 프로퍼티는 .을 사용해서 호출한다\r\n  self.sum = 10\r\n  \r\n  -- 메소드는 :를 사용해서 호출한다\r\n  self:SetSum()\r\n  ```\r\n\r\n<br/>\r\n\r\n위 컴포넌트를 엔티티에 등록한 후 콘솔을 확인한 결과는 다음과 같다.\r\n\r\n![](./result-script.png)\r\n\r\n\r\n\r\n## 네트워크의 이해\r\n\r\n> 멀티 플레이를 제공하는 게임의 경우 각 게임의 특성에 따라 사용되는 통신 모델들이 다양하다\r\n>\r\n> MOD는 다양한 통신 모델중 서버 - 클라이언트 모델을 사용하고 있다\r\n\r\n\r\n\r\n### 서버와 클라이언트\r\n\r\n#### 📌 클라이언트\r\n\r\n클라이언트는 유저들의 모바일이나 PC, 또는 해당 기기에서 개별적으로 돌아가는 프로그램을 의미한다. 주로 유저의 입력을 처리하거나 서버가 보내온 정보를 내부적으로 처리하여 유저에게 가시적으로 출력하는 역할을 수행한다.\r\n\r\n#### 📌 서버\r\n\r\n서버는 다수의 클라이언트가 연결된 단일 컴퓨터, 또는 해당 컴퓨터에서 돌아가는 프로그램을 의미한다. 일반적으로 각 클라이언트에서 보내온 요청에 대한 응답을 주기도 하지만, 게임 진행에 대한 주요 기능과 시스템을 서버에 구축함으로써 모든 클라이언트가 동일한 진행 상황이 될 수 있도록 할 수 있다.\r\n\r\n![](./server-client.png)\r\n\r\n> 클라이언트의 경우 유저가 해킹할 위험이 있다.\r\n>\r\n> 그렇기에 게임의 전반적인 로직과 시스템은 서버에서 구현하고 클라이언트는 유저의 입력을 받아 서버로 전달하거나, 게임 진행 상황을 내려받아 유저에게 전달하는 역할로 구조를 가져가는 것이 좋다\r\n\r\n<br/>\r\n\r\n\\# **클라이언트에서 주요 로직을 처리하는 구조 (비추천)** \r\n\r\n![](./client-mainlogic.png)\r\n\r\n\r\n\r\n\\# **서버에서 주요 로직을 처리하는 구조 (추천)**\r\n\r\n![](./server-mainlogic.png)\r\n\r\n\r\n\r\n### 서버, 클라이언트에서의 프로퍼티와 함수\r\n\r\n그럼 MOD 메이커에서 작성한 프로그램은 서버와 클라이언트에서 어떻게 작동할까?\r\n\r\n* 스크립트에서 선언한 프로퍼티와 함수는 별도의 설정을 하지 않는 한 서버와 클라이언트 두 개의 공간에 각각 독립적으로 생성된다\r\n* 이름은 같지만 서로 다른 공간에 존재하기 때문에 별도의 프로퍼티와 함수라고 보는 것이 좋다\r\n\r\n![](./independent-space.png)\r\n\r\n\r\n\r\n<br/>\r\n\r\n기본적으로 함수의 호출과 프로퍼티의 값 참조 및 할당은 같은 공간 내에서만 이루어진다\r\n\r\n예시를 봐보자!\r\n\r\n![](./method-property.png)\r\n\r\n`Method B`가 `Property A`에 값을 할당한다고 하자.\r\n\r\n* 서버에 있는 `Method B`는 서버의 `Property A`에만 값을 할당하고 클라이언트의 `Property A`에는 값을 할당하지 않는다.\r\n\r\n* 반대로 클라이언트의 `Method B`는 클라이언트의 `Property A`에만 값을 할당하고 서버의 `Property A`에는 값을 할당하지 않는다\r\n\r\n<br/>\r\n\r\n함수간 호출도 비슷하게 작동한다\r\n\r\n![](./method-method.png)\r\n\r\n\r\n\r\n### 동기화와 실행제어\r\n\r\n> 그렇다면 서버 - 클라이언트간 상호작용은 어떻게 할 수 있을까?\r\n>\r\n> MOD에서는 데이터 또는 상태를 전달하는 방식인 동기화와 특정 상황에 발생해야 할 행위, 행동들을 전달하는 방식인 실행제어를 제공하고 있다.\r\n\r\n\r\n\r\n#### 📌 동기화\r\n\r\nMOD에서의 동기화는 서버와 클라이언트 별도 공간에 있는 프로퍼티 값의 동기화를 의미한다. 예를 들어, 어느 한쪽의 프로퍼티 값이 변경되면, 자동으로 다른 한쪽의 프로퍼티 값도 동일하게 변경된다.\r\n\r\n![](./sync-prop.png)\r\n\r\n<br/>\r\n\r\n그렇다고 모든 프로퍼티가 동기화되는 것은 아니다.\r\n\r\n예를 들어, 주로 클라이언트에서만 작동하는 컴포넌트가 있다면 해당 컴포넌트는 서버로 데이터를 보낼 일이 없으니 서버로의 동기화가 일어나지 않는다.\r\n\r\n일반적으로 동기화는 서버에서 클라이언트 단방향으로 진행된다. 서버와 클라이언트의 관계가 일 대 다 관계이기 때문이다 .\r\n\r\n<br/>\r\n\r\n\\# **서버에서 클라이언트로 동기화**\r\n\r\n![](./sync1.png)\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n\\# **클라이언트에서 서버로 동기화**\r\n\r\n![](./sync2.png)\r\n\r\n\r\n\r\n\r\n\r\n#### 📌 실행제어\r\n\r\n서버와 클라이언트 간 통신에는 데이터의 전달, 즉 동기화 외에도 공간에 정의된 \"액션\"을 요청하고 수행하는 과정도 필요하다.\r\n\r\n> 위의 레벨업 처리 과정을 예시로 들면, 클라이언트가 유저의 입력을 받으면, 서버에게 \"몬스터 공격\"이라는 \"액션\"을 요청하게 되고, 서버는 클라이언트의 요청에 따라 \"몬스터 공격\"이라는 \"액션\"을 수행하게 된다.\r\n>\r\n> 이렇듯 각 공간에 정의된 액션을 서로 요청하여 수행케 하는 것을 실행제어라고 한다.\r\n\r\n<br/>\r\n\r\n\"액션\"은 스크립트의 \"함수\"로 정의할 수 있다. 스크립트에서 각 함수의 설정을 어떻게 하느냐에 따라 클라이언트에서 서버로 수행을 요청할 수도 있고, 반대로 서버에서 클라이언트로 수행을 요청할 수도 있다.\r\n\r\n<br/>\r\n\r\n예시를 봐보자!\r\n\r\n\\# **Method B의 실행 공간을 클라이어트, Method C의 실행 공간을 서버로 설정했을 때의 요청과 수행**\r\n\r\n![](./sync-action.png)\r\n\r\n<br/>\r\n\r\n위 상황을 예로 들면, 서버에서 선언된 함수 B의 실행 공간을 클라이언트로 설정하면, 함수 B는 서버 내 다른 함수에서 호출이 가능하지만, 클라이언트에서 실행되기 때문에 서버에서 호출할 수 있는 클라이언트 함수처럼 사용이 가능하다.\r\n\r\n<br/>\r\n\r\n실행제어의 종류는 다음과 같이 6개가 존재한다.\r\n\r\n![](./action-table.png)\r\n\r\n<br/>\r\n\r\n이처럼 동기화와 실행제어를 통해 서버와 클라이언트가 소통하게 할 수 있다!\r\n\r\n\r\n\r\n\r\n\r\n### 동기화와 실행제어 예시\r\n\r\n#### 📌 동기화 설정\r\n\r\n컴포넌트의 프로퍼티는 동기화 여부를 결정할 수 있다.\r\n\r\n아래 사진을 예시로 보면,\r\n\r\n프로퍼티 `sum`위에 `[Sync]`라고 되어있는데 이는 `sum`이 동기화되어있다는 의미이다.\r\n\r\n\\# **[Sync]**\r\n\r\n![](./change-sync-prop.png)\r\n\r\n<br/>\r\n\r\n`[Sync]` 부분을 클릭하면 `[None]`로 바뀌는데 이는 동기화되지 않음을 의미한다.\r\n\r\n![](./none-prop.png)\r\n\r\n\r\n\r\n#### 📌 실행제어 설정\r\n\r\n![](./action-table.png)\r\n\r\n\r\n\r\n\\# **서버에서 실행된 server 실행 제어 함수**\r\n\r\n![](./so-s.png)\r\n\r\n함수 `SetSum`이`server`함수이므로 `server`에서 바로 실행되는걸 볼 수 있다.\r\n\r\n`client`에서 실행된 `client` 함수도 이와 비슷하게 동작한다. (server에서 client로 바뀔 뿐)\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n\\# **서버에서 실행된 client 함수**\r\n\r\n![](./so-c.png)\r\n\r\n위 예시와 달리 `server only` 인 `OnBeginPlay`함수 내부의 코드가 전부 실행된 후, `SetSum`함수가 실행된 것을 볼 수 있다.\r\n\r\n즉, `SetSum`함수 자체는 `server`에서 호출되었으나  `client`로 넘어가 `client`에서 `SetSum` 함수가 실행되는 것이다.\r\n\r\n<br/>\r\n\r\n\\# **클라이언트에서 실행된 서버 함수**\r\n\r\n![](./co-s.png)\r\n\r\n앞의 예시와 비슷하게 이번에는  `Client`에서 `Server`함수인 `SetSum`이 호출되었기에 `Server`로 넘어가 `SetSum`이 실행되는 것을 볼 수 있다.\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n\r\n\r\n\\# **multicast**\r\n\r\n![](./so-multi.png)\r\n\r\n`multicast` 함수일 경우 `server`에서 호출되면 `server`에서 실행하고 이후 `client`에서도 실행하는 것을 볼 수 있다\r\n\r\n<br/>\r\n\r\n<br/>\r\n\r\n\\# **Function setting을 사용하지 않을 때**\r\n\r\n![](./no-no.png)\r\n\r\n`OnBeginPlay`함수는 Function setting을 설정하지 않았으므로 server와 client 두 곳에서 실행된다. `SetSum`함수도 Funtion setting을 하지않아 `OnBeginPlay`함수가 호출할 때 바로 실행된다.\r\n\r\n<br/>\r\n\r\n\\# **Function setting을 사용하지않는 함수에서 server함수 호출**\r\n\r\n![](./no-ser.png)\r\n\r\n`OnBeginPlay` 함수는 Function setting을 하지않아 서버와 클라이언트 두 곳에서 실행된다. 그러나 `SetSum`함수는 `server`로 세팅되어있기 때문에\r\n\r\n* `OnBeginPlay`가 서버에서 실행될 때는 바로 서버에서 같이 실행되고\r\n* `OnBeginPlay`가 클라이언트에서 실행될 때는 나중에 클라이언트에서 실행되는 것을 볼 수 있다.\r\n\r\n\r\n\r\n"},{"excerpt":"주퍼터에서 아래와 같이 작성하면 된다 os.environ'DJANGOSETTINGSMODULE' = 'projectname.settings'","fields":{"slug":"/jupyter-setting/"},"frontmatter":{"date":"May 27, 2022","title":"장고 shell 명령 주피터에서 할 때 초기세팅","tags":["django"]},"rawMarkdownBody":"\r\n주퍼터에서 아래와 같이 작성하면 된다\r\n\r\n```python\r\nimport os\r\n\r\n# 내 장고 프로젝트의 환경변수 로드\r\nos.environ['DJANGO_SETTINGS_MODULE'] = 'projectname.settings'\r\nimport django\r\ndjango.setup()\r\n\r\n```\r\n\r\n#### os.environ['DJANGO_SETTINGS_MODULE'] = 'projectname.settings'\r\n\r\n<br/>\r\n![](./wsgi.png)\r\n<br/>\r\nwsgi파일에서 서버가 시작될때마다 필요한 환경변수들을 자동으로 set해준다\r\n외부 스크립트에서 장고 프로젝트의 settings파일 위치를 가리키는 환경변수를 지정하고 `django.setup()`명령어로 장고 환경을 로드하면 장고 프로젝트의 구성 요소들을 외부 스크립트에서 사용할 수 있다\r\n\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"openssl설치 ssl 인증서를 발급받기 위해 필요 ubuntu 환경에서 설치했습니다  wget이 설치되지않은 사람은 wget설치  https://www.openssl.org/source/에 접속해서 openssl file에서 우클릭 누르고 링크 주소 복사한걸 wget으로 설치   다운받아진 openssl-1.1o.tar.gz 파일 압축해제 tar xv…","fields":{"slug":"/install-openssl/"},"frontmatter":{"date":"May 27, 2022","title":"ubuntu에서 openssl 설치하기","tags":["ssl"]},"rawMarkdownBody":"\r\n\r\n\r\n## openssl설치\r\n\r\n> ssl 인증서를 발급받기 위해 필요\r\n>\r\n> ubuntu 환경에서 설치했습니다\r\n\r\n* `sudo apt-get wget`\r\n  * wget이 설치되지않은 사람은 wget설치\r\n\r\n* `wget https://www.openssl.org/source/openssl-1.1.1o.tar.gz`\r\n\r\n  * https://www.openssl.org/source/에 접속해서 openssl file에서 우클릭 누르고 링크 주소 복사한걸 wget으로 설치\r\n\r\n    ![](./openssl-link.png)\r\n\r\n* `tar xvfz openssl-1.1o.tar.gz`\r\n  * 다운받아진 openssl-1.1o.tar.gz 파일 압축해제\r\n  * tar xvfz는 .tar.gz 파일을 압축 해제하는 명령어\r\n* `cd openssl1-1.1o`\r\n* `./config`\r\n  * default로 정적라이브러리로 컴파일되며 동적 라이브러리로 컴파일할 경우 \t`./config shared`\r\n* `apt-get install gcc make`\r\n  * make가 없다면 make를 다운받는다\r\n* `make`\r\n  * 컴파일 수행\r\n* `make test`\r\n* `sudo make install`\r\n\r\n이제 openssl을 사용할 수 있다!\r\n"},{"excerpt":"종합 설계 프로젝트 진행 중 팀원분에게 숙제를 받게 됨. \"SSL 인증서 발급받아오세요~\" 네! 그런데 SSL 인증서가... 뭐죠...? 응애개발자인 나는 SSL인증서가 뭔지 전혀 몰랐지만 4학년 주제에 그게 뭐죠? 하기에는 부끄러워 일단 \"넵! 해오겠습니다 ㅎㅎ;!\" 라고 대답을 하고 집에 돌아왔다... (나쁜 습관) 오늘도 일단 아는 척을 해버리고 나…","fields":{"slug":"/ssl-concept/"},"frontmatter":{"date":"May 27, 2022","title":"ssl 인증서란?","tags":["ssl"]},"rawMarkdownBody":"\r\n\r\n\r\n종합 설계 프로젝트 진행 중 팀원분에게 숙제를 받게 됨.\r\n\r\n> \"SSL 인증서 발급받아오세요~\"\r\n\r\n\r\n\r\n**네! 그런데 SSL 인증서가... 뭐죠...?**\r\n\r\n응애개발자인 나는 SSL인증서가 뭔지 전혀 몰랐지만 4학년 주제에 그게 뭐죠? 하기에는 부끄러워 일단 \"넵! 해오겠습니다 ㅎㅎ;!\" 라고 대답을 하고 집에 돌아왔다... *(나쁜 습관)*\r\n\r\n\r\n\r\n오늘도 일단 아는 척을 해버리고 나는 집에와서 구글링을 시작한다.\r\n\r\n\r\n\r\n## SSL이란?\r\n\r\n**(Secure Sockets Layer)**\r\n\r\n* 암호화 기반 인터넷 보안 프로토콜이며 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장한다\r\n* SSL을 사용하는 웹사이트의 URL에는 \"HTTP\" 대신 \"HTTPS\"가 있다\r\n\r\n![](./http-https.svg)\r\n\r\n### SSL/TLS란?\r\n\r\n* 네스케이프에 의해서 SSL이 발명되었고 이후 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. (즉, SSL의 이름이 TLS로 바뀐 것이다. TLS의 이전 버전이 SSL.)\r\n\r\n* TLS 1.0은 SSL 3.0을 계승한다\r\n* SSL은 SSL 3.0 이후 업데이트되지 않았으며 TLS가 최신 암호화 프로토콜이다\r\n* 그러나 SSL이라는 이름이 유명해서 공식적으로는 TLS 인증서지만 SSL 인증서라고 부르는 사람들이 더 많다\r\n\r\n\r\n\r\n### SSL 역할\r\n\r\n위에서 SSL은 개인정보 보호, 인증, 데이터 무결성을 보장한다고 했는데 좀 더 자세히 살펴보자!\r\n\r\n<br/>\r\n\r\n#### 🔑 암호화를 통해 사용자의 개인 정보 보호\r\n\r\n> 원래 웹 상의 데이터는 메시지를 가로채면 누구나 읽을 수 있는 일반 텍스트 형태로 전송됐다 ( 쇼핑몰에서 결제를 하기위해 신용 카드 번호를 입력하면 그 번호를 누가 읽을 수도 있는 것!)\r\n>\r\n> SSL은 위를 해결하고 사용자 개인 정보를 보호하기 위해 제작되었다\r\n>\r\n> SSL은 클라이언트와 웹 서버 사이를 이동하는 모든 데이터를 암호화하여 누군가 데이터를 가로채더라도 암호화된 데이터를 보게된다.\r\n>\r\n> SSL은 공개키와 대칭키를 혼합해서 암호화를 수행한다\r\n\r\n\r\n\r\n\r\n\r\n#### 🔑  핸드셰이크를 사용해 서버가 신뢰할 수 있는 서버인지 인증\r\n\r\n![](./tls-handshake.webp)\r\n\r\n> 클라이언트와 서버는 핸드셰이크 중에 메시지를 교환하여 서로를 인식하고, 검증하고, 암호화 알고리즘을 구성하고, 세션 키를 합의한다\r\n>\r\n> TLS 핸드셰이크는 TCP 핸드 셰이크를 통해 TCP 연결이 열린 후 발생한다\r\n\r\n서버 통신 과정을 순서대로 살펴보자!\r\n\r\n* 클라이언트가 서버에 접속 : Client Hello (이 단계에서 주고받는 정보는 아래와 같다)\r\n  * 클라이언트 측에서 생성한 랜덤 데이터\r\n  * 클라이언트가 지원하는 암호화 방식들\r\n  * 세션 아이디\r\n* 서버는 Client Hello에 대한 응답으로 Server Hello를 보낸다\r\n  * 서버 측에서 생성한 랜덤 데이터\r\n  * 서버가 선택한 클라이언트 암호화 방식\r\n  * 인증서\r\n* 클라이언트는 서버 인증서가 CA에 의해서 발급된 것인지를 확인하기위해 클라이언트에 내장된 CA리스트를 확인한다. \r\n  * 인증서가 CA에 의해서 발급된 것인지 확인하기위해 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다.\r\n  * 복호화가 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 보증되고 서버를 신뢰할 수 있다\r\n* 서버는 클라이언트는 master secret값을 공유하고 master secret을 사용해 세션 키를 생성한다. 서버와 클라이언트는 이 세션 키 값을 사용해서 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다\r\n\r\n\r\n\r\n* #### 디지털 서명을 사용해 데이터 무결성 제공\r\n\r\n  > 학교에서 학점때문에 컴퓨터 보안 강의들으면서 이거 근데 나중에 써먹을 날이 올까?... 했는데 써먹을 날이 와서 행복해짐\r\n\r\n\r\n\r\n\r\n\r\nSSL 인증서 발급받아오라는 말을 듣고 \"그게 뭐지...\" 하고 걱정했는데 https를 보고 아는거라 안심했다... \r\n\r\nhttps 는 http보다 보안이 강화됐다 정도로만 알고있었는데 이번 기회에 더 자세히 알게되었다  \r\n\r\n다음 포스트에서는  SSL 인증서를 직접 받아보겠다\r\n\r\n\r\n\r\n\r\n\r\n참고 사이트\r\n\r\nhttps://www.cloudflare.com/ko-kr/learning/ssl/what-is-ssl/\r\n\r\nhttps://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/\r\n\r\nhttps://opentutorials.org/course/228/4894\r\n\r\n"},{"excerpt":"docker에 환경변수 설정 danmer 서비스 배포시 aws 계정 비밀번호등이 담긴 환경변수가 필요한데 설정을 어떻게 해줘야할지 몰라서 이것 저것 찾던중 # docker-entrypoint.sh 아래와 같이 쓰면 환경변수 사용을 할 수 있다는 스택오버플로우 글을 발견함 -z 옵션은 환경변수 DJANGO_USERNAME의 length가 0이면 true, …","fields":{"slug":"/docker-env/"},"frontmatter":{"date":"May 26, 2022","title":"docker env설정(작성중ㅎㅎ)","tags":["docker"]},"rawMarkdownBody":"\r\n\r\n\r\n## docker에 환경변수 설정\r\n\r\n\r\n\r\n* danmer 서비스 배포시 aws 계정 비밀번호등이 담긴 환경변수가 필요한데 설정을 어떻게 해줘야할지 몰라서 이것 저것 찾던중\r\n\r\n\r\n\r\n\\# docker-entrypoint.sh\r\n\r\n```bash\r\nif [[-z \"${DJANGO_USERNAME}\"]];\r\nthen\r\n    python manage.py createsuperuser \\\r\n        --noinput \\\r\n        --username $DJANGO_USERNAME \\\r\n        --email $DJANGO_EMAIL \\\r\n        --password $DJANGO_PASSWORD\r\nfi\r\n\r\n$@\r\n\r\n```\r\n\r\n* 아래와 같이 쓰면 환경변수 사용을 할 수 있다는 스택오버플로우 글을 발견함\r\n*  -z 옵션은 환경변수 DJANGO_USERNAME의 length가 0이면 true, 아니면 false를 반환함\r\n  * -z외에 -n등 여러가지가 있음\r\n\r\n\r\n\r\n**그치만 이렇게 바로 해결이 될리가 없었다**\r\n\r\n* 근데 termius에서 컨테이너 생성 후 로그보니까 -z 명령어 같은건 없다고 수행못함\r\n* 여러 방법을 수행하던 중 김어쩌고씨에게서 아주 쉬운 방법을 배워버림(허무)\r\n\r\n> ```bash\r\n> docker run --env-file .env \r\n> ```\r\n>\r\n> .env파일 생성후 위 명령어도 실행해봤지만 오류남\r\n>\r\n> 어째서...?\r\n\r\n/+ 오류가 난 이유는 나중에 찾아서 추가할 예정\r\n\r\n\r\n\r\n### docker run -env\r\n\r\n바로 docker run을 할 때 -env 옵션을 줘서 환경변수 설정을 해주면 된다...\r\n\r\nex)\r\n\r\n```bash\r\ndocker run -d -e  DJANGO_USERNAME=myname -e DJANGO_PASSWORD=mypw\r\n```\r\n\r\n* 하나하나 설정해줘야한다는 단점이 있지만 굉장히 쉬운 방법이었다.\r\n* 더 효율적인 방법이 분명 존재할것이므로 더 탐구해볼예정"},{"excerpt":"멋쟁이 사자처럼 X 넥슨 MOD의 2주차 교육 내용을 정리하는 포스트입니다. 자주 쓰이는 Component TransformComponent entity들이 어디에 위치하는가 entity의 위치, 크기, 회전등을 결정할 수 있다 SpriteRendererComponent Sprite : 2D 이미지를 뜻함 entity가 어떻게 그려질지를 정함 entity…","fields":{"slug":"/2-component-basic/"},"frontmatter":{"date":"May 21, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 2주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n<br/>\r\n\r\n멋쟁이 사자처럼 X 넥슨 MOD의 2주차 교육 내용을 정리하는 포스트입니다.\r\n\r\n<br/>\r\n\r\n\r\n\r\n## 자주 쓰이는 Component\r\n\r\n### TransformComponent\r\n\r\n> entity들이 어디에 위치하는가\r\n>\r\n> entity의 위치, 크기, 회전등을 결정할 수 있다\r\n\r\n\r\n\r\n### SpriteRendererComponent\r\n\r\n> Sprite : 2D 이미지를 뜻함\r\n>\r\n> entity가 어떻게 그려질지를 정함\r\n>\r\n> entity의 색상, 레이어, 프레임등을 결정할 수 있다\r\n\r\n* 스프라이트마다 고유한 RUID 값을 가지고 있다\r\n* RUID 값을 이용해 빈 모델에 스프라이트를 넣거나 변경할 수 있다\r\n\r\n\r\n\r\n### TweenComponet\r\n\r\n> entity의 움직임을 결정한다\r\n>\r\n> * TweenLineComponent : 원점에서 목적지까지 선형운동\r\n> * TweenFloatingComponent : 원점을 기준으로 부유운동\r\n> * TweenCircularComponent : 원점을 중심으로 원운동\r\n\r\n\r\n\r\n## 맵 레이어\r\n\r\n* 하나의 맵에 최대 10개의 레이어 사용 가능\r\n* 레이어 창 가장 아래에 깔린 레이어가 맵 화면에서 가장 뒤에 위치하게 되고, 맨 위에 있는 레이어가 가장 앞에 배치된다\r\n* 레이어에 배치된 엔티티들은 레이어 순서에 일괄적으로 영향을 받습니다. 가장 아래 있던 레이어를 위로 올리는 순간, 엔티티의 순서가 함께 변경된다\r\n\r\n\r\n\r\n### 레이어 우선순위 \r\n\r\n1. Map Layer (SpriteRendererComponent의 SortingLayer)\r\n2. SpriteRenderer Component의 OrderInLayer 프로퍼티\r\n3. Transform Component의 Position Z값\r\n\r\n\r\n\r\n### 모델의 레이어 순서\r\n\r\n> 모델은 배치 편의를 위해 유형별로 OrderInLayer 기본값이 존재한다\r\n\r\n![](./orderinlayer.png)\r\n\r\n\r\n\r\n| OrderInLayer 값 | 모델 유형                                           |\r\n| --------------- | --------------------------------------------------- |\r\n| 0               | 오브젝트                                            |\r\n| 1               | 타일                                                |\r\n| 2               | 몬스터, NPC, 발판, 사다리, 로프, 포탈, 트랩, 아이템 |\r\n| 3               | 타 이용자의 아바타                                  |\r\n| 4               | 나의 아바타                                         |\r\n\r\n\r\n\r\n\r\n\r\n## 발판 만들기\r\n\r\n#### 발판\r\n\r\n* 캐릭터가 오를 수 있는, 밟을 수 있는 타일을 표시\r\n\r\n* 세팅 -> 만들기 -> 발판\r\n\r\n* Foothold가 있는 모델들은 `우클릭` -> `edit foothold` 를 사용해 풋홀드 위치를 변경할 수 있음\r\n* `CustomFootholdComponent`를 사용해 Foothold가 없는 모델에도 발판을 생성할 수 있다\r\n\r\n* 마찰력 속도등 풋홀드 속성이 존재한다\r\n\r\n\r\n\r\n## 충돌 감지\r\n\r\n* HitComponent : 피격의 범위를 설정\r\n* TriggerComponent : 충돌이 일어나는 범위를 설정\r\n\r\n\r\n\r\n### 충돌 이벤트 생성 방법\r\n\r\n* TriggerComponent를 사용해 충돌의 범위를 설정한다\r\n* 핸들러를 만들어서 충돌시 액션을 정의한다\r\n* 액션을 수행할 핸들러를 Entity에 등록한다\r\n\r\n> 위 절차를 통해 TriggerComponent를 통해 이벤트가 발생하면 핸들러로 등록한 함수가 호출되 충돌시 액션을 수행한다!\r\n\r\n![](./triggersystem.png)\r\n\r\n\r\n\r\n### 핸들러 생성\r\n\r\n* 핸들러는 리액터가 되는 스크립트 컴포넌트의 Entity Event Handler를 통해 추가할 수 있다\r\n\r\n* 액션을 수행할 스크립트 컴포넌트를 열고, Entity Event Handler의 우측 버튼을 눌러 핸들러 추가 메뉴를 오픈한다\r\n\r\n​\t<br/>![](./add_handler.png)\r\n\r\n<br/>\r\n\r\n* 충돌 이벤트에 대한 핸들러를 생성하기위해 Trigger관련 Event를 추가한다\r\n* 검색창을 이용해 편리하게 이벤트를 찾을 수 있다\r\n\r\n<br/>\r\n\r\n![](./search_event.png)\r\n\r\n| Event             | 발생 시점               |\r\n| ----------------- | ----------------------- |\r\n| TriggerEnterEvent | 충돌이 처음 발생했을 때 |\r\n| TriggerStayEvent  | 충돌이 일어나는 중일 때 |\r\n| TriggerLeaveEvent | 충돌이 끝났을 때        |\r\n\r\n\r\n\r\n*다음은 충돌시 hp가 하락하는 이벤트이다*\r\n\r\n![](./hp_event.png)\r\n\r\n상단의 `self`는 sender를 등록할 entity를 설정할 수 있다\r\n\r\n리액터 컴포넌트가 추가된 entity의 충돌 이벤트를 받는다면 self를,\r\n\r\n다른 외부 entity의 충돌 이벤트를 받는다면 `self`를 눌러`Entity`를 선택한 후 해당 entity로 바꿔주면된다\r\n"},{"excerpt":"멋쟁이 사자처럼 X 넥슨 MOD의 1주차 교육 내용을 정리하는 포스트입니다. Entity  맵을 구성하고있는 요소들 ex) npc, monster, tree object 등 아래 빨간 네모 박스안에 있는 것들이 전부 Entity  entity는 여러 개의 component로 구성되어있다 Scene Maker에서 관리 가능 Component 기능의 단위들 …","fields":{"slug":"/1-mod-concept/"},"frontmatter":{"date":"May 20, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 1주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n<br/>\r\n\r\n멋쟁이 사자처럼 X 넥슨 MOD의 1주차 교육 내용을 정리하는 포스트입니다.\r\n\r\n<br/>\r\n\r\n## Entity\r\n\r\n>  맵을 구성하고있는 요소들\r\n>\r\n> ex) npc, monster, tree object 등\r\n\r\n<br/>\r\n\r\n*아래 빨간 네모 박스안에 있는 것들이 전부 Entity*\r\n\r\n![](./entity.png)\r\n\r\n* entity는 여러 개의 component로 구성되어있다\r\n\r\n- Scene Maker에서 관리 가능\r\n\r\n\r\n\r\n## Component\r\n\r\n**기능의 단위들**\r\n\r\n* Entity는 Component들로 구성되어 있다 \r\n* Component들의 집합체를 Entity라고 볼 수 있다\r\n* Component는 각각의 요소를 담당하고 있으며 각각의 기능을 담당한다\r\n\r\nex)\r\n\r\n>* TransformComponent : entity의 위치, 회전 각도등을 결정함\r\n>* SpriteRendererComponent : entity를 어떻게 보여줄 것인지를 결정함\r\n>  * entity의 색상\r\n>  * entity가 속한 Layer\r\n>  * 움직이는 애니메이션 객체일 경우 Frame 수, 재생 속도등을 결정\r\n\r\n\r\n\r\n## Property\r\n\r\n> 컴포넌트 내에 있는 세부적인 정보, 고유 특성을 정의한다\r\n\r\n*아래는 ChatBalloonComponent의 Property들이다*\r\n\r\n![](./property.png)\r\n\r\n* 말풍선의 기능을 가진 `ChatBalloonComponent`의 Property `FontSize`를 조정해 말풍선안의 폰트 크기를 높인다\r\n\r\n\r\n\r\n## Model\r\n\r\n<p>\r\n    <img src =\"./model_list.png\" style= \"float:left; margin-right: 50px; margin-top : 10px\"/>\r\n</p>\r\n\r\nentity를 생성할 수 있는 원본\r\n\r\nMOD 메이커를 실행한 뒤 좌측 Model List 패널에서 확인할 수 있다.\r\n\r\nModel List에 있는 model object 가져와 entity로 만들어 맵을 꾸밀 수 있다\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Work Space\r\n\r\n파일탐색기와 비슷한 기능\r\n\r\n모델, 스크립트 파일, 컴포넌트등을 관리\r\n\r\nScene에서 사용된 컴포넌트들의 원본이 저장됨\r\n\r\n\r\n\r\n## Scene Maker\r\n\r\n- 씬 메이커는 계층구조로 되어있다\r\n\r\n- 부모 오브젝트를 움직이면 자식 오브젝트도 같이 움직인다\r\n\r\n- 씬 메이커에서 자식은 부모의 특성을 물려받는다\r\n\r\n- 자식의 특성보다 부모의 특성이 우선시 된다\r\n\r\n  - ex) 자식은 visible이지만 부모가 invisible이라면 자식또한 invisible한 상태가 된다\r\n\r\n- 현재 Scene에서 사용한 모든 오브젝트들을 볼 수 있음\r\n\r\n  `Make Original Model` 기능을 통해 원본 오브젝트에서 크기등이 변경된 오브젝트를 변경된 형태로 Workspace에 저장할 수 있음\r\n\r\n  -> 만들어진 엔티티를 모델로 생성\r\n\r\nModserivice : 재가공 불가능 Core한 서비스\r\n\r\nModlogic : 재가공 가능. 유저가 생성 가능\r\n\r\n\r\n\r\n## 기본 조작\r\n\r\n- 프로젝트 출시\r\n\r\n  `File` -> `Publish`\r\n\r\n- 프로젝트 버전 기록 및 관리\r\n\r\n `File` -> `Revisions`\r\n\r\n- 패널 세팅 초기화\r\n\r\n `Panel` -> `Reset Panels`\r\n\r\n- Map 리스트 보기 및 관리\r\n\r\n  `Window` -> `Map list`\r\n\r\n- 메이플스토리 맵 불러오기\r\n\r\n  `Window` -> `MapleStory Map`\r\n\r\n- 스크립트 샘플 다운로드\r\n\r\n  `Window` -> `Script Manager`\r\n\r\n수직으로 생성된 타일은 캐릭터가 올라갈 수 없다\r\n\r\n하나의 레이어에서는 하나의 타일만 사용가능하다\r\n\r\n여러 개의 타일을 사용하고싶다면 Map Layer를 추가해야함\r\n\r\nMap Layer란의 상위 레이어가 Scene의 가장 앞에 배치된다\r\n\r\n배치 순서는 Property -> SpriteRendererComponent -> OrderLayer에서 설정가능\r\n\r\n- 사용자 정의 오브젝트 그룹 생성\r\n\r\n `Object` -> `새 그룹 추가`\r\n\r\n\r\n\r\n"},{"excerpt":"docker란  어떤 서비스를 개발할 때 필요한 패키지, 라이브러리들을 다른 서버에서 재설치를 하지않고 충돌없이 사용할 수 있게 해주는 서비스 docker image 리눅스 환경에서 사용가능한 패키지, 라이브러리들을 컴퓨터로 다운받을 수 있게 저장해둔 것 docker component docker image를 가지고 컴퓨터에 생성한 독립적인 작업 공간 를…","fields":{"slug":"/docker-concept/"},"frontmatter":{"date":"May 17, 2022","title":"docker 개념","tags":["docker"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n## docker란\r\n\r\n>  어떤 서비스를 개발할 때 필요한 패키지, 라이브러리들을 다른 서버에서 재설치를 하지않고 충돌없이 사용할 수 있게 해주는 서비스\r\n\r\n\r\n\r\n### docker image\r\n\r\n> 리눅스 환경에서 사용가능한 패키지, 라이브러리들을 컴퓨터로 다운받을 수 있게 저장해둔 것\r\n\r\n\r\n\r\n### docker component\r\n\r\n> docker image를 가지고 컴퓨터에 생성한 독립적인 작업 공간\r\n\r\n`docker image`를 가지고 여러 개의 `component`를 생성할 수 있다\r\n\r\n\r\n\r\n### docker volume\r\n\r\n> 컨테이너와 내 컴퓨터의 특정 폴더를 공유하는걸 의미\r\n\r\n\r\n\r\n### docker compose\r\n\r\n> 각각의 component들을 하나로 묶음\r\n\r\n\r\n\r\n### 간단한 docker 실습\r\n\r\n#### docker 기본 명령어\r\n\r\n* 도커 버전 확인\r\n\r\n```bash\r\ndocker -v\r\n```\r\n\r\n\r\n\r\n* 도커 이미지 다운만 받기\r\n\r\n```bash\r\ndocker pull {img_name}:{tag}\r\n# 태그는 필수 요소가 아님\r\n```\r\n\r\n\r\n\r\n* 컴퓨터 내 도커 이미지들 보기\r\n\r\n```bash\r\ndocker images\r\n```\r\n\r\n\r\n\r\n* 이미지로 컨테이너 생성하기\r\n\r\n```bash\r\ndocker create {option} {img_name}:{tag}\r\n# ex) docker crate -it python\r\n```\r\n\r\n\r\n\r\n* 만들어진 컨테이너 시작하기 (이미지에 CMD로 지정해놓은 작업 시키기)\r\n\r\n```bash\r\ndocker start {container_id or name}\r\n```\r\n\r\n\r\n\r\n* 컨테이너로 들어가기 (컨테이너 내 CLI 이용하기)\r\n\r\n```bash\r\ndocker attach {container_id or name}\r\n```\r\n\r\n\r\n\r\n* (해당 이미지가 없다면) 이미지를 다운받아 바로 컨테이너 실행하여 진입하기\r\n\r\n```bash\r\ndocker run {img_name}:{tag}\r\n# ex) docker -it run python:3\r\n# pull, create, start, attach를 한 번에 실행하는 것과 같다\r\n```\r\n\r\n* 환경변수 선언\r\n\r\n  ```bash\r\n  # -e 옵션 사용\r\n  \r\n  docker run -it -p 8000:8000 -d -e ACCESS_KEY = 1234 -3 SECRET_ACCESS_KEY = abcd\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n| 옵션                                  | 설명                                                         |\r\n| :------------------------------------ | ------------------------------------------------------------ |\r\n| -d                                    | 데몬으로 실행(백그라운드에서 알아서 돌라고 하기)             |\r\n| -it                                   | 컨테이너로 들어갔을 때 bash로 CLI 입출력을 사용할 수 있도록 해줌 |\r\n| --name {container_name}               | 컨테이너 이름 지정                                           |\r\n| -p {port of host}:{port of container} | 호스트와 컨테이너의 포트를 연결                              |\r\n| --rm                                  | 컨테이너가 종료되면 컨테이너 제거                            |\r\n| -v {dir of host}:{dir of container}   | 호스트와 컨테이너의 디렉토리를 연결                          |\r\n| -e                                    | 환경변수설정 ex) docker run -e ACCESS_KEY = 1234 -e SECRET_ACCESS_KEY = abcd |\r\n\r\n\r\n\r\n* 동작중인 컨테이너 재시작\r\n\r\n```bash\r\ndocker restart {container_id or name}\r\n```\r\n\r\n\r\n\r\n* 도커 컨테이너 내부 쉘에서 빠져나오기 (컨테이너를 종료)\r\n\r\n```bash\r\nexit\r\n# 또는  ctrl + d\r\n```\r\n\r\n\r\n\r\n* 도커 컨테이너 내부 쉘에서 빠져나오기 (컨테이너를 종료하지 않음)\r\n\r\n  * ctrl + P + Q\r\n\r\n    \r\n\r\n* 동작중인 컨테이너 목록보기\r\n\r\n```bash\r\ndocker ps\r\n# 동작하지않는 컨테이너까지 모두 보려면 docker ps -a\r\n```\r\n\r\n\r\n\r\n* 컨테이너 삭제\r\n\r\n```bash\r\ndocker rm {container_id or name}\r\n\r\n# 모든 컨테이너 삭제\r\n# docker rm `docker ps -a -q`\r\n# 실해중인 컨테이너가 있다면 stop사용\r\n# ex\r\ndocker stop {cid} && docker rm {cid}\r\n```\r\n\r\n\r\n\r\n* 이미지 삭제\r\n\r\n```bash\r\ndocker rm {option} {img_id}\r\n# 컨테이너가 있을시 강제 삭제 : 옵션 -f 사용\r\n\r\n```\r\n\r\n\r\n\r\n* 모든 컨테이너와 이미지 등 도커 요소 중지 및 삭제\r\n\r\n```bash\r\n# 모든 컨테이너 중지\r\ndocker stop $(docker ps -aq)\r\n\r\n# 사용되지 않는 모든 도커 요소(컨테이너, 이미지, 네트워크, 볼륨 등) 삭제\r\ndocker system prune -a\r\n```\r\n\r\n\r\n\r\n* 특정 컨테이너에 명령어 실행\r\n\r\n```bash\r\ndocker exec -opt {c_id} cmd \r\n\r\n# ex\r\n# 도커 컨테이너 내부에서 bash shell 실행\r\ndocker exec -it {c_id} bash\r\n\r\n# 도커 컨테이너가 장고프로젝트일 경우 아래와 같은 명령어 사용도 가능\r\ndocker exec -it {c_id} python manage.py createsuperuser\r\n```\r\n\r\n\r\n\r\n\r\n\r\n* 도커 파일로 이미지 생성\r\n\r\n```bash\r\n# Dockerfile 파일이 있는 디렉토리 기준.  마지막의 . 이 상대주소\r\ndocker build -t {이미지명} .\r\n```\r\n\r\n\r\n\r\n* 도커 컴포즈 실행\r\n\r\n```bash\r\n# docker-compose 파일이 있는 디렉토리 기준\r\ndocker-compose up\r\n# 백그라운드에서 데몬으로 돌게 하려면 옵션 -d를 붙임\r\n```\r\n\r\n\r\n\r\n#### Dockerfile\r\n\r\n\r\n\r\n* \r\n\r\n"},{"excerpt":"PM2란? 무중단 서버 실행 멀티스레딩 Daemon Process Manager 보통 Node.js 와 같이 사용되며 Node.js 어플리케이션을 쉽게 관리할 수 있게 해주는 Process Manager이다 Node.js 어플리케이션은 단일 CPU 코어에서 실행되기 때문에 CPU의 멀티코어 시스템은 사용할 수 없다 때문에 Node.js는 클러스터 모듈을 …","fields":{"slug":"/pm2/"},"frontmatter":{"date":"May 16, 2022","title":"django에서 pm2 사용하기","tags":["deploy"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n## PM2란?\r\n\r\n* 무중단 서버 실행\r\n* 멀티스레딩\r\n\r\n**Daemon Process Manager**\r\n\r\n> 보통 Node.js 와 같이 사용되며 Node.js 어플리케이션을 쉽게 관리할 수 있게 해주는 Process Manager이다\r\n>\r\n> Node.js 어플리케이션은 단일 CPU 코어에서 실행되기 때문에 CPU의 멀티코어 시스템은 사용할 수 없다\r\n>\r\n> 때문에 Node.js는 클러스터 모듈을 통해 단일 프로세스를 멀티 프로세스로 늘릴 수 있는 방법을 제공한다\r\n>\r\n> 유저는 클러스터 모듈을 사용해 마스터 프로세스에서 워커 프로세스를 생성할 수 있다\r\n>\r\n> 이를 도와주는 것이 PM2이며 PM2를 사용해 하이퍼 스레딩 및 무중단 서비스 제공이 가능해진다 \r\n\r\nPM2를 Django 프로젝트에서 사용해보자!\r\n\r\n\r\n\r\n#### 🔨 node 설치\r\n\r\n```idl\r\n$ sudo apt install nodejs\r\n```\r\n\r\n\r\n\r\n#### 🔨 npm 설치\r\n\r\n```idl\r\n$ sudo apt install npm\r\n# $ sudo npm install npm@latest -g\r\n```\r\n\r\n\r\n\r\n#### 🔨 pm2 설치\r\n\r\n```idl\r\n$ sudo npm install pm2 -g\r\n```\r\n\r\n\r\n\r\n#### 🔨 프로젝트 하위에 json 파일 생성 및 작성\r\n\r\n```idl\r\n$ vim pm2-appname.json\r\n```\r\n\r\n\r\n\r\n\\# project/pm2-appname.json\r\n\r\n```json\r\n{ \"apps\": \r\n \t[\r\n        { \"name\": \"djnago_with_pm2\", \r\n         \"script\": \"manage.py\", \r\n         \"args\": [\"runserver\", \"0.0.0.0:8000\"],\r\n         \"exec_mode\": \"fork\", \r\n         \"exec_interpreter\" : \"python\" }\r\n    ] \r\n}\r\n```\r\n\r\n* args 에는 django 프로젝트를 배포할 때 쓰는 명령어 args를 넣는다\r\n\r\n\r\n\r\n#### 🔨 pm2 start\r\n\r\n```idl\r\n$ pm2 start pm2-appname.json\r\n```\r\n\r\n* 작성한 json파일을 실행\r\n\r\n![](./pc2list.png)\r\n\r\n> * pm2 stop all : 모든 서버 중지\r\n> * pm2 stop {pid} : 해당 pid 서버 중지\r\n\r\n"},{"excerpt":"termius에서 git clone {repo_name} 중 git access tokens 문제 발생 원래 id와 pw를 치고 인증하는데 pw가 아니라 access token을 입력하는 방법으로 바뀜 Access token 발급 방법 github > settings 메뉴의 가장 아래에 있는  클릭 메뉴의 Personal access tokens 클릭해서…","fields":{"slug":"/access-token/"},"frontmatter":{"date":"May 16, 2022","title":"git access token 발급 잔디 테스트","tags":["git"]},"rawMarkdownBody":"\r\n- termius에서 git clone {repo_name} 중 git access tokens 문제 발생\r\n- 원래 id와 pw를 치고 인증하는데 pw가 아니라 access token을 입력하는 방법으로 바뀜\r\n\r\n## Access token 발급 방법\r\n\r\n1. github > settings\r\n\r\n2. 메뉴의 가장 아래에 있는 `Developer settings` 클릭\r\n\r\n3. 메뉴의 Personal access tokens 클릭해서 token 생성\r\n\r\n4. 생성한 후 보여주는 token값을 저장해서 github인증시 pw대신 token을 입력하면 성공!\r\n\r\n   > token값은 처음 생성할 때 한 번만 보여주므로 주의\r\n   >\r\n   > 물론 까먹어도 다시 발급하면됨\r\n"},{"excerpt":"Python 라이브러리 requests method 4가지에 따라 api 제공 GET : requests.get() POST : requests.post() PUT : requests.put() DELETE : requests.delete() status_code content text json() headers params get 방식으로 HTTP 요청…","fields":{"slug":"/requests/"},"frontmatter":{"date":"May 16, 2022","title":"python 라이브러리 requests","tags":["python"]},"rawMarkdownBody":"\r\n\r\n\r\n## Python 라이브러리 requests\r\n\r\nmethod 4가지에 따라 api 제공\r\n\r\n* GET : requests.get()\r\n* POST : requests.post()\r\n* PUT : requests.put()\r\n* DELETE : requests.delete()\r\n\r\n\r\n\r\n### status_code\r\n\r\n```python\r\nresponse = requests.get(\"http://localhost:8000\")\r\nresponse.status_code # 200, 404 ...\r\n```\r\n\r\n\r\n\r\n### content\r\n\r\n```python\r\nresponse.content\r\n# 바이너리 원문을 가져옴\r\n```\r\n\r\n\r\n\r\n### text\r\n\r\n```py\r\nresponse.text\r\n# UTF-8로 인코딩된 문자열\r\n```\r\n\r\n\r\n\r\n### json()\r\n\r\n```py\r\nresponse.json()\r\n# 응답 데이터가 JSON포맷이라면 딕셔너리 객체 반환\r\n```\r\n\r\n\r\n\r\n### headers\r\n\r\n```python\r\nresponse.headers\r\n# {'Date': 'Sat, 16 May 2022 21:10:49 GMT', 'Content-Type': 'application/json; charset=utf-8', ...}\r\n# 헤더 정보를 딕셔너리 객체로 반환\r\n```\r\n\r\n\r\n\r\n### params\r\n\r\n* get 방식으로 HTTP 요청을 할 때는 쿼리 스트링을 통해 응답받을 데이터를 필터링하는 경우가 많다\r\n* params 옵션을 사용하면 쿼리 스트링을 사전의 형태로 넘길 수 있다\r\n\r\n\\# youtube data api 예제\r\n\r\n```python\r\nparams = {\r\n    \"key\": \"my_secret_key\",\r\n    'chart': 'mostPopular',\r\n    \"part\": [\"snippet\", \"statistics\"],\r\n    \"regionCode\" : \"KR\",\r\n    \"maxResults\": 10,\r\n}\r\n\r\nresponse = requests.get(url, params=params)\r\n```\r\n\r\n\r\n\r\n### url\r\n\r\n```py\r\nparams = {\r\n    \"key\": \"my_secret_key\",\r\n    'chart': 'mostPopular',\r\n    \"part\": [\"snippet\", \"statistics\"],\r\n    \"regionCode\" : \"KR\",\r\n    \"maxResults\": 10,\r\n}\r\n\r\nresponse = requests.get(url, params=params)\r\nresponse.url\r\n# https://www.googleapis.com/youtube/v3/videos?key={my_secret_key}&chart=mostPopular&part=snippet&part=statistics&regionCode=KR&maxResults=10\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### data\r\n\r\n* post나 put방식으로 HTTP 요청을 할 때는 request body에 데이터를 담아서 보낸다\r\n* data 옵션을 사용하면 `HTML 양식(form)` 포맷의 데이터를 전송할 수 있으며 이 때 `Content-Type` 요청 헤더는 `application/x-www-form-urlencoded`로 자동 설정된다\r\n\r\n```py\r\nrequests.post(\"https://localhost:8000/post\", data={'title': 'title1', 'text':'hi~'})\r\n```\r\n\r\n\r\n\r\n### json\r\n\r\n* json 옵션을 사용하면 REST API로 `JSON` 포맷의 데이터를 전송할 수 있으며 이때 `Content-Type` 요청 헤더는 `application/json`으로 자동 설정된다\r\n\r\n```py\r\nrequests.post(\"https://localhost:8000/post\", json={'title': 'title1', 'text':'hi~'})\r\n```\r\n\r\n\r\n\r\n### headers\r\n\r\n* headers옵션을 사용해서 요청 헤더도 설정할 수 있다\r\n* 인증 토큰을 보낼 때 유용하게 사용된다\r\n"},{"excerpt":"Viewset url등록 메소드별로 수동으로 지정 router 사용 메소드별로 수동 지정 as_view에 인자를 넣어 설정한다 urls.py 이처럼 메소드별로 수동으로 지정할 수 있다 viewset에서 제공하는 기능 create retrieve update partial_update destroy list router 사용 의  url은 으로 연결된다 의…","fields":{"slug":"/viewset-url/"},"frontmatter":{"date":"May 16, 2022","title":"viewset url 등록","tags":["django","DRF"]},"rawMarkdownBody":"\r\n\r\n\r\n## Viewset url등록\r\n\r\n* 메소드별로 수동으로 지정\r\n* router 사용\r\n\r\n\r\n\r\n#### 메소드별로 수동 지정\r\n\r\n* as_view에 인자를 넣어 설정한다\r\n\r\n#urls.py\r\n\r\n```python\r\nfrom . import views\r\n\r\ntutor_list = views.TutorVideoViewSet.as_view({'get' : 'list'})\r\n# get 요청이 오면 viewset의 list함수 실행\r\n\r\ntutor_detail = views.TutorVideoViewSet.as_view({'get':'retrieve'})\r\n# get 요청이 오면 view set의 retrieve 함수 실행\r\n\r\nurlpatterns = [\r\n    path('tutor/', tutor_list, name = 'tutor_list'),\r\n    path('tutor/<int:pk>/', tutor_detail, name = 'tutor_detail')\r\n]\r\n```\r\n\r\n이처럼 메소드별로 수동으로 지정할 수 있다\r\n\r\n> viewset에서 제공하는 기능\r\n>\r\n> * create\r\n> * retrieve\r\n> * update\r\n> * partial_update\r\n> * destroy\r\n> * list\r\n\r\n\r\n\r\n#### router 사용\r\n\r\n```python\r\nfrom rest_framework import routers\r\n\r\nrouter = routers.DefaultRouter()\r\nrouter.register('dancing',views.TutorVideoViewSet)\r\nrouter.register('practice',views.TuteeVideoViewSet)\r\n\r\nurlpatterns = [\r\n    path('',include(router.urls)),\r\n]\r\n```\r\n\r\n* `TutorVideoViewSet`의  url은 `~/dancing`으로 연결된다\r\n* `TuteeVideoViewSet`의 url은 `~/practice`로 연결된다\r\n\r\n"},{"excerpt":"중첩 사용 list comprehension vs zip","fields":{"slug":"/list-comprehension/"},"frontmatter":{"date":"May 12, 2022","title":"list comprehension","tags":["python"]},"rawMarkdownBody":"\r\n## 중첩 사용\r\n\r\n```python\r\ntemp = [i*j for i in range(1,4) for j in range(1,5)]\r\n\r\ntemp = []\r\nfor i in range(1,4):\r\n    for j in range(1,5):\r\n        temp.append(i*j)\r\n```\r\n\r\n## list comprehension vs zip\r\n\r\n```python\r\ntarget = [0.6, 0.8, 0.5]\r\nactual = [0.726, 0.708, 0.778]\r\n\r\nprint([target[i]-actual[i] for i in range (len(target))])\r\nprint([x-y for x,y in zip(target, actual)])\r\n```\r\n"},{"excerpt":"zip iterable 자료형의 요소를 순서대로 묶어서 새로운 iterable 자료형을 생성한다. iterable : 문자열, 리스트, 튜플과 같이 반복 가능한 자료형 조건 : 요소 개수가 같아야 함 class 'zip'을 바로 print할 수 없고 dict이나 list등으로 형변환을 시켜서 출력한다 # zip으로 list생성 # zip으로 dict생성","fields":{"slug":"/zip/"},"frontmatter":{"date":"May 12, 2022","title":"zip","tags":["python"]},"rawMarkdownBody":"\r\n## zip\r\n\r\n- iterable 자료형의 요소를 순서대로 묶어서 새로운 iterable 자료형을 생성한다.\r\n\r\n  > iterable : 문자열, 리스트, 튜플과 같이 반복 가능한 자료형\r\n\r\n- 조건 : 요소 개수가 같아야 함\r\n\r\n- class 'zip'을 바로 print할 수 없고 dict이나 list등으로 형변환을 시켜서 출력한다\r\n\r\n\\# zip으로 list생성\r\n\r\n```python\r\norder =\"123\"\r\nanimals = ['lion','cat','dog']\r\nfruit = ['mandarin','strawberry','apple']\r\nzip_list = zip(order, animals, fruits)\r\nprint(list(zip_list))\r\n```\r\n\r\n\\# zip으로 dict생성\r\n\r\n```python\r\norder = \"123\"\r\nanimals = ['lion', 'cat', 'dog']\r\nzip_dict = zip(order, animals)\r\nprint(dict(zip_dict))\r\n```\r\n"},{"excerpt":"mutual exclusion을 방지하려면? 현실적이지않음 mutual exclusion이 필요해서 하는건데... no preemption 이것도 현실적으로 쉽지않음 no hold and wait 원래는 다른애가 가지고 있으면 무한정 기다려야하는데 한꺼번에 획득하면 기다릴일이 없음 아예 가져가거나 못가져가거나 atomic한듯 no circular wait…","fields":{"slug":"/11-2/"},"frontmatter":{"date":"May 11, 2022","title":"os 11-2","tags":["OS"]},"rawMarkdownBody":"\r\n#### mutual exclusion을 방지하려면?\r\n\r\n현실적이지않음\r\n\r\nmutual exclusion이 필요해서 하는건데...\r\n\r\n#### no preemption\r\n\r\n이것도 현실적으로 쉽지않음\r\n\r\n#### no hold and wait\r\n\r\n원래는 다른애가 가지고 있으면 무한정 기다려야하는데\r\n\r\n한꺼번에 획득하면 기다릴일이 없음\r\n\r\n아예 가져가거나 못가져가거나\r\n\r\natomic한듯\r\n\r\n#### no circular wait\r\n\r\ncircular wait를 만들지않으려면 모든 리소스에 번호를 부여\r\n\r\n리소스를 할당받을 때 낮은 번호의 리소스부터 할당받게한다\r\n\r\n누군가가 높은 번호를 가진 상태에서 낮은 번호를 요구할 일이 없음. 모든 리소스 할당이 낮은 순서부터되기때문에 아예 할당을 못받거나 순차적으로 할당을 받거나\r\n\r\n자연스럽게 circular wait이 해결된다\r\n\r\n모든 프로세스들은 순서에 맞춰서 리소스를 할당받는다 근데 사실상 이것도 어려움\r\n\r\n1. 몇 개의 리소스가 있는지도 모름\r\n\r\n2. 시스템마다 리소스 수가 다를 것\r\n\r\n3. os가 일정한 order를 가지고 순서를 부여학 쉽지않음\r\n\r\n4. 새로운 리소스가 추가되면 어떻게 할 것인지\r\n\r\n   단순하게 i+1?\r\n\r\n   근데 얘가 굉장히 중요한 리소스라면?\r\n\r\n이론적으로는 괜찮으나 실질적으로 어렵다\r\n\r\n\r\n\r\n## Deadlock Avoidance - Banker's Algorithm \r\n\r\n시스템이 추가적인 정보, 사전 정보 요구 : a prior informationL\r\n\r\n- maximun number of resource : 각각의 프로세스가 동시에? 사용하고자하는 최대 리소스의 개수를 미리 개재\r\n  - ex) P0은 R0 :10개, R1: 5개, R2:2개\r\n  - 미리 정해두는게 쉬운건 아니지만 일단 이걸 전제\r\n\r\n- resource-allocation state : 특정순간에 실제 할당받은 것을 체크 - circular wait이 생기지않도록함\r\n\r\n\r\n\r\n## Banker's Algorithm\r\n\r\n시스템은 state를 safe state와 unsage state로 나눔\r\n\r\n- Safe state : 어떤한 형태에도 데드락이 발생안함\r\n  - Safe sequence <P1, P2,... Pn>이 safe state에 존재한다\r\n\r\n  - 아래 은행 예시의 경우 B-A-C, B-C-A, C-A-B, C-B-A가 될 수 있음\r\n\r\n  - safe sequence에서는 언제나 앞번호의 프로세스가 수행되고 그 다음 뒷번호 프로세스가 수행된다고 가정한다\r\n\r\n  - P1이 빌려가고 반납하면 P2가 빌려감.. 이렇게 순차적으로\r\n\r\n  - 느리긴 하지만 safe할 수 있다\r\n\r\n- Unsafe state : 데드락이 발생할수도있음\r\n\r\nP : 프로세스 n개의 set\r\n\r\nR : 리소스 m개의 set\r\n\r\nsafe state인지를 어떻게 볼까\r\n\r\n<br/><br/>\r\n\r\nex) 은행 총 100억 소유중이라고 할 때,\r\n\r\n(리소스가 하나만 존재 : 돈)\r\n\r\n\\# safe state 예시\r\n\r\n| 고객 | 최대 필요량 | 현재 대출금 | 필요량 |\r\n| ---- | ----------- | ----------- | ------ |\r\n| A    | 60억        | 20억        | 40억   |\r\n| B    | 50억        | 30억        | 20억   |\r\n| C    | 50억        | 30억        | 20억   |\r\n\r\n은행 남은 잔고 : 30억\r\n\r\n* B또는 C에게 필요량만큼 빌려줄 수 있음!\r\n* 만약 B에게 20억을 빌려준다면 B가 일을 수행 후 대출한 50억을 다시 은행에게 돌려줌\r\n* 받은 50억으로 모두에게 돈을 빌려주고 회수가능\r\n\r\n<br/>\r\n\r\n\\# unsafe state 예시\r\n\r\n| 고객 | 최대 필요량 | 현재 대출금 | 필요량 |\r\n| ---- | ----------- | ----------- | ------ |\r\n| A    | 60억        | 30억        | 30억   |\r\n| B    | 50억        | 40억        | 20억   |\r\n| C    | 50억        | 30억        | 20억   |\r\n\r\n은행 남은 잔고 : 0억\r\n\r\n* 모두에게 돈을 추가로 빌려줄 수 없음 -> 아무도 더 이상 돈을 빌리지 못하고 일을 수행할 수 없는 상태\r\n* 그러나 만약 운좋게 A가 30억만으로도 주어진 일을 수행할 수 있다면 A가 일을 완수후 30억을 다시 돌려주고 은행은 다른 고객에게 돈을 빌려주는게 가능!\r\n* 이렇게 데드락이 발생할수도 있는 상황을 unsafe라고 함\r\n\r\n\r\n\r\n### 전제조건\r\n\r\n- 각각의 프로세스는 사전에 maximum use를 고지해야함 - 최대 얼마나 사용할 것인지 미리 알려줘야함\r\n\r\n- 프로세스는 기다릴 수 있어야함\r\n\r\n- 프로세스가 한 번 리소스를 가져가면 주어진 시간안에 반환을 해야함\r\n\r\n### \r\n\r\n\r\n\r\n### Notation\r\n\r\n- n : 프로세스의 개수\r\n- m : 리소스의 개수\r\n- Available[1:m] 리소스마다 몇 개가 사용 가능한지\r\n- Max[1:n, 1:m] : n x m 행렬, 각 프로세스가 최대로 필요로 하는 리소스 개수\r\n- Allocation[1:n, 1:m] : 현재 각 프로세스들에게 할당된 리소스\r\n- Need[1:n, 1:m] : 각 프로세스들에게 필요한 리소스들 (Max - Allocation)\r\n\r\n\r\n\r\n### 알고리즘 두 가지\r\n\r\n- safety algorithm : 현재 safe인지 unsafe인지 판별\r\n- Resource-Request Algorithm : 새로운 리퀘스트가 왔을 때, 이 리퀘스트를 들어주면 safe인지 unsafe인지 판별 (safety algorithm 사용)\r\n\r\n\r\n\r\n### Safety Algorithm\r\n\r\nAvailabe보다 Need가 더 작은애들은 언제든지 일을 할 수 있음\r\n\r\nFinish : 해당 프로세스가 끝났는지를 나타냄\r\n\r\n![](../../../../../../inha-image/safety.png)\r\n\r\nAvailable == Work라고 할 때\r\n\r\n1. initialize Work[1:m] and Finish[1:n]\r\n\r\n   Work = Available\r\n\r\n   Finish[i]는 전부 false\r\n\r\n2. 아래를 만족하는 i를 찾는다.\r\n\r\n   * Finish[i] = false : 아직 working중인 process\r\n   * Need i <= Work : Pi에게 추가로 필요한 리소스가 현재 빌려줄 수 있는 리소스보다 작은 상태\r\n\r\n   만약 만족하는 i가 없다면 4번으로\r\n\r\n3. Work = Work + Allocation(i) : Pi가 일을 마쳤으니 Pi에게 할당된 리소스를 회수\r\n\r\n   Finish[i] = true : Pi 작업끝!\r\n\r\n   2번으로 돌아감\r\n\r\n4. 모든 i에 대해 Finish[i]가 true이면, 시스템은 safe state한 것.\r\n\r\n\r\n\r\n\r\n\r\n### Resource Request Algorithm\r\n\r\n리퀘스트를 받았다고 가정하고 앞으로 벌어질 일들에 대해 safety algorithm을 돌려봄\r\n\r\n* 어떤 프로세스가 리소스 요청을 할 때 일단 들어줘보고 safe가 유지되는지 확인\r\n\r\n![](../../../../../../inha-image/resource-req.png)\r\n\r\n1. Request(i)가 Need(i)보다 작은지 확인 (만약 Request가 크다면 Max를 넘어가는 범위이므로 error)\r\n\r\n2. Request(i) <= Available(i)이면 일단 실행\r\n\r\n3. 아래 수행 - 실제로 request를 들어주는건 아니고 빌려줘도 될지 값만 계산해봄\r\n\r\n   * Available = Available - Request(i) : 빌려줄 수 있는 리소스양에서 Request만큼 줄임\r\n   * Allocation(i) = Allocation(i) + Request(i) :  Pi에게 리소스 할당\r\n   * Need(i) = Need(i) - Request(i) : 빌려준만큼 Pi에게 필요한 리소스에서 줄임\r\n\r\n   safe를 만족하면 Pi에 리소스를 할당\r\n\r\n   unsafe하면 Pi를 기다리게함\r\n\r\n### 한계\r\n\r\n근데 사실 잘안쓰임\r\n\r\n1. Rj가 얼마나 될지 정확하게 알기 힘듦 - 리소스 자원의 수가 가변적일수도있음\r\n2. Process 수가 가변적임 - 프로세스 수가 고정되어있는게 아님\r\n3. 미리 maximum use를 고지하기 힘듦\r\n\r\n그래서 사용되진않음 ㅎ\r\n\r\n사실 데드락을 크게 고려안함... 왜?!\r\n\r\n데드락이 발생하면 pc사용자가 바로 인지할 수 있음\r\n\r\n무한뤂프 돌면서 뻗을때... 걍 작업관리자 켜서 종료함\r\n\r\n오잉~ 나 스스로 데드락 종료 ?!\r\n\r\n그래서 엄청나게 중요한 문제는 아님\r\n\r\n유저가 개입할 수 없는 서버시스템, misstion critical system(자율자동차)...에서는 중요한 문제\r\n\r\n\r\n\r\n### prevention과 detection 차이\r\n\r\nprevention : 비쌈, 비효율적. 데드락 가능성을 보고 아예 방지\r\n\r\ndetection : 데드락을 허용하되 리커버리 제공\r\n\r\n근데 사실 디텍션도 그렇게 값싼건아님\r\n\r\n복구가 항상 가능한 것은 아님\r\n\r\nmission critical system(자율주행자동차)같이 데드락에 취약한 시스템에서는 사용이 어렵다\r\n\r\n\r\n\r\n## Deadlock Detection\r\n\r\n- single instance - 자원 타입마다 자원이 한 개\r\n\r\n  - 그래프에 싸이클이 생기는지 안생기는지로 detection\r\n  - wait-for 그래프 사용\r\n\r\n    ![](./wait-for.png)\r\n\r\n    자원이 하나씩있으므로 리소스 노드 삭제하고 간편화해서 그림\r\n\r\n    싸이클이 발생했는지 확인하기위해선 O(n^2)의 시간이 걸린다. (n = 화살표의 개수)\r\n- multiple instance - 한 종류의 자원이 여러개있음\r\n\r\n  - banker's algorithm을 변형해서 detection\r\n\r\n바이너리 세마포어, 카운팅 세마포어 같은 느낌\r\n\r\n\r\n\r\n### Multiple instance\r\n\r\nMax가 없고 Request[1:n, 1:m]가 생김\r\n\r\n* Process들의 Request가 따로따로 존재함\r\n* Need 대신 Request사용\r\n* Request : 리소스 리퀘스트를 보냈지만 아직 할당은 받지 못한 상태\r\n\r\nFinish[i]가 True가 되는 조건이 다름\r\n\r\n* 아까는 초기값 False에 자원 반납을 전부 완료하면 True로 전환\r\n* 지금은 allocation한게없으면 True (자원을 아무것도 사용하고있지않으면 일단 True)\r\n\r\n데드락이 생기는지 안생기는지만 판단\r\n\r\n\r\n\r\n![](../../../../../../inha-image/deadlock-detection.png)\r\n\r\n1. Initialize Work[1:m], Finish[1:n]\r\n\r\n   Work = Available\r\n\r\n   Finish[i] = false (if Allocation != 0), 아니면 true\r\n\r\n2. 다음 조건을 만족하는 i를 찾는다\r\n\r\n   Finish[i] = false\r\n\r\n   Request(i) <= Work\r\n\r\n   만족하는 i가 없다면 4번으로\r\n\r\n3. Work = Work + Allocation(i)\r\n\r\n   Finish[i] = true\r\n\r\n   2번으로 다시 \r\n\r\n4. 모든 i에 대해 Finish[i] = true면 no deadlock\r\n\r\n\r\n\r\ndetection은 request가 들어올 때마다 돌린다\r\n\r\n* 알고리즘이 무거워서 오래걸림. 함수가 너무 자주 호출됨 : 오버헤드가 큼\r\n\r\n주기적으로 호출한다\r\n\r\n* 주기가 길면 데드락 상황도 오래 지속된다\r\n\r\n주기적으로 하면서 특정 조건일 때 발동\r\n\r\n* CPU 사용률이 40% 이하일 때 - 성능적으로 큰 손해가 없음, 데드락 가능성 존재(다들 기다리는중)\r\n\r\n\r\n\r\n데드락 감지되면 어떻게 하죠?\r\n\r\n리커버리 해야죠\r\n\r\n* 프로세스 종료\r\n  * 모든걸 종료시킬거임? - 개오바 무리\r\n  * 하나씩 종료시키면서 데드락 해결되길바라자\r\n    * 근데 뭘 먼저 종료시킬건데?\r\n    * 얼마나 중요한가, 얼마나 돌았는가, 끝내기위해 얼마나 많은 리소스를 필요로 하는가 등 많은 조건들을 따짐\r\n    * 시스템마다 우선으로 두는 가치를 잘 반영해서 짜야함\r\n* 자원을 뺏어서 다른애한테 (preemption)\r\n  * 누구껄 뺏죠 - 이것도 복잡한 문제\r\n  * Rollback - 자원 할당 시키기 전으로 되돌림, safe한 state일 때로 돌려야함. 근데... 그 때가 언젠지 어떻게 알죠?;\r\n  * safe한 state일 때를 기록해놔야함 : 이것도 오바\r\n  * Starvation : 한 명이 계속 자원 뺏길수도있음 \r\n"},{"excerpt":".env vsc의 프로젝트 하위에 .env 파일을 만든다 .env 파일안에 SECRET KEY를 적어둔다   export는 전역변수 선언 dotenv pip install dotenv os.environ'ACCESS_KEY' : .env에 ACCESS_KEY가 없으면 KEY ERROR 그냥 python 딕셔너리라고 생각하면 됨 os.environ.get(…","fields":{"slug":"/env/"},"frontmatter":{"date":"May 09, 2022","title":"SECRET KEY 환경변수에 숨기기","tags":["env"]},"rawMarkdownBody":"\r\n\r\n\r\n## .env\r\n\r\n* vsc의 프로젝트 하위에 .env 파일을 만든다\r\n* .env 파일안에 SECRET KEY를 적어둔다\r\n\r\n![](./env_capture.png)\r\n\r\n>  export는 전역변수 선언\r\n\r\n\r\n\r\n## dotenv\r\n\r\n* pip install dotenv\r\n\r\n```python\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nAWS_ACCESS_KEY_ID = os.getenv('ACCESS_KEY')\r\n```\r\n\r\n> * os.environ['ACCESS_KEY'] : .env에 ACCESS_KEY가 없으면 KEY ERROR 그냥 python 딕셔너리라고 생각하면 됨\r\n>\r\n> * os.environ.get('ACCESS_KEY') : getenv가 그냥 os.envrion.get의 래퍼인듯... 똑같이 작용\r\n>\r\n>   \r\n"},{"excerpt":"Dining-Philosophers Problem 원형 테이블에서 식사하는 철학자 철학자는 thinking하거나 eating 두 가지 상태 존재 각 철학자들은 밥을 먹어야할 때만 소통 두 명이 젓가락 한 개씩 공유 옆에 있는 젓가락만 사용가능 ( i번째 사람은 i또는 i+1만) 공유데이터 밥 (data set) Semaphore chapstic 5 sem…","fields":{"slug":"/11-1/"},"frontmatter":{"date":"May 09, 2022","title":"os 11-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Dining-Philosophers Problem\r\n\r\n> 원형 테이블에서 식사하는 철학자\r\n>\r\n> * 철학자는 thinking하거나 eating 두 가지 상태 존재\r\n>\r\n> * 각 철학자들은 밥을 먹어야할 때만 소통\r\n>\r\n> 두 명이 젓가락 한 개씩 공유\r\n>\r\n> * 옆에 있는 젓가락만 사용가능 ( i번째 사람은 i또는 i+1만)\r\n>\r\n> 공유데이터\r\n>\r\n> * 밥 (data set)\r\n> * Semaphore chapstic [5]\r\n\r\n- semaphore chapstic[5]; # binary semaphore(=mutex lock) 1or0\r\n\r\n- signal() # release 밥을 다 먹음\r\n\r\n- 데드락 문제 발생 가능!!\r\n\r\n## Deadlock\r\n\r\n내가 원하는 자원을 상대방이 점유하고있어서 다음으로 넘어갈 수 없음\r\n\r\nex. 모든 사람들이 다 자신의 왼쪽에 있는 젓가락 한 짝을 소유중\r\n\r\n모두가 계속 기다림... \r\n\r\n* wait( chopstic[ (i+1) % 5] ) <- 여기서 다들 기다리게됨\r\n\r\n<br/>\r\n\r\n### 해결방안 1\r\n\r\n다섯명의 철학자가 있지만 책상에 앉을 수 있는 사람을 4명으로 제한\r\n\r\n- 적어도 한 명은 젓가락 한 쌍을 얻을 수 있다\r\n\r\n<br/>\r\n\r\n### 해결방안 2\r\n\r\n젓가락 두 개가 동시에 사용 가능할때만 젓가락을 집게한다\r\n\r\n- 두 줄의 코드가 atomic하게\r\n- 크리티컬 섹션으로. 내가 젓가락을 집을 때 다른 사람이 집을 수 없음\r\n\r\n-> 모니터를 사용해서 구현\r\n\r\nstate hungry 추가\r\n\r\n* thinking\r\n\r\n* hungry\r\n\r\n* eating : 두 이웃이 젓가락을 안쓰고있을때만 eating 가능\r\n* 모니터 안에는 condition self가 존재\r\n  * condition == semaphore + waiting queue + wait(), signal() 함수를 제공하는 하나의 자료형\r\n  * 여기서의 Semaphore는 자원이라기보단 스케줄링을 위한 수단이라고 보는게 좋음 \r\n\r\n\r\n\r\n#### 코드\r\n\r\npickup() : 젓가락 획득 시도\r\n\r\n* self[i].wait - i번째 사람이 밥을 먹을 수 없는 상태라면 대기\r\n* 양쪽 사람들 중 누군가가 밥을 다 먹고 젓가락을 내려놓을때 먹을 수 있음\r\n\r\ntest() :  양쪽 사람이 안먹고있는지 체크\r\n\r\n* 내가 배고픈데 & 왼쪽 사람이 밥 안먹고있고 & 오른쪽 사람이 밥을 안먹고있는가\r\n* self[i].signal() - i번째 사람 밥먹으라고 신호\r\n\r\nputdown() : 젓가락 반환\r\n\r\n* test : i번째는 밥을 다 먹었으니 양 옆에 사람들이 밥 먹을 수 있는지 테스트\r\n* test했는데 hungry면 기다리고 있었던 것. 걔 self[i].signal()로 밥먹게함\r\n\r\ninitialization_code() : state 초기화 \r\n\r\n> No deadlock, but starvation is possible\r\n>\r\n> 데드락은 해결됐지만 누가 계속 밥을 먹으면 누군가는 굶주려야함\r\n\r\n<br/>\r\n\r\n### 해결방안 3\r\n\r\nasymmetric한 구조를 만든다 (i -> i+1순으로 잡는데 만약 전체 인원의 반이 i+1->i순으로 젓가락을 집는다면?)\r\n\r\nwait(i+1)\r\n\r\nwait(i)\r\n\r\n순으로 하게 변경\r\n\r\n모두가 동시에 왼쪽 젓가락을 집지않는다\r\n\r\n\r\n\r\n## Deadlock\r\n\r\n어떤 프로세스가 다른 프로세스가 지닌 무언가를 얻기 위해 기다리고있는데 상대 프로세스도 무언가를 기다리는 중이라서 관련된 모든 프로세스들이 전부 기다려야하는 상황\r\n\r\n\r\n\r\n### System Model\r\n\r\nm개의 리소스 종류, R\r\n\r\n* 리소스는 꼭 공유변수여야하는건 아니고 cpu 사이클일수도있고 메모리 공간일수도 있고 i/o 디바이스...\r\n* 각각의 프로세스는 세 가지 경우가 있다\r\n  * request\r\n  * use\r\n  * release\r\n* 각각의 리소스 R은 리소스 총량 W가 있다\r\n  * 리소스 R이 W개 있다\r\n\r\n\r\n\r\n### 데드락 친구들\r\n\r\n* Deadlock - 서로가 상대방의 자원을 요구하면서 기다리는 상태\r\n* Livelock - 락의 획득/해제가 무한히 반복되는 상태 : 데드락을 방지하는 코드에서 발생할수도있음\r\n\r\n* Indefinite Postponement - 일어나지 않을 일을 기다리는 중이라 무한하게 대기중인 상태\r\n\r\n\r\n\r\n### 데드락의 조건\r\n\r\n- Mutual exclusion\r\n  - 한 명이 리소스를 차지하고있으면 다른 사람이 리소스를 동시에 차지할 수 없다\r\n- No preemption\r\n  - 한 번 자원을 얻으면 할 일이 끝날 때까지 자원을 양보하지않는다\r\n- Hold and wait\r\n  - 한 프로세스가 적어도 하나 이상의 리소스를 가지고 있고 다른 리소스를 원하는 상태, 그러나 그 다른 리소스는 또 다른 프로세스가 가지고있음\r\n\r\n- Circular wait\r\n  - 원을 그리면서 서로가 서로의 것을 원하는... 상태\r\n\r\n\r\n\r\n### 데드락 방지\r\n\r\n위 조건 중 하나라도 만족하지않으면 문제가 생기지않음\r\n\r\n\r\n\r\n* no mutual exclusion\r\n  * 여러명이 동시에 같은 자원 사용이 가능하게\r\n  * 현실적으로 불가능 ㅎㅎ;\r\n  * 리소스의 특성 자체를 바꾸는 일\r\n* no preemption\r\n  * 양보 가능한\r\n  * 라이브락 가능성 존재\r\n  * 그러나 새로운 것도 획득 가능 할때 다시 기존 것도 얻게하면 라이브락 방지가 가능할 것!\r\n* no hold and wait\r\n  * 리소스를 순차적을 얻지 않고 한 번에 얻거나 한 번에 기다린다\r\n  * 프로세스가 어느 시점에 어떤 리소스를 원할지 예측하는게 어려움, 구현 복잡;;\r\n  * 리소스 낭비가 심해질수있음 (쓸지안쓸진 모르지만 일단 다 받아놓자~ )\r\n  * starvation 가능 - 한 명이 리소스 독식\r\n* no circular wait\r\n  * 서큘러가 될 거 같으면 연결 고리가 끊어질때까지 대기\r\n\r\n\r\n\r\n## Resource-Allocation Graph\r\n\r\n각 프로세스가 자원을 어떻게 활용하고 있는지 나타낸 그래프\r\n\r\n4개 - 최대 4개의 프로세스가 사용가능\r\n\r\n\r\n\r\n* circular wait이 있다면 데드락 가능성 존재\r\n  * 완전히 닫힌 싸이클\r\n* 예시1은 데드락\r\n* 예시 2는 싸이클이지만 데드락 아님\r\n  * p2 p4는 개별적을 동작 가능\r\n  * 뭘 기다리고있지않음\r\n"},{"excerpt":"EC2 인스턴스 할당하기 Security Group > Add Rule HTTP HTTPS Custom -> TCP -> 8000 -> 0.0.0.0/0, ::/0 Review and Launch > Launch Create a new key pair 원하는 이름 설정 Download Key Pair Launch Instance Elastic IP 받기 …","fields":{"slug":"/deploy-ec2/"},"frontmatter":{"date":"May 08, 2022","title":"django 프로젝트 ec2로 배포하기","tags":["DRF","AWS","EC2"]},"rawMarkdownBody":"\r\n\r\n\r\n## EC2 인스턴스 할당하기\r\n\r\n#### Security Group > Add Rule\r\n\r\n1. HTTP\r\n2. HTTPS\r\n3. Custom -> TCP -> 8000 -> 0.0.0.0/0, ::/0\r\n\r\n\r\n\r\n#### Review and Launch > Launch\r\n\r\n1. Create a new key pair\r\n2. 원하는 이름 설정\r\n3. Download Key Pair\r\n4. Launch Instance\r\n\r\n\r\n\r\n#### Elastic IP 받기\r\n\r\nNetwork & Security > Elastic IPs\r\n\r\nAllocate Elastic IP address\r\n\r\nAllocate\r\n\r\nAssociate Elastic IP address\r\n\r\nInstance > 아까 생성된 인스턴스 선택\r\n\r\nAssociate\r\n\r\n\r\n\r\n#### SSH 연결하기\r\n\r\nssh ubuntu@아까_받은_Elastic_IP -i 다운받은_PEM_FILE\r\n\r\n\r\n\r\n## Django 프로젝트의 settings.py 수정\r\n\r\n1. DEBUG = (os.environ.get('DEBUG', 'True') != 'False')\r\n2. ALLOWED_HOSTS = ['*']\r\n3. pip freeze > requirements.txt\r\n4. git add -A, commit 해서 git repo에 push\r\n\r\n\r\n\r\n## Termius\r\n\r\n1. python3 -m venv venv #가상 환경 생성\r\n2. git clone {내_GitHub_레포지토리} {django-app}\r\n3. cd {django-app}\r\n4. source ../venv/**bin**/activate\r\n5. pip install -r requirements.txt\r\n6. python manage.py runserver 0.0.0.0:8000\r\n\r\n하면 http:// {나의 Elastic_IP:8000} 으로 접속 가능\r\n"},{"excerpt":"S3 버킷 생성 Django setting 설정 패키지 & 라이브러리 설치 settings.py - INSTALLED_APP","fields":{"slug":"/media-S3/"},"frontmatter":{"date":"May 08, 2022","title":"django media파일 S3서버랑 연동하기","tags":["DRF","AWS","S3"]},"rawMarkdownBody":"\r\n\r\n\r\n## S3 버킷 생성\r\n\r\n\r\n\r\n\r\n\r\n## Django setting 설정\r\n\r\n#### 패키지 & 라이브러리 설치\r\n\r\n```python\r\npip install boto3 # python에서 AWS에 접근가능한 패키지\r\npip install django-storages # 커스텀 스토리지 \r\n```\r\n\r\n\r\n\r\n#### settings.py - INSTALLED_APP\r\n\r\n\r\n\r\n```python\r\n# media url 설정\r\nMEDIA_URL = \"/media/\"\r\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\r\n\r\n# for AWS S3\r\nDEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\r\nAWS_S3_SECURE_URLS = False # use http instead of https\r\nAWS_QUERYSTRING_AUTH = False # don't add complex authentication-related query parameters for requests\r\n\r\nload_dotenv()\r\n\r\n# AWS IAM 유저 key설정\r\nAWS_S3_ACCESS_KEY_ID = os.getenv('ACCESS_KEY')\r\nAWS_S3_SECRET_ACCESS_KEY =os.getenv('SECRET_ACCESS_KEY')\r\n\r\n# S3 버킷 이름\r\nAWS_STORAGE_BUCKET_NAME = 'danmer-videos'\r\n```\r\n\r\n\r\n\r\n"},{"excerpt":"Modular Exponentiation e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다 n의 bit수와 d의 bit수는 거의 같다 d = p x q (p, q는 각각 2048 bit) 곱하면 4096bit n은 3072 or 4096bit 0 < d < 파이(n) d의 자릿수 숫자는 불규칙? Binary L to R =(Squa…","fields":{"slug":"/rsa-mod/"},"frontmatter":{"date":"May 02, 2022","title":"10-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## Modular Exponentiation\r\n\r\n\r\n\r\n* e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다\r\n* n의 bit수와 d의 bit수는 거의 같다\r\n* d = p x q (p, q는 각각 2048 bit) 곱하면 4096bit\r\n* n은 3072 or 4096bit\r\n* 0 < d < 파이(n)\r\n* d의 자릿수 숫자는 불규칙?\r\n\r\n\r\n\r\n### Binary L to R\r\n\r\n=(Square and multiply)\r\n\r\n* 이진수로 분해\r\n* 제곱 (f x f)\r\n* 비트 곱하기? (f x a)\r\n\r\n제곱과 선택적인 비트 곱하기\r\n\r\n"},{"excerpt":"Modular Exponentiation e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다 n의 bit수와 d의 bit수는 거의 같다 n은 3072 or 4096 bit 자리 이진수 n = p x q (p, q는 각각 2048 bit) 곱하면 4096bit 파이n은 (p-1)(q-1)이므로 역시 4096bit d는 e의 곱셈의 역원…","fields":{"slug":"/rsa-mod/"},"frontmatter":{"date":"May 02, 2022","title":"10-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## Modular Exponentiation\r\n\r\n* e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다\r\n* n의 bit수와 d의 bit수는 거의 같다\r\n  * n은 3072 or 4096 bit 자리 이진수\r\n\r\n* n = p x q (p, q는 각각 2048 bit) 곱하면 4096bit\r\n* 파이n은 (p-1)(q-1)이므로 역시 4096bit\r\n* d는 e의 곱셈의 역원을 모듈러 파이n한 것이므로 : 0 < d < 파이(n)\r\n* d의 자릿수 숫자는 불규칙?\r\n  * d의 앞 bit가 1이면 4096bit (확률 1/2)\r\n  * d의 앞 bit가 0, 두 번째 bit가 1이면 4065bit (확률 1/4)\r\n  * 이런식을 확률이 점점 줄어듦. 즉 bit수가 4096과 가까울 확률이 높음\r\n\r\n\r\n* Two key techniques for fast exponentiation\r\n  * 거듭해서 곱하지말고 제곱과 곱하기를 해결하자~\r\n  * a^b는 숫자가 너무 크니, 각 a에 mod n연산을 해줘서 크기를 줄이자!\r\n    * 4000 -> 8000 -> 16000 -> 24000 ...\r\n    * 4000 -> 8000 -> 4000(mod n) -> 8000 ...\r\n  * 어차피 (x x y) mod n = [(x mod n) x (y mod n)] mod n\r\n  * 이게 적용된게 `Fast Modular Exponentiation` 알고리즘\r\n\r\n\r\n\r\n## Binary L to R\r\n\r\n=(Square and multiply)\r\n\r\n* 이진수로 분해\r\n* 제곱 (f x f)\r\n* 비트 곱하기? (f x a)\r\n\r\n제곱과 선택적인 비트 곱하기\r\n\r\n\r\n\r\n## Application of RSA\r\n\r\n* 기밀성(Confidentiality)\r\n  * src는 dest의 pu로 암호화\r\n  *  dest는 dest의 pr로 복호화\r\n\r\n* 인증(Authentication) - 전자서명(nonrepudation) 제공 가능\r\n  * src는 src의 pr로 암호화\r\n  * dest는 src의 pb로 복호화\r\n\r\n* 기밀성 & 인증 둘 다\r\n  * src가 src의 pr로 암호화 (서명)\r\n  * src가 dest의 pu로 암호화(메시지 암호화)\r\n  * dest가 dest의 pr로 복호화(메시지 복호화)\r\n  * dest가 src의 pb로 복호화 (서명확인)\r\n"},{"excerpt":"이전 내용 요약 Critical Section with Disable/Enable interrupt 인터럽트로 인해 다른 프로세스가 참견불가능 싱글 cpu일 경우 해결 가능 그러나 너무 강력한 방법 크리티컬 섹션하자고 모든 인터럽트를 다 막는다? 하드웨어 인스트럭션 : testandset 크리티컬 섹션 문제 해결 가능 Mutex Lock 이전에 배운 te…","fields":{"slug":"/sync-tools/"},"frontmatter":{"date":"May 02, 2022","title":"os 10-1 Synchronization Tools","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n> 이전 내용 요약\r\n>\r\n> * Critical Section with Disable/Enable interrupt\r\n>   * 인터럽트로 인해 다른 프로세스가 참견불가능\r\n>   * 싱글 cpu일 경우 해결 가능\r\n>   * 그러나 너무 강력한 방법\r\n>   * 크리티컬 섹션하자고 모든 인터럽트를 다 막는다?\r\n> * 하드웨어 인스트럭션 : test_and_set\r\n>   * 크리티컬 섹션 문제 해결 가능\r\n\r\n\r\n\r\n## Mutex Lock\r\n\r\n> 이전에 배운 test_and_set같은 하드웨어 instruction의 경우 불편한 점이 있다!\r\n>\r\n> * 개발자마다 다 다르게 개발할텐데... 어떻게 구현할지 다 지맘대로\r\n>\r\n> 그래서 api수준의 해결방법을 만들자! 해서 생긴게 mutex, semaphore, monitor들\r\n\r\n* race condition - 리소스를 공유하면서 생길 수 있는 문제 상황 그 자체\r\n* critical section - 문제 정의 : 레이스 컨디션을 발생시킬수있는 코드를 정의\r\n* mutex, semaphore, monitor - 해결방법 (high-level) API 수준임 - OS가 제공해줘야함\r\n\r\n* **Mutex (Mutual Exclusion) : 공유 변수 + 공유 자원(HW자원, I/O device ) - 변수를 넘어 자원까지 확장됨**\r\n\r\n​\t\r\n\r\n> ex)\r\n>\r\n> ![](./mutex-example-image.png)\r\n>\r\n> 하나의 프린터를 여러 사람들이 공유해서 쓴다면 출력되는 내용이 섞일 것. 프린터룸을 \"key\"를 가진 사람만 접근 가능하게 해서 해결하자!\r\n>\r\n> * 프린터룸 : critical section (프린터기를 공유하면서 문제가 생길 수 있는 공간)\r\n>\r\n> * 프린터기 : 공유 자원\r\n>\r\n> * admin : =os, key(mutex)를 관리한다\r\n> * 각각의 사람들 : process or thread\r\n> * key : mutex\r\n>\r\n\r\n\r\n\r\nos는 mutex권한을 acquire하거나 realease함\r\n\r\n* mutex로 Critical section을 보호하는 방법\r\n\r\n* acquire()과 release()를 사용해서 섹션에 진입하는 것을 제어한다. (인터페이스 제공)\r\n\r\n* Boolean variable == mutex == key \r\n\r\n\r\n\r\n\r\n\r\n### acquire() - key를 전달\r\n\r\n![](./mutex-acquire.png)\r\n\r\n* admin이 수행\r\n\r\n- key가 없으면 대기 - 계속 while문 돌면서 누군가 key를 release() 할 때까지 기다림\r\n- key가 생기면 acquire()이후의 코드를 실행 (크리티컬 섹션으로 진입)\r\n\r\n\r\n\r\n### release() - key를 반납\r\n\r\n- 할 일이 끝났으니 available을 true로 만듦\r\n\r\n\r\n\r\n### Busy waiting\r\n\r\n>  key를 얻기전에 while문을 계속 도는 것\r\n\r\n- available이 참인지 거짓인지 계속 판단\r\n- while을 깨줄 수 있는건 외부의 다른 프로세스가 realease를 해주는 것 뿐\r\n- 만약 프로세스 P0이 waiting상태라면,\r\n  - P0 : time slice를 소진할 때 까지 busy waiting\r\n  - availble을 참으로 바꿔주는 건 다른 프로세스 : 다른 프로세스가 cpu에 올라가서 참으로 만들어줘야하나 이미 P0이 cpu 선점\r\n  - P0은 계속 while문을 돌리면서 cpu에 있어야함\r\n  - 성능 손해\r\n\r\n- 이걸 spinlock이라함 == (lock을 위해서 계속 spin중이다.)\r\n\r\n\r\n\r\n## Semaphore\r\n\r\n> mutex와 비슷하나 좀 더 진화된 형태\r\n\r\nkey가 여러개!!!\r\n\r\n- P() : wait(), (=acquire)\r\n- V() : signal(), (= release)\r\n- S : int, key가 몇 개인지 개수를 나타냄\r\n  -  0보다 큰 int (S가 1이면 mutex와 같은 기능. mutex에서는 0과 1뿐인 boolean 사용했음)\r\n\r\n\r\n#### 📌 Binary semaphore \r\n\r\n- S가 0또는 1 (mutex와 같은 기능)\r\n\r\n  - for 전통적인 공유 변수 제어\r\n\r\n  \r\n\r\n#### 📌 Counting Semaphore \r\n\r\n* S가 2보다 크거나 같음\r\n\r\n- for   공동의 리소스 자원 관리/제어\r\n- wait()과 signal() 사용 - **스케줄링 필요** : 단순히 공유 자원의 lock개념을 넘어 확장됨(동기화)\r\n\r\n<br/><br/>\r\n\r\n### Implementation\r\n\r\n- wait()과 signail()(P, V)을 수행하는 것도 크리티컬 섹션에 포함시켜야한다 - 특히 S값을 바꾸는 과정\r\n  - S는 공유 자원이므로 S의 값을 변화시키는 wait()와 signal()도 크리티컬 섹션에 포함시켜야함\r\n\r\n- 전통적인 방법으로 크리티컬 섹션 문제를 푸는 것은 busywaiting 발생\r\n\r\n\r\n\r\n### 그렇다면, busy waiting을 어떻게 해결해야할까?\r\n\r\n#### semaphore waiting queue\r\n\r\nbusywaiting해결을 위해 세마포어 전용 waiting queue를 만든다\r\n\r\n각 세마포어에는 waiting queue가 할당된다.\r\n\r\n세마포어 waiting queue의 entry에는 아래 두 개가 존재한다.\r\n\r\n* value(int)\r\n* 다음 순서를 가리키는 포인터\r\n\r\n> busywaiting 하지말고 그냥 잠들어있어라\r\n>\r\n> 잠든 애들은 웨이팅 큐에 넣어서 os가 관리\r\n>\r\n> 주의! cpu의 waiting queue와 다른 것임\r\n>\r\n> 세마포어 전용 waiting queue를 의미\r\n\r\n<br/>\r\n\r\nblock과 wakeup 두 동작을 수행한다.\r\n\r\n\r\n\r\n#### 📌 block & wakeup\r\n\r\n- block == sleep : wait을 호출한 프로세스를 적절한 waiting queue에 넣는다\r\n- wakeup : waiting queue에 있는 애를 제거하고 cpu의 ready queue에 넣는다\r\n\r\n\r\n\r\n#### 📌 wait\r\n\r\n​\t![](./sem-wait.png)\r\n\r\n​\t<br/>\r\n\r\n​\t\\# interrupt 제어 추가버전\r\n\r\n​\t![](./sem-wait-adv.png)\r\n\r\n* wait - value가 0보다 작으면 키가 없는것!\r\n\r\n* 키가 없으니 리스트(웨이팅 큐)에 넣는다\r\n\r\n* block() == sleap\r\n\r\n\r\n\r\n#### 📌 signal\r\n\r\n​\t![](./sem-signal.png)\r\n\r\n​\t<br/>\r\n\r\n![](./sem-signal-adv.png)\r\n\r\n* S의 value가 0보다 작거나 같다면, 누가 대기중이라는 것이므로 하나를 wake up해줌\r\n  * = 가 들어가는 이유는 앞에서 S value를 증가시켜줬으므로 결국 초반에는 마이너스였다는 뜻\r\n\r\n* 대기중이 아니라면(S가 0보다 크다면) 그냥 S value 하나 늘려주고 끝\r\n\r\n> S는 0보다 크거나 같은 정수라 했는데 왜 0보다작은 S를 고려?\r\n>\r\n> * 어떤 프로세스가 키를 획득할 때 S value값을 줄임\r\n>\r\n> * S가 음수라면 S의 절대값은 wait을 호출하고 대기중이 P의 수를 의미함\r\n>\r\n> * 대기하는 수만큼 마이너스됨\r\n\r\n\r\n\r\n문제 하나 더!\r\n\r\nwait과 signal도 크리티컬 섹션이어야한다\r\n\r\n> 서로 다른 두 함수가 S value, S list를 공유중\r\n\r\n- S의 value랑 list도 크리티컬하게 관리되어야함 -> 싱글 cpu일 경우, disable interrupt, inable interrupt 사용\r\n\r\n\r\n\r\n>  앞에서는 disable interrupt하는거 오버헤드 크다고 했는데 여기선 쓰는 이유 : disable해두는 시간이 짧음\r\n>\r\n> 그러나 멀티 cpu일때는... cpu가 여러개 있으므로 다른 cpu를 사용하는 애들의 인터럽트는 막지 못함. 그렇다고 다른 cpu의 인터럽트까지 막기는 too strong!\r\n>\r\n> 결국 atomic한 하드웨어 서포트를 받아서 해결해야함\r\n\r\n\r\n\r\n### 멀티 cpu - 멀티 프로세서에서의 세마포어\r\n\r\n- turn off all other processors : 멀티 cpu일때는 위처럼 다른 cpu의 interrupt도 막는 것은 위험. \r\n- atomic hardware support가 필요(test_and_set) - S와는 별도로 TAS에서 critical section 해결을 위한 boolean 변수 필요 -> 복잡해짐\r\n  - 생각보다 사용자 레벨에서 쓰기가 어렵...\r\n- 시그널하고 wait하든 wait두 번 연속으로 하든 잘못된거 모름. 한참 돌다가 나중에 알아챌수도\r\n- 데드락, starvation 발생 가능\r\n- 즉, 장점도 있지만 사용하긴 어려움\r\n\r\n"},{"excerpt":"Django 로그인 처리 Django자체에 디폴트로 로 처리되어있다 장고의  를 활용해서 설정","fields":{"slug":"/LoginView/"},"frontmatter":{"date":"May 01, 2022","title":"Django LoginView 사용","tags":["django","python"]},"rawMarkdownBody":"\r\n## Django 로그인 처리\r\n\r\nDjango자체에 디폴트로\r\n\r\n```\r\nLOGIN_URL = '/accounts/login/'\r\n\r\nLOGIN_REDIRECT_URL = 'accounts/profile/'\r\n```\r\n\r\n로 처리되어있다\r\n\r\n장고의 `LoginView` 를 활용해서 설정\r\n\r\n```python\r\nform django.contrib.views import LoginView\r\n\r\nurlpatterns=[\r\n    path('login/', LoginView.as_view(template_name='accounts/login.html'), name = 'login'),\r\n]\r\n# LoginView의 template경로는 'registation/login.html'로 설정되어있다.\r\n# template_name = 'registation/login.html'\r\n# as_view 함수의 인자로 필드값을 넣어 인스턴스의 template_name을 변경시킬수있다.\r\n```\r\n"},{"excerpt":"Symmetric Encryption의 문제 어떻게 secure채널을 통해서 안전한 키를 전달하지? 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation - 자신이 보낸걸 부인할 수 없는 CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 - 나랑 이전에 키를 공유했던 그 사람이 맞…","fields":{"slug":"/public-key/"},"frontmatter":{"date":"May 01, 2022","title":"9-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## Symmetric Encryption의 문제\r\n\r\n* 어떻게 secure채널을 통해서 안전한 키를 전달하지?\r\n\r\n* 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation - 자신이 보낸걸 부인할 수 없는\r\n\r\n* CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 - 나랑 이전에 키를 공유했던 그 사람이 맞구나!\r\n\r\n  > 만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : \r\n  >\r\n  > B가 CBC-MAC을 통해 받은 Ciphertext를 key로 복호화해서 A로부터받았음을 확인\r\n  >\r\n  > B가 법정에서 증거를 제출하려면 받은 Plaintext와 key와 MAC(Message Authentication)을 제공\r\n  >\r\n  > key는 secure하게 보관되어야하므로 A와 B만 가지고있다\r\n  >\r\n  > 그러나 이 Plaintext가 정말 A가 보낸건지 B가 key를 사용해서 임의로 만든건지 구분할 수 없다\r\n  >\r\n  > 즉, key가 최소 두 명이상한테 공유되었기때문에 누가 쓴건지 구별이 불가능하다.\r\n  >\r\n  > key는 single claimed sender를 가져야한다. 보낸이한테만 유일한 키\r\n\r\n\r\n\r\n## Public-Key Cryptosystems\r\n\r\n`Plaintext` -> `Public key` -> `Encryption algorithm`\r\n\r\n`Ciphertext` -> `Private key` -> `Decryption algorithm`\r\n\r\n* 키 분배 문제 해결\r\n* 전자서명 구현\r\n\r\n\r\n\r\n### Encryption with public key : 메세지를 숨기고 싶을 때\r\n\r\n* 누구의 퍼블릭 키, 누구의 프라이빗 키인지가 중요하다\r\n* Bob이 Alice에게 암호문을 보낼 때, Alice의 퍼블릭키를 사용해서 암호화\r\n* Alice는 받은 암호문을 Alice의 프라이빗키를 사용해 복호화한다 \r\n\r\n> 키 분배 문제 해결 \r\n>\r\n> * 키 분배 문제 : 어떻게 key를 안전하게 교환할 것인가\r\n> * Public-Key는 A가 Key pair를 생성하면 공개키를 모두에게 공개\r\n> * 굳이 안전하게 전달할 필요가 없음\r\n\r\n\r\n\r\n### Encryption with private key : 전자서명\r\n\r\n* Private key를 가지고 Encryption : 전자서명에 해당\r\n* Encryption algorithm == Signature Generation\r\n* Decryption algorithm == Signature Verification\r\n\r\n* Bob이 Alice에게 암호문을 보낼 때, Bob의 Private key를 사용해서 암호화\r\n* Alice는 받은 암호문을 Bob의 Public key를 사용해서 복호화\r\n* 서명을 해서 보냄. 받아서 복호화한 Plaintext와 서명이 잘 맞아 떨어진다면 중간에 오류나 변조없이 도착한 것임 : Integrity 보장\r\n* Bob의 Privae key를 통해서 온 것이므로 nonrepudiation 해결\r\n\r\n\r\n\r\n### Conventional and Public-Key Encryption\r\n\r\n* conventional : 전통적인 (= Symmetric)\r\n\r\n|                   Conventional Encryption                    |                    Publick-Key Encryption                    |\r\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\r\n| 같은 알고리즘이 **같은 키**와 사용된다 (AES같은 경우엔 완전히 같진않고 역연산) | 두 개의 키가 존재한다 하나는 Encryption에 다른 하나는 Decryption에 사용 |\r\n|      보내는 사람과 받는 사람이 알고리즘과 키를 공유한다      | 알고리즘은 서로 공유하나 보내는 사람과 받는 사람이 같은 키가 아닌 키 pair를 사용한다 |\r\n|         대칭 암호에서는 키가 안전하게 유지되어야한다         |            공개키는 안전하게 전달 될 필요가 없다             |\r\n| 키가 안전하게 유지되고 있다면 메세지를 키 없이 복호화하는게 어렵다 | 키 중에 하나가 (Private Key)가 안전하게 유지되고 있다면 메세지를 복호화하는게 어렵다 |\r\n| 알고리즘을 알고 Cipher text를 몇개를 알아도(암호문쌍) 어떤 키가 사용됐는지 알아내는게 어렵다 | 알고리즘을 알고 공개키하나도 알고 Ciphertext(암호문쌍)을 알아도 private key를 알아내긴 어렵다 |\r\n\r\n\r\n\r\n### Public-Key Cryptosystem \r\n\r\n* Authentication and Confidentiality\r\n* Source A, Destination B 일 때\r\n* 1. A가 자신의 Private key를 가지고 서명\r\n  2. A가 B의 Public key를 가지고 암호화\r\n* 1. B가 자신의 Private key를 가지고 복호화\r\n  2. B가 A의 Public key를 가지고 A가 맞는지 확인\r\n\r\n\r\n\r\n#### Public-key cryptosystems can be classified into three catagories:\r\n\r\n* Encryption/Decryption\r\n* Digital Signature\r\n* Key exchange\r\n  * 공개키 쓴다고 symmetric 암호 안쓰는 건 아님\r\n  * 공개키암호는 속도가 느림\r\n  * 대용량 암호를 공유할 때 불편. 공개키암호와 대칭암호를 함께 사용\r\n\r\n\r\n\r\n#### Public-Key Requirements\r\n\r\n공개키 암호의 요구사항\r\n\r\n* 수신자가 키 페어를 만들기 쉬워야함\r\n* 퍼블릭 키와 메세지를 사용해서 ciphertext를 만드는 일이 쉬워야함\r\n* 프라이빗 키와 cipher text를 사용해서 plaintext로 만드는 일도 쉬워야함\r\n* 퍼블릭 키를 알고있어도 프라이빗 키를 추측하는건 어려워야함\r\n* 퍼블릭 키와 ciphertext를 알아도 private key없이 plain text를 추측하는건 어려워야함\r\n\r\n\r\n\r\n## RSA(Rivest-Shamir-Adleman) Algorithm\r\n\r\n> 글을 숫자 형태로 표현하는게 전제\r\n>\r\n> 어떤 정수 n을 모듈러로 사용해서\r\n>\r\n> 0 to n-1까지의 정수들을 plaintext의 메시지라고 간주한다.\r\n\r\n<br/>\r\n\r\n* PU = {e, n}\r\n* PR = {d, n}\r\n* 암호화는 e를 사용해서, 복호화는 d를 사용해서 함\r\n* 두 개다 mod n을 사용해야함. n은 권장사항이 2048 bit이상이며 보통 3072, 4096사용\r\n\r\n![](./rsa-enc-dec.png)\r\n\r\n> 지수연산 사용\r\n>\r\n> * plaintext는 M이라는 숫자로보고\r\n> * ciphertext는 C라는 숫자로 본다\r\n\r\n\r\n\r\n### Algorithm Requirements\r\n\r\n![](./algorithm-req.png)\r\n\r\n1. M은 평문의 글을 나타내며, n보다 작은 모든 M에 대해 위 수식을 만족해야한다\r\n2. 복호화, 암호화 계산이 어렵지않아야한다\r\n3. e와 n이 주어졌을때 d를 추측하기 어려워야한다\r\n\r\n<br/>\r\n\r\n### 예시\r\n\r\n ex ) Bob -> Alice에게 암호문을 보낼 때\r\n\r\n#### Key Generation by Alice\r\n\r\n* 소수인 p와 q를 임의로 뽑는다 (p와 q는 다른 수)\r\n*  n을 구한다 : n = p x q\r\n\r\n* 오일러 n을 구한다. \r\n  * n은 p x q이므로 오일러 n은 (p-1)(q-1)이다.\r\n\r\n*  임의로 e를 뽑는다. (e는 오일러(n)과 서로소여야함, e는 오일러 n보다 작고 1보다 큼)\r\n  * 이후 구할 d때문. (d는 모듈러 오일러n일때 e의 곱셈의 역원임) \r\n  * 즉, e x d = 1 mod 오일러(n)\r\n* Extended Euclid를 사용해서 d까지 구하면 퍼블릭키와 프라이빗키 생성 완료!!\r\n  * PU = {e, n}, PR = {d, n}\r\n\r\n\r\n\r\n#### Encryption by Bob with Alice's Public Key\r\n\r\n> Plain text = m, m은 n보다 작은 숫자의 범위\r\n\r\n* C = M^e mod n\r\n\r\n#### Decryption by Alice with Alice's Private Key\r\n\r\n![](./enc_dec.png)\r\n\r\n* C^d mod n == (M^e mod n)^d mod n\r\n  * M^ed mod n\r\n  * e x d = 1 mod 오일러n이었음\r\n  * 즉, (ed = k x 오일러(n) + 1) : d는 e의 곱셈의 역원\r\n\r\n* (  (M^오일러(n))^k  x  M )mod n\r\n\r\n> 오일러 이론에 의해 (M^오일러(n))^k 는 1이 된다\r\n\r\n* M mod n = M \r\n  * M이 n보다 작으므로 \r\n\r\n\r\n\r\n#### Example of RSA Algorithm\r\n\r\n![](./example.png)\r\n\r\n> p = 11, q = 17\r\n>\r\n> n = p x q = 187\r\n>\r\n> ∮(n) = (p-1)(q-1) = 160\r\n>\r\n> e = 7 (160과 서로소인 수)\r\n>\r\n> d = 23 ( e*d를 mod 160했을 때 1이 나옴. d는 e의 곱셈의 역원)\r\n>\r\n> * plaintext는 n(187)보다 작은 숫자\r\n\r\n### Dealing with Long Message\r\n\r\n* 128bit단위로 잘라서 블록 단위로 암호화했었음\r\n\r\n* RSA에선?\r\n\r\n> 1. 마찬가지로 M을 쪼개서 블록단위로 암호화\r\n>\r\n> 2. 하이브리드 encrypiton\r\n>    * **Data encryption** : src가 랜덤한 키를 만들어서 M을 나눈 블록에 대해 K를 사용해서 암호화 시킴 (블록 암호화)\r\n>    * **Key encapsulation** : K는 메시지라고 간주해서 메시지를 암호화해서 보내는 것 처럼 같이 보냄 (K^e mod n)\r\n>    * dest는 받은 메시지와 키를 가지고 메시지를 키로 암호화해서 평문으로 복호화 가능\r\n\r\n### RSA Signature\r\n\r\n> Decryption : Signature generation\r\n>\r\n> Encryption : Signature Verification\r\n\r\n* Alice 가 Bob에게 보낼 때 Alice가 자신의 private key로 Signature generation을 한다. (M, S)를 전달\r\n  * M은 메시지\r\n  * S는 서명한 M ==  (M^d mod n)\r\n* Bob 은 받은 S를 Alice의 public key(e)를 사용해서 Signature Verification을 한다\r\n  * S ^ e mod n == (M^d mod n)^e mod n == M^de mod n == M\r\n\r\n\r\n\r\n### Left to Right binary\r\n\r\n**Square and Multiply라고도 불림**\r\n\r\n지수승 계산\r\n\r\na^b mod n\r\n\r\n> 암호화할때는 b가 e가 되고, 복호화할 때는 b가 d가 된다\r\n\r\n예제 a=7, b=560, n=561\r\n\r\n> c = 2c와 c = c+1은 편의상의 코드 (없어도 됨)\r\n>\r\n> f = fxf와 f = fxa를 수행한다\r\n>\r\n> f는 a의 c제곱 mod n을 의미\r\n\r\n* for k부터 0까지 루프를 돈다\r\n  * k는 b의 비트수 (bk ~ b0)\r\n  * 예제의 경우 bit수가 10개이므로 k는 9~0\r\n* c는 현재 a의 몇 제곱인지를 알려줌(10진수). \r\n  * b의 bit를 10001까지 수행했을 경우 10001은 10진수로 17 = c \r\n  * 결과값에는 영향을 주지 않음. (지워도 상관없음. 이해를 돕기위한 값)\r\n* f의 initial은 1\r\n* f는 (a의 bi제곱 mod n)을 의미\r\n* **f는 일단 제곱을 무조건 시킴**  + (c = cx2)\r\n* 해당 bit인 bi가 1일 경우\r\n  * c = c+1\r\n  * f 에 a를 곱함\r\n\r\n> 운이 좋을 경우 (1000000)\r\n>\r\n> : 제곱만 수행 (곱셉 연산 한 번)\r\n>\r\n> 운이 나쁠 경우 (1111111)\r\n>\r\n> : 제곱과 곱하기를 수행 (곱셈 연산 두 번)\r\n>\r\n> 지수 e가 2048일 경우\r\n>\r\n> 즉, 총 log2 n ~ 2log2n 의 연산을 수행\r\n>\r\n> * 운이 나쁘면 연산 두 개를 하므로 두 배\r\n>\r\n> * 즉, (2048 ~ 4096)\r\n>\r\n> * 평균적으로 3/2 log2n (3072)\r\n>\r\n> 만약 이렇게 로그에 기반해서 연산안하고 바로 a x a x a x ...a 했다면 2^2048번의 연산을 수행해야한다고함\r\n\r\n\r\n\r\n### Efficient Operation Using the Public Key\r\n\r\n근데 저렇게 해도 숫자가 너무 커서 오래걸림\r\n\r\n그래서 e를 2^16 +1로 고정(어차피 public key라 고정해도 상관없음)\r\n\r\n* 17bit - 맨 앞과 맨 뒤만 1이고 나머지는 0\r\n* 제곱 15번, 곱셈 2번 (위의 2048보다 훨씬 줄어듦)\r\n\r\n2^16 +1하면  제곱 16번 + bit 1인게 두개라서 2번 곱셈\r\n\r\n가끔 3이나 17같은 엄청 작은 숫자를 쓰기도 하나 공격에 취약할수도있음\r\n\r\n**d는 프라이빗이라 고정해놓으면 안됨**\r\n\r\n\r\n\r\n### Attack against RSA\r\n\r\n* Brute force\r\n  * d에 모든 값 대입 \r\n  * 2048가지의 경우 존재 너무 오래걸림\r\n* Mathematical attacks\r\n  * 소인수 p와 q의 쌍을 구하려함\r\n* Chosen ciphertext attack\r\n  * RSA의 구조적인 특성을 이용한 공격\r\n  * homomorphic 특성 이용\r\n* Implementation attacks\r\n  * 하드웨어적 구현상의 문제\r\n  * 수행하는데 걸리는 시간, power, cache\r\n\r\n\r\n\r\n\r\n### Factoring Problem\r\n\r\n* n으로 p, q두 쌍을 구할 수 있으면 RSA는 깨짐 - n을 p, q로 factoring\r\n\r\n> 1999년에 실제 RSA에서 쓰는 512bit까지 팩토링 할 수 있게됨\r\n\r\n\r\n\r\n## Chosen Ciphertext Attack (CCA)\r\n\r\n* 공격자가 Plain text와 Cipher text의 쌍을 알 때 private key없이 어떤 Cipher text의 Plain text를 추측할 수 있는 것\r\n\r\n* 공격자가 어떤 C에 대한 P를 물어봐서 P를 얻어냄\r\n\r\n* 이를 바탕으로 또 다른 C를 물어보지않고도 P를 추측하면 공격자가 성공했다고 판단\r\n\r\n* 우리가 앞에서 봤던 rsa(textbook rsa)는 이런 공격법에 취약. \r\n\r\n* ex\r\n\r\n  > C의 P를 구하고자 할 때\r\n  >\r\n  > C' = C x 2^e mod n\r\n  >\r\n  > C'의 P를 요청함\r\n  >\r\n  > P' = C'^d mod n =  (C x 2^e)^d mod n = C^d x 2 mod n\r\n  >\r\n  > 즉 C의 P는 P'에 2의 역원을 곱하면 된다\r\n\r\n이런 공격을 방지하기 위해 RSA에 특별한 구조를 넣게 되어있음 RSA Security- OAEP\r\n\r\n안전성때문에 RSA-OAEP 사용\r\n\r\n\r\n\r\n### OAEP(Optimal Asymmetric encryption padding)\r\n\r\n> 원래는 M에 e제곱을 해서 암호화를 했지만 OAEP에서는 M을 인코딩한 EM을 e제곱한다\r\n\r\n인코딩방법\r\n\r\n* M에 0을 쭉 채워넣은 패딩을 추가\r\n* 파라미터를 해쉬함 (파라미터는 공개됨)\r\n* 해시 + 패딩 + M을 더해서 데이터블록생성\r\n* 암호할때마다 매번 생성하는 랜덤 시드를 MGF돌림(MGF도 해시함수의 일종)\r\n* MGF한 seed와 DB를 xor연산\r\n* DB에 위의 MGF가 아닌 또 다른 MGF를 돌린후 seed와 xor해서 maskedseed를 얻는다\r\n* maskedseed + maskedDB 형태인 EM획득\r\n\r\n복호화 방법\r\n\r\n> 암호문을 복호화하면 EM이 나옴\r\n>\r\n> EM의 형식이 맞는지 체크하는 과정이 있음\r\n\r\n* EM을 파싱해서 앞부분과 뒷부분으로 나눔(maskedseed + maskedDB)\r\n* maskedDB에 해시함수 적용\r\n  * 해시함수는 모두에게 공개됨\r\n* maskedseed와 해시함수를 적용한 maskedDB를 xor해서 seed값을 얻는다\r\n* xor과 MGF로 DB도 얻는다\r\n* 파라미터를 해시함수로 돌려서 DB의 앞부분이 나오는지 확인\r\n  * MAC(Message Authentication)과 유사\r\n  * 정상적인 구조인가 확인\r\n  * 공격자가 만든 임의로 조작된 Ciphertext였다면 인증이 안됨\r\n  * 임의로 조작됐다면 파라미터를 해시함수 적용했을때 원하는 값이 안나옴\r\n  * 이럴 땐 Decryption 결과 안돌려줌\r\n\r\n> 그 외 장점\r\n>\r\n> 랜덤 시드값을 사용하므로 같은 M이라도 다른 결과가 나옴\r\n>\r\n> 이전 M의 쌍을가지고 추측이 어려움\r\n\r\n\r\n\r\n## Side Channel Attack\r\n\r\nimplementation attack의 하나\r\n\r\n알고리즘을 실행시키고있는 기계 자체를 공격\r\n\r\n알고리즘을 실행하면 기계에서 부수적인 정보가 나옴\r\n\r\n* Timing attack : 누군가 private key를 가지고 연산을 하고있을 때 private key에 따라 연산 시간이 달라질수도있다\r\n  * C^d mod n 할 때  앞에서 비트 값이 0이면 제곱만, 1이면 제곱+곱셈연산 수행\r\n  * 연산 시간에 따라 1인지  0인지 추측 가능\r\n\r\n* Power analysis : 전력 소모의 패턴을 분석. 제곱연산할때의 전력소모와 곱셈 연산을 할 때 전력소모를 구해서 분석. (전자기파 분석, 클라우드 분석)\r\n  * 1이면 S M , 0이면 S\r\n\r\n* Cache\r\n  * 논리적인 자원은 분리되어있지만 물리적인 자원은 분리되어있지않음\r\n  * 캐시가 어떤 형태로 플래쉬되는지 패턴을 통해 추측가능\r\n\r\n<br/><br/>\r\n\r\n어떻게 막나?\r\n\r\n### Constant-time algorithm\r\n\r\n* 알고리즘을 비트가 0이냐 1이냐에 따라서 바뀌지않게 만든다\r\n* M을 항상 하게 바꿈\r\n* f x f 연산 결과값을 f에넣지않고 x[0]또는 x[1]에 넣는다\r\n* 1이냐 0이냐에 따라 X[0] or X[1] 반환\r\n* 비트가 0이든 1이든 항상 곱셈을 수행한다.\r\n* 시간이 더 오래 걸리긴 함(필요없는 M도 하게 되어서)\r\n* 시간분석 대응가능. 일정한 시간 소요\r\n\r\n\r\n\r\n### Fault-Based Attack\r\n\r\n좀 더 공격적\r\n\r\n아까는 공격자가 그냥 관찰만\r\n\r\n연산이 수행되는 와중에 강력한 전압을 걸어주는등의 공격을 해서 오류가 생기게\r\n\r\n(ex) 내 버스카드에 물리적으로 충격을 걸어서(전압공격등) 잔액정보를 마음대로 조작~~)\r\n\r\n### Misconceptions Concerning Public-Key Encryption\r\n\r\n* 공개키 알고리즘은 암호 공격에 대해서 시메트릭 암호보다 안전하다\r\n\r\n> 맞을수도있고 틀릴수도있음\r\n>\r\n> AES 128비트 버전과 RSA 2048 어떤게 더 안전할까?\r\n>\r\n> RSA가 시도할 경우의 수가 더 많음\r\n>\r\n> 그러나 이렇게 무작위로 하지않음\r\n>\r\n> 팩토링을 사용하면 효율적으로 가능. AES보다 더 빠르게\r\n>\r\n> 공격할 방식 자체가 다르기 때문에 맞을수도있고 틀릴수도있음\r\n\r\n\r\n\r\n* 공개키 알고리즘이 대칭 알고리즘을 완벽하게 대체할 수 있는 알고리즘이다\r\n\r\n  x : 성능 측면에서 대칭 알고리즘이 훨씬 유리\r\n\r\n  키 공유 문제에선 공개키 알고리즘이 유리\r\n\r\n  보통 둘 다 사용하는 하이브리드 알고리즘 사용\r\n\r\n* 대칭 암호의 키공유문제를 해결하기 위해 나온게 공개키 알고리즘 : 공개키 암호를 쓰면 키 분배를 하는데 전혀 문제가 없을까?\r\n\r\n  x : 상대적으로 대칭 암호에 비해 키 공유가 나은 것이지 근본적으로 해결되는 것은 아니다\r\n\r\n  시메트릭 : 키를 안전하게 전달하는 것이 목표\r\n\r\n  퍼블릭키 : 키를 숨기면서 전달할 필요가 없음. \r\n\r\n  대칭 암호에서의 키 분배는 confidentialiry\r\n\r\n  퍼블릭키는 authentication과 Integrity 보장해야함\r\n\r\n  공격자가 다른 사람의 공개키인척 공유하면 안됨\r\n\r\n  이런 문제때문에 공개키 인증서가 나옴\r\n\r\n  정부에서 공인된 절차로 만든게 공인인증서\r\n\r\n  \r\n\r\n\r\n\r\nRSA에서 Factoring과 Discrete Logarithm(이산대수)이 중요하다...\r\n"},{"excerpt":"패킷(Packet) 네트워크 계층 (Layer 3)에서 정의되는 데이터 단위 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함 헤더와 데이터로 구성됨 헤더 : 운송장, 데이터 : 물품 Packet Sniffing 네트워크 트래픽을 도청하고 민감한 정보를 수집하는 행위 passive attack 노출된 ID, password, cookie등을…","fields":{"slug":"/arp-attack/"},"frontmatter":{"date":"April 30, 2022","title":"9-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n## 패킷(Packet)\r\n\r\n- 네트워크 계층 (Layer 3)에서 정의되는 데이터 단위\r\n- \r\n- 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함\r\n- 헤더와 데이터로 구성됨\r\n- 헤더 : 운송장, 데이터 : 물품\r\n\r\n## Packet Sniffing\r\n\r\n- 네트워크 트래픽을 도청하고 민감한 정보를 수집하는 행위\r\n\r\n- passive attack\r\n\r\n- 노출된 ID, password, cookie등을 엿볼 수 있는 위험\r\n\r\n  > HTTP Cookie\r\n  >\r\n  > - 웹 사이트에 접속할 때 웹 사이트 서버가 내 컴퓨터에 보내는 임시 파일이다\r\n  > - 크기는 4KB 이하로 매우 작다\r\n\r\n- 다운로드 불가능한 파일을 덤프하거나 엿볼 수 있는 위험\r\n\r\n- 스위치/라우터로 분리된 네트워크들 간에는 sniffing 불가\r\n\r\n  - A공유기 구역에서 B공유기 구역으로 sniffing 불가능\r\n  - 허브는 가능. broad cast 가능\r\n\r\n## Wireshark\r\n\r\n패킷 분석 프로그램\r\n\r\n### Promiscuous mode란?\r\n\r\n> 정상적인 네트워크 카드는 네트워크 카드에 인식된 2계층(MAC)과 3계층(IP) 정보가 자신의 것과 일치하지 않는 패킷은 무시한다\r\n>\r\n> 정상적인 경우에는 이러한 패킷들을 처리할 이유가 없기 때문\r\n>\r\n> 모든 패킷을 일일이 CPU가 확인하여 처리하면 CPU에 부하가 많아짐\r\n\r\n- 위의 필터링을 끈다\r\n- 2계층과 3계층에서 필터링을 하지 않는다\r\n\r\n### Capture filter\r\n\r\n- 그렇다고 다 필터안하면 너무 많음. 적당히 필터해야함\r\n- 캡처를 시작하기 전에 필터를 적용하는 방식\r\n- 필요성1 : 필터없이 캡처를 시작할 경우 많은 양의 패킷으로 인해 원하는 패킷을 찾기 힘들다\r\n- 필요성2 : 캡처를 시작한 이후 Display Filter를 적용할 수 있으나 Display Filter는 모든 패킷을 캡처한 후 필터링을 진행하는 것이기 때문에 불필요한 패킷이 캡처되어서 파일의 크기가 커진다.\r\n- 이때 Capture Filter를 적용하면 불필요한 패킷은 사전에 필터링되어서 Wireshark 프로그램에 걸리는 부하를 효과적으로 줄일 수 있다\r\n\r\n### Display Filter\r\n\r\n- 캡처를 한 뒤 원하는 패킷만 화면에 출력한다\r\n- Capture filter와 문법이 다르다\r\n- 원하는 패킷을 캡처한 뒤 세부 분석을 하기 위해 쓰인다\r\n\r\n#### 캡처 방법\r\n\r\n- 특정 호스트의 패킷 캡처\r\n  - ip.addr == 10.10.50.15\r\n- 특정 두 호스트의 통신 패킷 캡처\r\n  - host 10.10.50.170 and host 10.10.50.15\r\n- 특정 포트 패킷 캡처\r\n  - tcp.port == 80\r\n- 특정 두 포트 전부 패킷 캡처\r\n  - tcp.port ==80 or tcp.port ==1770\r\n- 특정 호스트의 특정 포트 패킷 캡처\r\n  - ip.addr == 10.10.50.170 and tcp.port == 80\r\n- 특정 패킷만 캡쳐 안함\r\n  - not arp\r\n- 출발지나 목적지 IP 주소로 검색\r\n  - ip.addr == 192.168.0.1\r\n- 출발지 IP 주소로 검색\r\n  - ip.src == 192.168.0.1\r\n- 도착지 IP 주소로 검색\r\n  - ip.dst == 192.168.0.1\r\n- 포트로 검색\r\n  - tcp.port == 443\r\n- 출발지 포트로 검색\r\n  - tcp.srcport == 443\r\n- 도착지 포트로 검색\r\n  - tcp.dstport == 443\r\n\r\n### Practice 2 : FTP Packets\r\n\r\n- FTP\r\n\r\n  > - 파일 전송 프로토콜\r\n  > - TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 하기 위한 프로토콜\r\n  > - FTP는 통신을 위해 2개의 port를 사용함 (command, data transfer)\r\n  > - 보통 FTP 프로토콜은 20번 포트 (for command)\r\n  > - FTP-DATA 프로토콜은 21번 포트 (for data transfer)\r\n\r\n- FTP를 사용하지 말아야 하는 이유 ?\r\n  - **평문** 파일 전송 프로토콜이기때문\r\n\r\n## MAC Address / IP Address\r\n\r\n- MAC Address : Datalink 계층의 주소\r\n- IP Address : Network 계층의 주소\r\n- 도메인 이름은 정류장 이름\r\n- IP는 정류장 번호\r\n- MAC은 정류장 주소\r\n\r\n### MAC(Media Access Control) 주소\r\n\r\n- NIC(네트워크 인터페이스 카드)에 할당된 고유한 식별자\r\n- 로컬 네트워크 통신에 사용\r\n- 48bit의 주소길이\r\n- 관리자 계정은 PC의 MAC주소를 직접 변경할수도 있음\r\n  - window는 ipconfig/all\r\n  - mac은 ifconfig\r\n\r\n#### MAC Address 를 사용하는 이유\r\n\r\n- 서버의 NIC와 내 컴퓨터의 NIC끼리 통신\r\n- Datalink layer 통신을 위해서는 MAC 주소 알아야함\r\n\r\n### ARP의 메커니즘\r\n\r\nIP주소에 해당하는 MAC주소를 알고싶음\r\n\r\n- IP를 가지고 broad cast request로 IP에 해당하는 컴퓨터를 찾는다\r\n\r\n- 해당 IP를 가지는 컴퓨터가 Unicast Reply로 자신의 MAC주소를 알려준다\r\n\r\n  > ARP 취약점\r\n  >\r\n  > System B(컴퓨터)가 정상적인 노드인지 보장 못함(인증없음)\r\n  >\r\n  > B가 정말로 해당 IP를 가진 컴퓨터인지, 악의적인 목적을 지닌 공격자인지 판별할 수 없다\r\n\r\nex)\r\n\r\n#### ARP Request : 1292.168.0.16?\r\n\r\n- 192.168.0.50(00:E0:91:DB:3C)이 192.168.0.16의 MAC주소를 알기 위해 ARP Request 메시지를 브로드 캐스팅\r\n\r\n#### MAC 주소를 알고있음에도 ARP 요청이 발생하는 경우\r\n\r\nex. 컴퓨터가 바뀐 경우? IP주소는 그대로 지만 MAC 주소 변경됨\r\n\r\n이런 경우 주기적으로(30초마다) ARP요청. (유니캐스트)\r\n\r\nreply가 오면 살아있고 응답이 없으면 문제가 생긴것. 알고있는 MAC주소가 유효하지않으므로 다시 브로드캐스트\r\n\r\n### ARP cache\r\n\r\n#### ARP cache table\r\n\r\n- MAC주소와 IP주소를 매핑하고 있는 테이블\r\n\r\n  1. static ARP cache entry\r\n\r\n     - 수동으로 추가 가능. (컴퓨터 재시작시 삭제)\r\n\r\n  2. dynamic ARP cache entry\r\n     - ARP reply packet을 받으면 OS에 의해 자동으로 저장\r\n     - 30초간 지속\r\n\r\n## ARP Spoofing(위장)\r\n\r\n- 근거리 통신망(LAN)하에서 ARP 메시지를 이용하여 상대방의 데이터 패킷을 중간에 가로채는 중간자 공격(Man-in-the-middle-Attack)기법이다.\r\n- 가로챈 패킷을 변조하는 Active attack까지 수행 가능\r\n- 이 공격은 데이터 링크(Layer 2)상의 프로토콜인 APR 프로토콜을 이용하기 때문에 근거리 상의 통신에서만 사용할 수 있는 공격이다\r\n\r\n#### 스위치를 통하는 패킷의 흐름\r\n\r\n- 유니캐스트 패킷\r\n- 스위치가 MAC 주소 테이블을 유지/관리\r\n\r\n- 스위치로 묶였다면 하드웨어적으로 연결을 해줘서 Promiscuous mode 효과 없음\r\n\r\n- 허브로 묶였다면 모든 시스템을 다 봐서 Promiscuous mode 효과 있음\r\n- 스니핑(도청) != 스푸핑\r\n\r\n#### 스위치로 묶인 네트워크일 경우 어떻게 스니핑할까?\r\n\r\n공격 시나리오\r\n\r\n- 공격 대상(1번)에게 조작된 정보를 보내 수신지를 변경 (ARP 패킷 관련)\r\n- 공격자의 NIC는 promiscuous 모드\r\n- 수신된 패킷은 relay함 (Packet forwarding) : 정상인척 패킷을 받아서 보내줌\r\n- 패킷 모니터링 룰 실행\r\n\r\n## Detect ARP Spoofing\r\n\r\n결국은 스위치가 잘해줘야함. (ex. 방화벽)\r\n\r\n- ARP 탐지 솔루션 또는 네트워크 방화벽\r\n  - arpwatch(\\*nix 계열)\r\n  - xarp(NT/\\*nix)\r\n  - ai 기반 탐지?\r\n- Promiscuous 모드로 동작하는 Host 탐지\r\n  - ARP Spoofing 공격 시도 가능성이 높기 때문\r\n- ARP Cache 테이블을 정적으로 유지\r\n\r\n## DNS(Domain Name System) Spoofing\r\n"},{"excerpt":"패킷(Packet) 네트워크에서 데이터를 주고받는 단위 네트워크 3계층에서 정의되는 데이터 단위 그 외에도 OSI의 각 계층에서 주고 받는 정보의 단위를 모두 패킷이라고 총칭하기도함 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함 헤더와 데이터로 구성됨 헤더 : 운송장, 데이터 : 물품 Packet Sniffing src가 dst에게 보내…","fields":{"slug":"/1-network-security/"},"frontmatter":{"date":"April 30, 2022","title":"9-1 ","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## 패킷(Packet)\r\n\r\n네트워크에서 데이터를 주고받는 단위\r\n\r\n* 네트워크 3계층에서 정의되는 데이터 단위\r\n* 그 외에도 OSI의 각 계층에서 주고 받는 정보의 단위를 모두 패킷이라고 총칭하기도함\r\n* 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함\r\n* 헤더와 데이터로 구성됨\r\n* 헤더 : 운송장, 데이터 : 물품\r\n\r\n\r\n\r\n## Packet Sniffing\r\n\r\n> src가 dst에게 보내는 패킷을 중간에 훔쳐봄\r\n\r\n* 네트워크 트래픽을 도청하고 민감한 정보를 수집함\r\n  * 노출된 ID, password, cookie등을 엿볼 수 있음\r\n  * HTTP Cookie : 평문 형태의 정보 (session hijacking) (평문이 아니라 암호문이라면 패킷이 노출되어도 정보 노출 위험을 최소화시킬 수 있긴함)\r\n* 다운로드 불가능한 파일을 덤프하거나 엿볼 수 있는 위험\r\n* Passive attack\r\n\r\n\r\n\r\n### 스니핑이 가능한 조건\r\n\r\n* 스위치/라우터로 분리된 네트워크들 간에는 스니핑 불가\r\n  * 허브로는 가능 (브로드캐스트)\r\n* 묶여진 내부 네트워크에서만 스니핑 가능\r\n  * 예시 사진 1번에서는 가상 네트워크 구역내에서만 스니핑 가능\r\n  * 예시 사진 2번에서 A공유기 구역의 pc가 B공유기 구역에 스니핑 불가능\r\n\r\n\r\n\r\n## Wireshark\r\n\r\n패킷 분석 프로그램\r\n\r\n\r\n\r\n### Promiscuous mode란?\r\n\r\n> 네트워크 패킷 필터링을 하지않는다\r\n\r\n정상적인 경우, 네트워크 패킷들을 하드웨어적으로 필터링함\r\n\r\n* 네트워크 카드에 인식된 2계층(MAC)과 3계층(IP) 정보가 자신의 것과 일치하지않는 패킷은 무시한다\r\n* 무시하지않고 모든 패킷을 일일이 CPU가 확인하여 처리하면 CPU에 부하가 많아짐\r\n\r\nPromiscuous mode를 하면 패킷을 필터링하지않는다\r\n\r\nex) 와이파이 패킷을 promiscuous mode로 해두면 컴퓨터에서 패킷을 확인했는데 핸드폰의 패킷도 관찰 가능 \r\n\r\n\r\n\r\n> Promiscuous 모드로 모든 패킷을 확인하므로 나에게 필요한 패킷을 필터링하는게 중요하다\r\n\r\n\r\n\r\n### Capture filter\r\n\r\n> 캡처를 시작하기전에 필터를 적용하는 방식\r\n>\r\n> 불필요한 패킷을 사전에 필터링해서 Wireshark 프로그램에 걸리는 부하를 줄일 수 있다\r\n\r\n* 필터없이 캡처를 시작할 경우 많은 양의 패킷으로 인해 원하는 패킷을 찾기 힘듦\r\n* 캡처를 시작한 이후 Display Filter를 적용할 수 있으나 Display Filter는 모든 패킷을 캡처한 후 필터링을 진행하는 것이기 때문에 불필요한 패킷이 캡처되어서 파일의 크기가 커진다\r\n\r\nex)\r\n\r\n* host 10.10.50.170 : 특정 호스트만 캡처\r\n\r\n* port 80 : 80번 포트만 캡처\r\n* host 10.10.50.170 and port 80 : &&와 ==, || 연산자 사용 가능\r\n\r\n\r\n\r\n### Display Filter\r\n\r\n> 캡처를 한 뒤 원하는 패킷만 화면에 출력\r\n\r\n* Capture filter와 문법이 다름\r\n\r\nex)\r\n\r\n* ip.addr = 10.10.50.170\r\n* host 10.10.50.170 and host 10.10.50.15\r\n* tcp.port = 80\r\n\r\n\r\n\r\n### 예제2 : FTP Packets\r\n\r\n#### FTP (File Transfer Protocol)\r\n\r\n* 파일 전송 프로토콜\r\n* FTP는 통신을 위해 2개의 port를 사용함 (command, data transfer)\r\n* 보통, command용으로 20번 포트, data-transfer 용도로 21번 포트를 사용한다\r\n* 평문 파일 전송 프로토콜이라 해킹이 쉬움\r\n\r\n\r\n\r\n\r\n\r\n## MAC Address\r\n\r\n* NIC(네트워크 인터페이스 카드)에 할당된 고유한 식별자\r\n* 로컬 네트워크 통신에 사용\r\n* 48-bit의 주소길이\r\n* 관리자 계정은 PC의 MAC주소를 직접 변경할 수도 있음\r\n  * LAN카드내에 박혀있는 하드웨이 맥주소를 바뀔 수 없지만 PC에 로드되어있는 맥주소는 변경이 가능하다\r\n\r\n> cmd에 ifconfig 명령어로 맥주소 확인 가능(리눅스, 맥)\r\n>\r\n> 윈도우는 ipconfig/all \r\n\r\n\r\n\r\n## LAN과 WAN (Network layer)\r\n\r\n* Datalink layer 통신을 위해서는 MAC  주소를 알아야함\r\n\r\n* 로컬 네트워크 (LAN) : 서버의 NIC와 내 컴퓨터의 NIC끼리 통신\r\n* 외부 네트워크와 연결 (WAN) : 다른 LAN과 연결됨 (라우팅)  ex. 인터넷\r\n\r\n\r\n\r\n## ARP 메커니즘\r\n\r\n> ARP(Address Resolution Protocol) \r\n>\r\n> * 맥주소를 알기위한 프로토콜\r\n\r\n\r\n\r\n#### ARP를 활용하여 목적지의 MAC주소 찾는 방법\r\n\r\n* Broadcast Request \r\n  * ip 주소를 가지고 브로드캐스트함\r\n  * 이 ip주소 가지고 있는애 누구야!\r\n* Unicat Reply (1대1)\r\n  * 해당 ip주소를 가지고 있는 애가 자신의 mac주소를 답변해줌\r\n\r\n#### ARP 취약점\r\n\r\n답변을 해준 시스템이 정상적인 노드인지 보장 못함 (인증없음)\r\n\r\n원하는 맥주소를 가지고있는 애가 아님에도 속이고 reply 보낼수도있음 - ARP Request\r\n\r\n\r\n\r\n#### MAC주소를 이미 알고있음에도 ARP요청을 보내는 경우\r\n\r\n* 브로드 캐스트가 아니라 유니캐스트로 보냄\r\n* MAC주소가 바뀔수도있기때문\r\n* 똑같은 ip를 쓰지만 컴퓨터가 바뀔수도있음\r\n* 30초정도마다 ARP요청을 다시 보냄\r\n* 보냈는데 응답이 없으면 다시 브로드캐스트\r\n\r\n\r\n\r\n### ARP cache\r\n\r\n> ARP cache table\r\n>\r\n> * MAC 주소와 IP주소를 매핑하고 있는 테이블\r\n\r\n1. static ARP cahce entry\r\n   * 수동으로 추가 가능 (컴퓨터 재시작시 삭제)\r\n2. dynamic ARP cache entry\r\n   * ARP reply packet을 받으면 OS에 의해 자동으로 저장\r\n   * 30초간 지속\r\n\r\n\r\n\r\n## ARP Spoofing\r\n\r\nspoofing : 위장\r\n\r\n> 근거리 통신망(LAN)하에서 ARP 메시지를 이용하여 상대방의 데이터 패킷을 중간에서 가로채는 중간자 공격 \r\n\r\n* 가로챈 패킷을 변조하는 Active attack도 가능\r\n* 데이터 링크(Layer 2)상의 프로토콜인 ARP프로토콜을 이용하기 때문에 근거리 상의 통신에서만 사용할 수 있는 공격\r\n\r\n\r\n\r\n### 스위치로 묶인 네트워크에서 스니핑 시도\r\n\r\n> 허브는 패킷을 브로드 캐스트로 모두에게 보내기때문에 Promiscuous 모드를 키면 패킷을 받아볼 수 있지만 스위치는 MAC주소 테이블을 사용해서 해당 pc에게만 패킷을 보내기때문에 Promiscuous mode를 해도 패킷을 훔쳐볼 수 없다.\r\n\r\n#### 스니핑을 위해 스푸핑 시도!\r\n\r\n> 스니핑 : 도청\r\n>\r\n> 스푸핑 : 패킷이 나를 거치게 함\r\n\r\n1. 공격 대상에게 조작된 정보를 보내 수신지 변경 - 스위치의 맥주소테이블을 감염시킴\r\n2. 공격자의 NIC는 promiscuous 모드로\r\n3. 수신된 패킷은 relay함 (Packet forwarding) : 잘못된걸 눈치채지못하게 원래 받아야 할 애한테 다시 보내줌\r\n4. 패킷 모니터링 툴 실행\r\n\r\n\r\n\r\n## ARP spoofing 탐지 방법\r\n\r\n결국은 스위치가 잘해줘야함\r\n\r\n* ARP 탐지 솔루션 또는 네트워크 방화벽\r\n  - arpwatch(\\*nix 계열)\r\n  - xarp(NT/\\*nix)\r\n  - ai 기반 탐지?\r\n* Promiscuous 모드로 동작하는 host탐지\r\n* ARP cache 테이블을 정적으로 유지\r\n\r\n\r\n\r\n## DNS spoofing\r\n\r\n> DNS Server가 올바른 Reply를 해주기전에 공격자가 Reply를 해줘서 웹을 연결시킴\r\n>\r\n> 이후 들어오는 DNS Server의 Reply는 무시됨"},{"excerpt":"django.contrib.auth.models django.contrib.auth.models를 사용해 이미 만들어진 User모델을 가져와 사용할 수 있다 django.contrib.auth.models에서 직접 User model을 참조해오거나 getusermodel () 을 사용해서 유저 모델을 가져오거나 settings.py에 을 지정해서 유저 모…","fields":{"slug":"/auth-user/"},"frontmatter":{"date":"April 28, 2022","title":"AUTH_USER_MODEL 사용","tags":["django"]},"rawMarkdownBody":"\r\n## django.contrib.auth.models\r\n\r\n- django.contrib.auth.models를 사용해 이미 만들어진 User모델을 가져와 사용할 수 있다\r\n- django.contrib.auth.models에서 직접 User model을 참조해오거나\r\n- get_user_model () 을 사용해서 유저 모델을 가져오거나\r\n- settings.py에 `AUTH_USER_MODEL`을 지정해서 유저 모델을 가져올 수 있다\r\n\r\n> from django.contrib.auth.models import User\r\n>\r\n> 를 사용해 직접 User를 참조하는 방법은 이후 모델이 바뀌거나 코드를 수정해야할 일이 생길 때 유연성이 떨어진다\r\n\r\n> get_user_model()은 객체 인스턴스를 리턴해서 Django 앱이 로드되는 그 순간에 실행되기 때문에 반드시 유효한 사용자 모델 객체를 리턴한다는 보장이 없다.\r\n> 문자열이 아닌 유저 클래스 자체를 써야할 때 사용하도록한다.\r\n>\r\n> AUTH_USER_MODEL은 외래키 모델을 전달할 때 문자열로 전달한다. 외래키가 임포트될 때 모델 클래스 탐색에 실패하면 모든 앱이 로드될 때까지 실제 모델 클래스의 탐색을 미루기때문에 항상 올바른 사용자 모델을 얻을 수 있다\r\n\r\n## AUTH_USER_MODEL 등록해보기\r\n\r\nDjango자체에 디폴트로\r\n\r\n```\r\nLOGIN_URL = '/accounts/login/'\r\n\r\nLOGIN_REDIRECT_URL = 'accounts/profile/'\r\n```\r\n\r\n로 처리되어있다\r\n\r\ndjango 공식 깃허브에 accounts앱이 있으므로\r\n\r\n- accounts라는 이름을 가진 앱을 만든다\r\n- accounts의 models.py에 `django.contrib.auth.models`의 AbstractUser를 상속한 User클래스를 만들어준다\r\n- accounts라는 앱에서 User모델을 따로 만들었으므로 커스텀이 가능하다\r\n\r\n\\# accounts/models.py\r\n\r\n```python\r\nfrom django.db import models\r\nfrom django.contrib.auth.models import AbstractUser\r\n\r\nclass User(AbstractUser):\r\n    pass\r\n```\r\n\r\n- config의 settings.py 에 AUTH_USER_MODEL을 등록한다\r\n\r\n\\# config/settings.py\r\n\r\n```python\r\nAUTH_USER_MODEL = 'accounts.User'\r\n```\r\n"},{"excerpt":"7-1 스레드! 멀티스레드! 스레드를 어떻게 구현하는지! 스레드라는게 왜 나왔나요? cpu 하나의 성능 개선 : 한계에 다다름 cpu를 여러개? 멀티 코어 = 멀티 프로그래밍 여러개의 프로그램을 돌릴 수 있게 됨 A와 B가 각기 다른 일을 수행(멀티 프로그래밍) 여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드) 여러개의 코어에서 한 프로그램…","fields":{"slug":"/7-1/"},"frontmatter":{"date":"April 22, 2022","title":"os 7-1","tags":["OS"]},"rawMarkdownBody":"\r\n7-1\r\n\r\n스레드! 멀티스레드! 스레드를 어떻게 구현하는지!\r\n\r\n#### 스레드라는게 왜 나왔나요?\r\n\r\ncpu 하나의 성능 개선 : 한계에 다다름\r\n\r\ncpu를 여러개? 멀티 코어 = 멀티 프로그래밍\r\n\r\n여러개의 프로그램을 돌릴 수 있게 됨\r\n\r\n1. A와 B가 각기 다른 일을 수행(멀티 프로그래밍)\r\n2. 여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드)\r\n\r\n여러개의 코어에서 한 프로그램이 하는 일을 분배해서 수행\r\n\r\n#### 스레드가 생기고 나온 문제\r\n\r\n- Dividing activites (일을 어떻게 나눌지)\r\n- Balance (혼자 팀플 ...)\r\n- Data splitting (데이터를 어떻게 나눠줄지)\r\n- Data dependency (한 명이 수정했는데 다른 사람들이 그 수정한 파일에 기반을 두고 있을 경우 어떻게 할 것 인지)\r\n- Testing and debugging\r\n\r\nParallelism : 여러 코어에서 동시에 수행 (멀티 코어)\r\n\r\nConcurrency : 하나의 코어에서 수행\r\n\r\n#### 기존 프로세스의 특성\r\n\r\n**하나의 프로세스는 두 가지 특성으로 나눌 수 있다**\r\n\r\n_an execution stream in the context of a particular process state(resource)_\r\n\r\n- unit of resource ownership\r\n\r\n> resource ownership을 가진 애를 process라고 부르자!\r\n\r\n- unit of execution stream\r\n\r\n> execution stream은 나눌 수 있지않을까?\r\n>\r\n> 외부에서 돌아가는 excuted stream을 thread라고 부르자!\r\n>\r\n> 하나의 프로그램 안에서 execution stream을 여러 개로 나눔\r\n\r\n- execution stream이 여러 개라면 각각의 stack과 register가 필요하다! stack, reg 스레드마다 분리 (code, data, files는 공유함)\r\n\r\n#### 스레드의 특징\r\n\r\n- 스레드는 state 3개 (running, ready, stopped(brocked = wait))\r\n\r\n  - 그럼 생성 종료는 어떻게?\r\n\r\n    실제로 os상에서 구현할 때는 라이브러리 같은걸 제공하게되는데 거기서는 생성, 종료 state를 추가적으로 만들긴함. 기본적인 state임 신경안써도 ㄱㅊ\r\n\r\n- 프로세스 state는 5개 (new, run, wait, ready, terminate)\r\n\r\n- 프로세스가 termination되면 당연히 그 안의 스레드도 termination\r\n\r\n- 스레드마다 context(reg, stack에 대한 정보들)를 따로 관리해야한다\r\n\r\n- stack이 따로 있고 static memory(for local vairables)도 존재할수도 있음\r\n\r\n- 그러나 사실상 접근하는 메모리 공간은 process의 메모리 공간에 공유함\r\n\r\n  ![](./thread.png)\r\n\r\n  - 프로세스의 모든 스레드들은 이걸 공유함 (그림의 share부분 참고)\r\n\r\n- 여러 os에서 다양한 형태의 스레드를 사용한다\r\n- MS-DOS : 싱글유저 - 싱글스레드\r\n- 초창기 유닉스 : 여러 개의 프로세스 but 프로세스당 스레드 하나\r\n- 현대 유닉스 : multiple threads\r\n\r\n멀티스레드 어디서 사용? 보통서버 아키텍처에서 많이사용\r\n\r\nex. 이메일 서비스\r\n\r\n![](./email.png)\r\n\r\n멀티스레드.......... vs 멀티프로세스\r\n\r\n뭔 차이냐....... 이 말이여\r\n\r\n프로세스 생성에 대한 오버헤드가 큼! 프로세스에 필요한 공간 할당. 메모리에 올려야 함\r\n\r\n멀티 스레드는 a,b,c도 같은 프로세스안에서 돌게하므로 성능상의 이득을 취하면서도 프로세스 생성에 대한 오버헤드도 줄일 수 있다!\r\n\r\n#### 멀티 스레드의 이점\r\n\r\n- Responsiveness(응답성)\r\n\r\n  - 위 예시에서 싱글스레드는 a를 처리해야 b처리 가능\r\n\r\n- Resource sharing\r\n  - 멀티 프로세스의 경우 각기 독립적인 메모리 공간을 사용\r\n\r\n> 멀티 프로세스는 각각 abc리퀘스트를 처리하기 위해서 프로세스를 따로 만들어줌. 각기 독립적인 메모리 공간. 따라서 프로세스들간 소통을 하기위해선 커널을 거쳐서 shared memory 나 message passing을 통해서 소통해야함\r\n>\r\n> 그러나 멀티 스레드는 같은 프로세스안 Resourcce sharing에 유리.\r\n\r\n- economy\r\n\r\n  - takes less time\r\n\r\n     뉴 스레드를 만드는게 프로세스를 만드는 것보다 빠름\r\n\r\n     프로세스는 모든 컨텍스트를 새로 만들고 초기화\r\n\r\n     스레드는 스레드 컨텍스트(stack)만 서로 만듦\r\n\r\n     마찬가지로 종료도 스레드가 유리\r\n\r\n     한 프로세스내에서 두 개의 컨텍스트를 스위치하는 시간도 빠름\r\n\r\n    코어가 늘어나는것에대해서 성능도 증가\r\n\r\n  - Uses very little resources\r\n\r\n    스레드가 필요한건스택과 per-thread staticy memory 뿐\r\n\r\n스레드가 많아지면 멀티프로세서같이 코어가 많은 아키텍처에서는 프로세스가 advantage를 얻을 수 있다\r\n\r\n## Threads Implementation\r\n\r\n1. user-level : 사용자가 코드에 작성하는 것(사용자가 나눈 일의 단위)\r\n2. kernel-level : 커널이 관리하는 스레드(cpu 자원 할당 단위)\r\n\r\n두 개를 나눠서 구현하게 됨\r\n\r\n### User-Level Threads : Multi thread using only user-level thread\r\n\r\n- 100% 유저 레벨\r\n\r\n- 커널은 얘의 존재를 모름. 커널이 보기에는 프로세스 하나\r\n\r\n- 유저레벨에서 코드를 나눠서 작성함\r\n\r\n- 이걸 위해 user-level library 존재\r\n\r\n**user-level library**\r\n\r\n    - 스레드 만들고 소멸\r\n    - 스레드간의 스케줄링\r\n    -\r\n    - 스레드 컨텍스트 스위칭될 때 컨텍스트를 saving and restore\r\n    - 스레드 간의 데이터 소통\r\n\r\n실질적으로 cpu할당은 프로세스단위로 이루어짐\r\n\r\n- 어플리케이션은 유저레벨 스레드를 사용해서 모든 스레드를 관리한다\r\n- 스케줄링도 어플리케이션안에서 다 함 ( 어플리케이션 맞춤)\r\n- 커널은 유저레벨스레드의 존재를 모르고 프로세스 하나가 동작하는줄 앎\r\n- 어떤 스레드가 blocking system call을 할 때 커널은 그 프로세스를 통째로 block, waiting시킨다\r\n- 장점\r\n  - 스레드간 스위칭을 할 때 커널이 관여를 안함 (오버헤드 없음 mode switching없음 usermode <-> kernel mode)\r\n  - 스케줄링이 베스트 알고리즘을 선택할 수 있다\r\n  - os에서 스레드모드를 지원하지않아도 라이브러리만 있으면 구현을 할 수 있다\r\n- 단점\r\n  - 어떤 스레드가 시스템콜을 날리면 모든 스레드가 block\r\n  - 코어가 여러개여도 활용을 모함 (한 책상을 여러명이 돌려씀)\r\n- 사실상 초기 스레드 모형이며 지금은 사용하지않음. 너무 구림\r\n\r\n### Kernel-Level Threads\r\n\r\n- one to one mapping between user-level and kernel-level\r\n- 유저레벨 스레드와 커널레벨 스레드가 둘 다 존재\r\n- 유저레벨 스레드와 커널레벨 스레드가 1대1 매핑\r\n- 유저 레벨 스레드 라이브러리를 쓰지않고 커널의 기능을 호출(api - kernel function)\r\n  - 커널이 프로세스뿐만아니라 스레드에 대한 컨텍스트 정보도 유치\r\n  - 스레드간 스위칭 지원\r\n  - 스레드 스케줄링\r\n  - synchronization\r\n- 사용자가 어플리케이션 내부적으로 따로 스레드를 생성하고 관리하는건 없고 사용자가 스레드를 만들고싶을 때는 시스템한테 요청을 함. 시스템이 스레드를 관리를 온전히 다 한다. 유저레벨에선 관리할 필요가 없음.\r\n- cpu 자원할당이 스레드 위주로 돌아감\r\n- 모든 스레드를 커널이 관리\r\n- 코드에서 유저레벨 스레드를 생성하면 실제 커널 레벨 스레드가 생성된다는 말\r\n- 장점:\r\n  - 여러개의 스레드를 여러개의 cpu코어에서 동시에 돌릴 수 있다\r\n  - 어떤 스레드 하나가 block되어도 다른 스레드가 돌아간다\r\n  - 커널에 대한 여러가지 루틴들도 멀티스레드처럼 만들 수 있다(뭔 소리?)\r\n- 단점:\r\n  - 스레드 스위칭자체가 컨텍스트 스위칭과 같은 오버헤드를 야기한다\r\n- modern linux, windows가 원투원 매핑 사용\r\n\r\n### Combined Threads\r\n\r\n`Many-to-Many`\r\n\r\n커널레벨모드도 유저레벨모드도 존재\r\n\r\n유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다\r\n\r\n커널은 사실상 스레드의 존재를 크게 의식하지않음\r\n\r\n커널은 단지 유저에게 virtual processor같은\r\n\r\n커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 스케줄링하고 관리해줌\r\n\r\n유저레벨 스레드는 커널레벨 스레드가 가상의 프로세서라고 생각하고 활용\r\n\r\n어떤 스레드를 어떤 프로세서에 넣을지 관리를 해줌\r\n"},{"excerpt":"Critical Section Problem 동기화! 각 프로세스의 코드에는 크리티컬 섹션이 존재한다 critical section : 공유 데이터가 업데이트 일어나는 부분 entry section : 크리티컬 섹션에 들어가기위한 코드의 부분 exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분 remainder section : 크리…","fields":{"slug":"/8-1/"},"frontmatter":{"date":"April 22, 2022","title":"os 8-1","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n## Critical Section Problem\r\n\r\n> 동기화!\r\n>\r\n> 각 프로세스의 코드에는 크리티컬 섹션이 존재한다\r\n>\r\n> * critical section : **공유 데이터**가 업데이트 일어나는 부분\r\n> * entry section : 크리티컬 섹션에 들어가기위한 코드의 부분\r\n> * exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분\r\n> * remainder section : 크리티컬섹션이 아닌 나머지부분\r\n>\r\n> 위 섹션들은 모두 코드임\r\n\r\n\r\n\r\n* n개의 프로세스가 있다고 가정\r\n\r\n* 각각의 프로세스는 코드를 가지는데 그 코드에 크리티컬 섹션이 존재\r\n\r\n* 크리티컬 섹션안에서는 정보의 업데이트가 가능하다\r\n\r\n* 공유되는 변수나 테이블등을 바꿀 수 있음\r\n\r\n* 어떤 프로세스가 크리티컬 섹션을 가지고있으면 다른 프로세스가 그 크리티컬 섹션에 진입할 수 없다\r\n\r\n  \r\n\r\n#### Solution to Critical Section Problem\r\n\r\n* Mutual Exclusion (상호배제)\r\n  * 한 번에 한 프로세스만 크리티컬 섹션에 들어갈 수 있다\r\n  * 한 프로세스가 어떤 크리티컬 섹션에 들어가 있으면 다른 프로세스가 동일한 크리티컬 섹션안에 들어가지못한다\r\n\r\n* Progress\r\n  * 만약에 크리티컬 섹션에 아무도 없는데 들어가고싶어하는 사람이 있으면 그 결정은 바로 나야한다\r\n  * 즉 최대한 빨리 결정이 나야한다는 것! 무기한 연장되지않는다\r\n  * 그 결정은 remainder 섹션에 있지 않은 애들이어야한다 \r\n* Bounded Waiting (유한한 대기. 언젠간 들어갈 수 있게)\r\n  * 어떤 프로세스가 크리티컬 섹션에 들어가고 싶어서 request를 날렸을 때 바운디드 웨이팅에 한계가 있다. 즉 무기한 기다리지않는다\r\n\r\n\r\n\r\n#### Critical Section Handling in OS\r\n\r\n> **예시** : 크리티컬 섹션 핸들링이 되지않는다면?\r\n>\r\n> fork()를 하면 next_available_pid를 제공\r\n>\r\n> 만약 두 프로세스가 동시에 fork()를 한다면?\r\n>\r\n> 동시에 next_available_pid에 접근해서 \r\n>\r\n> 방금 생성한 프로세스 p2, p3가 서로 다른 프로세스임에도 같은 프로세스 아이디를 가져갈 수도 있다\r\n\r\n\r\n\r\n* preemptive(cpu를 뺏어갈수있는 스케줄링)\r\n  * 어떤 프로세스가 커널모드에서 run하고 있을 때 cpu를 뺏는게 가능\r\n  \r\n* non-preemptive (능동적)\r\n  * cpu 뺏는게 안됨\r\n  * 특정 프로세스가 커널모드를 끝날 때까지 or 양보할 때까지 동작하는게 보장이 됨\r\n  * 커널 안에서의 작업이 **완전히 끝나는 것을 보장**\r\n  * 애초에 critical problem, race conditions가 발생하지않음\r\n  * 일을 하는중에 누군가 뺏어가지않음\r\n  * **문제가 생기는건 preemptive한 커널 구조**\r\n  \r\n  \r\n\r\n어떤식으로 해결해야할까?\r\n\r\n### Peterson's Solution\r\n\r\n* 고전적인 소프트웨어 기반 해결책. 현대에는 적용할 수 없음\r\n* 두 개의 프로세스가 동시에 크리티컬 섹션에 들어갈때(두 개의 프로세스일때만 가능. 여러개는 못함)\r\n* 로드, 스토어 명령어는 atomic하다고 가정. = 명령어 중간에 껴들어갈수없다\r\n* 싱글 cpu가정\r\n* 두가지변수사용\r\n  * int turn : 누구 순서인지\r\n  * bool flag[2] : \r\n    * flag[i] == True이면 Pi가 크리티컬 섹션에 들어갈 준비가 되었다는 뜻\r\n  * turn = j; #양보함 -> turn이 j로 바뀌어서 while문을 빠져나옴?\r\n  * pj가 다 끝나면 flag i를 다시 false로 바꿔줌??\r\n  * (while flag[j] && turn == j ) : 기다림\r\n  * i가 크리티컬 섹션에 들어갈 수 있을 때는\r\n  * 1. 상대방이 준비가 안됐을때\r\n    2. 나의 턴일 때\r\n\r\n> while문과 critical section이 별개인듯\r\n>\r\n> 먼저 순서를 양보해서 j가 준비되었고 턴이 j면 i는 while문을 계속 돎\r\n>\r\n> j의 크리티컬 섹션이 끝나서 flag[j] = false가 되면 i가 while문을 빠져나오고 크리티컬 섹션에 진입\r\n\r\n\r\n\r\n그러나 현대 컴퓨터에서 쓰일 수 없음...\r\n\r\n가장 큰 이유는 reorder때문\r\n\r\n아무리 순차적으로 코드를 짰어도 그거에 디펜던시가 없으면 컴퓨터가 효율성을 위해서 리오더링할 수 있음\r\n\r\ncpu가 알아서 turn을 먼저하고 flag를 나중에 해버림\r\n\r\n\r\n\r\n#### Critical Section with Disable/Enable Interrupt\r\n\r\n어떻게 막을 수 있을까?\r\n\r\n누군가 크리티컬 섹션에 진입했을때 인터럽트를 막아버림\r\n\r\n인터럽트 : 컨텍스트 스위칭을 유발할 때 생김\r\n\r\n컨텍스트 스위칭을 하기위해 인터럽트를 보냄\r\n\r\n인터럽트를 막았기 때문에 컨텍스트 스위칭이 되지않음(p1에서  p2로 넘어가지않음)\r\n\r\n* 그러나 인터럽트를 disable/enable 하는 것은 너무 강력한 메소드!\r\n\r\n* 이거 하려고... 인터럽트... 다 막으려고...~?\r\n* 벼룩잡으려다 초가삼간 태우는 꼴!\r\n\r\n> 소프트웨어만으로는 해결하기 힘든 문제\r\n>\r\n> 하드웨어의 도움이 필요하다!\r\n\r\n## Synchronization Hardware\r\n\r\n### Hardware Instruction : test_and_set\r\n\r\n* atomic = non-interruptible한 instruction\r\n\r\n* 어떤 메모리에서 테스트 값을 가져와서 그 값을 바꾸는 일도 함\r\n\r\n\r\n\r\nboolean test_and_set (boolean \\*target)\r\n\r\n> target을 받아서 값을 가져옴\r\n>\r\n> 타겟을 true로 만듦\r\n>\r\n> 받은 target값을 그대로 return\r\n>\r\n> \\# test : 얘가 원래 true였는지 false였는지 테스트\r\n>\r\n> \\# set : target을 true로 셋~ \r\n\r\n\r\n\r\n> 예시\r\n>\r\n> lock = target, lock은 공유변수\r\n>\r\n> 초기 lock값은 false\r\n>\r\n> tas()의 리턴값이 false라서 while문을 빠져나오지만\r\n>\r\n> lock이 true 로 set되어서 다른애들은 크리티컬 섹션 들어가지못함\r\n\r\n\r\n\r\nos 개념, 컨셉 이론. 전체적인 개념을 묻는 문제가 많이 나올것\r\n\r\n"},{"excerpt":"Combined Threads many to many 커널레벨모드도 유저레벨모드도 존재 유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다 커널은 사실상 스레드의 존재를 크게 의식하지않음 커널은 단지 유저에게 virtual processor같은. cpu코어같음 커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 …","fields":{"slug":"/7-2/"},"frontmatter":{"date":"April 22, 2022","title":"os 7-2","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n### Combined Threads\r\n\r\n* many to many\r\n\r\n* 커널레벨모드도 유저레벨모드도 존재\r\n\r\n* 유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다\r\n\r\n* 커널은 사실상 스레드의 존재를 크게 의식하지않음\r\n\r\n* 커널은 단지 유저에게 virtual processor같은. cpu코어같음\r\n\r\n* 커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 스케줄링하고 관리해줌\r\n\r\n* 유저레벨 스레드는 커널레벨 스레드가 가상의 프로세서라고 생각하고 활용\r\n\r\n* 어떤 스레드를 어떤 프로세서에 넣을지 관리를 해줌\r\n\r\n* 사용자 : 자기 자신이 스레드를 만들고 관리\r\n* 시스템 : 시스템도 똑같이 만들고 관리\r\n* 시스템(커널) 스레드 수의 한계가 존재(1대1로 매핑하면 오버헤드가 커짐)\r\n* 유저 레벨 스레드 > 커널 레벨 스레드\r\n* 유저 레벨 스레드 라이브러리\r\n  * 유저레벨스레드를 만들고 없앰\r\n  * 스케줄링 ( 어떤 스레드를 선택할지, 어떤 유저레벨스레드를 커널레벨스레드에 올릴지 )\r\n  * 컨텍스트를 saving, restore\r\n  * 스레드간 데이터, 메시지 통신\r\n\r\n* System call API and kernel functions for thread facility\r\n  * 커널레벨 스레드 중에 어떤걸 cpu에 올릴지라는것만 빼고 다 동일\r\n\r\n\r\n\r\n* 유저가 스레드를 만듦\r\n* 커널에서는 유저 스레드의 양을 보고 적절한 양의 커널 스레드를 만들어서 매핑\r\n* 유저레벨 스레드간의 소통, 싱크로나이즈는 유저레벨에서 이루어짐\r\n* 사실 요즘 하드웨어는 cpu코어가 적당히 많아서 원투원 사용\r\n\r\n\r\n\r\n## Thread Libraries\r\n\r\n* Pthread & OpenMP\r\n* Pthread(Unix 계열의 표준 API)\r\n* OpenMP (c++, c)\r\n\r\n### Pthreads\r\n\r\n* Pthread : POSIX standard for threads\r\n* api만 정의되어있음\r\n* 구현은 실제 라이브러리를 만드는 사람마다 다르게 사용할 수 있음\r\n\r\n\r\n\r\n* pthread_create()는 fork()와 비슷한\r\n* pthread_exit = exit()\r\n* pthread_join() = wait\r\n* pthread_yield() : cpu를 양보하겠다는 말. 다른 스레드가 써라!\r\n\r\n\r\n\r\npthread_create(&tid, NULL, runner(수행할 일), argv\\[1](runner함수의 인자) )\r\n\r\n스레드 attribute\r\n\r\n​\tex. 스케줄러, 폴리시, 프라이어티, stack주소등\r\n\r\n\r\n\r\n## Implicit Threading\r\n\r\n* explicit threads (명시적으로 스레드 생성, 일 분담) - 어렵다 적당히 시스템이 해줬음좋겠다라는 마음에서 나온게 implicit threading\r\n* 스레드 생성, 관리를 컴파일러나 런타임라이브러리가 해줌\r\n* 프로그래머는 단지 병렬적으로 일할 수 있는 부분만 알려줌\r\n* 사용자수준에서는 훨씬 사용하기쉽다\r\n\r\n### OpenMP\r\n\r\n컴파일러한테 여기 parallel하게 해줘~하면 알아서 병렬처리 해주는 api와 compiler directives\r\n\r\n* #pragma omp parallel\r\n* 앞에 이 문장만 넣어주면 병렬로 해줌 밑에 나오는 줄을 코어 수만큼 수행. 병렬로 할 수 있는만큼 중복수행해줌\r\n* #pragma omp parallel for (num_thread(4))\r\n* for문의 크기를 적당히 쪼개서 병렬로 처리해줌\r\n* num_thread를 통해 thread를 몇 개 쓸건지 정할수도있음\r\n\r\n\r\n\r\n## Synchronization Tools\r\n\r\n프로세스들간의 소통이 필요\r\n\r\ndata inconsistency를 야기할수도\r\n\r\na라는 애가 읽으려는 데이터를 b가 읽기전에 바꿔버리면 예측하려는 결과가 안나옴\r\n\r\ncounter로 버퍼사이즈를 카운트\r\n\r\natomic하지않음 - Race Condition - 자원을 공유해서 잘못된 결과를 낳음\r\n\r\n그래서 동기화가 필요!\r\n\r\n프로듀서가 쓸거라고하면 컨슈머가 건들지못하고 컨슈머가 쓸려고하면 프로듀서가 쓰지못하는\r\n\r\n\r\n\r\n"},{"excerpt":"Dispatcher os의 프로세스를 구동하는 부분의 가장 안쪽이다 디스패처의 역할! 어떤 프로세스를 돌리고 스탑, 상태 세이브 다른 프로세스의 스테이트를 로드해옴 switching context switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유…","fields":{"slug":"/4-2/"},"frontmatter":{"date":"April 21, 2022","title":"4-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Dispatcher\r\n\r\nos의 프로세스를 구동하는 부분의 가장 안쪽이다\r\n\r\n> 디스패처의 역할!\r\n>\r\n> 어떤 프로세스를 돌리고\r\n>\r\n> 스탑, 상태 세이브\r\n>\r\n> 다른 프로세스의 스테이트를 로드해옴\r\n\r\n\r\n\r\n* switching context\r\n\r\n* switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유저모드)\r\n\r\n* 적절한 위치로 점프 (새로운 프로세스의 실행해야할 위치, load state로 점프)\r\n\r\n\r\n\r\n디스패치는 사실 수동적\r\n\r\n\r\n\r\n### 디스패처는 어떻게 컨트롤을 유지할 수 있을까?\r\n\r\n>  cpu는 한 번에 하나의 일만 할 수 있다\r\n>\r\n> 유저 프로세스가 실행되고 있다는 말은 디스패처가 실행되고있지않다는 말\r\n>\r\n> 그럼 어떻게 디스패처를 컨트롤할까?\r\n\r\n* 📌 non-preemptive way : 프로세스가 디스패처를 깨워줄거라고 믿음\r\n* 📌 preemptive way : 디스패처가 일정시간마다 깨어나서 프로세스를 쫓아냄\r\n* interrupt, traps and faults에 의해 호출됨\r\n* ex. interrupt (하드웨어)\r\n  * 터미널에서 문자입력\r\n  * 디스크에서 읽어오는거 끝남 (I/O)\r\n  * 타이머\r\n* Traps and Faults(소프트웨어) - 프로세스가 os한테 요청\r\n  * 시스템 콜 : process가 os한테 어떤일을 해달라고 요청\r\n  * floating  : 계산불가능. os가 처리\r\n  * page fault\r\n\r\n\r\n\r\nnonpremmtive는 완벽하지않음. 프로세스가 자리 안내줄수도있음. \r\n\r\n그래서 preemptive가 필요\r\n\r\n \r\n\r\n## Scheduling Policy\r\n\r\n1. 프로세스 테이블을 스캔해서 돌 수 있는애를 앉힌다 \r\n   * 시간이 오래 걸림\r\n2. 레디큐의 제일 첫번째에 있는 프로세스를 실행\r\n3. 레디큐에서 우선순위가 높은 것을 실행\r\n\r\n* 우선순위를 결정하는게 policy\r\n* 왜 디스패처가 하지않을까?\r\n  * policy와 mechanism을 분리하기위해\r\n\r\n \r\n\r\n## Context Switching\r\n\r\n* 디스패처가 기존의 state를 save하고 restore하는 것을 context switch mechanism을 통해 구현한다\r\n* 다음 프로세스가 건들여서 손상을 일으킬 것 같은 모든 것을 저장한다.... 걍 웬만하면 다 저장?\r\n  * Program counter\r\n  * Processor status word(condtion codes 등)\r\n    * 프로세스가 사용하던 cpu상태 정보\r\n  * 레지스터들\r\n  * 메모리는 정리하지않아도 될까? (책장)\r\n  * 메모리는 저장하기에 너무 크고 비용이 큼\r\n  *  memory management part가 별도로 담당하기때문에 context switching에서는 고려하지않는다\r\n\r\n\r\n\r\n## Context Switching Implementation\r\n\r\nmachine... 에 따라 다른 컨텍스트 스위칭 수행존재...\r\n\r\nos마다 구현하는 방법에 따라 다름\r\n\r\n\r\n\r\nstatus를 메모리에 옮김\r\n\r\n메모리의 어디에? 스택 or PCB\r\n\r\n* 스택 : 프로세스가 사용하는 메모리 공간\r\n* PCB : os가 사용하는 메모리 공간\r\n\r\n\r\n\r\n뒤에 예시 그림은 stack\r\n\r\n* before interrupt\r\n\r\n* interrupt call\r\n\r\n  수행중이던 프로세스 멈추고 prcoess status word를 넣고 그 다음 return addr(=pc)를 넣음\r\n\r\n* PUSHA instruction\r\n\r\n  책상에 있는걸 다 책장에 정리해야함\r\n\r\n​\t\t레지스터 정보를 모두 스택에 저장\r\n\r\n​\t\t단 %rsp는 원래  return addr를 가리키던 n이었으나 레지스터 정보를 넣고 n-a로 업데이트된다(실제로는 n-a까지 들어갔지만 스택에는 n이 들어가버림) \r\n\r\n* Saving stack pointer\r\n\r\n​\t\t**그래서 %rsp는 os-PCB의 StkPtr에 저장**\r\n\r\n* Selecting Next Process\r\n\r\n  scheduling policy는 OSPCBCur가 새 프로세스 OS-PCB의 StkPtr을 가리키게함\r\n\r\n  OS-PCB의 StkPtr값을 CPU's StkPtr에 넣음\r\n\r\n* POPA instruction\r\n\r\n  새 프로세스의 스택에 있는 레지스터들을 전부 가져옴\r\n\r\n  그 다음 return addr과 PSW도 가져온다\r\n\r\n\r\n\r\nSelecting Next Process과정에서 만약 새 프로세스가 처음 생성된 애, empty 스택이라면?\r\n\r\n스택이 비었다면 디스패처 오류\r\n\r\n시스템은 처음 생성된 프로세스에게 임시로 stack에 할당해줌 디폴트값\r\n\r\n\r\n\r\n## CPU Scheduling\r\n\r\n## Scheduling Policy\r\n\r\n우선순위 기준점\r\n\r\n* cpu utilization : 책상 사용량을 증대!\r\n* throughput : 주어진 시간동안 몇 개의 프로세스가 일을 했냐\r\n* turn around time : 특정프로세스가 일을 하고 싶은데 얼마나 자주? 보통 낮으면 좋지만 무조건적인건아님\r\n* waiting time : 기다리는 시간\r\n* response time : 프로세스한테 job을 요청했는데 job이 끝날때까지의 시간. 프로그램 종료를 뜻하는건 아님. 특정 동작\r\n\r\n\r\n\r\n### First-Come, First-Served(FCFS)\r\n\r\nfifo라고도 불림 first in first out\r\n\r\n먼저 왔으면 먼저 내보냄\r\n\r\n문제 : 앞에 애가 엄청 오래걸리는 애인데 뒤에 애들은 몇 초만에 끝날 때-monopolize, Convoy effect\r\n\r\n해결방안 : 먼저 온 애를 먼저 앉히되, 특정 시간동안만 일하게하고 다음에 부름 - maximum time을 **timeslice**라고 함\r\n\r\ntime slice외에 I/O요청등에 의해 내려오는 경우도 있음. 이걸 blocked됐다고 말함\r\n\r\n\r\n\r\n### Shortest Job First(SJF)\r\n\r\n그럼 짧은 애부터 실행하자!ㅎㅎ\r\n\r\n"},{"excerpt":"DoS attack : 서비스 거부 공격 취약점 공격형 Boink, Bonk, TearDrop Land 자원 고갈형 Ping of death SYN flooding HTTP flooding Smurf Mail bomb TearDrop TCP 오류 제어 로직의 불완전한 구현을 악용 클라이언트 측에서 의도적으로 패킷의 시퀀스 넘버와 길이를 조작 패킷들이 부분…","fields":{"slug":"/dos-attack/"},"frontmatter":{"date":"April 20, 2022","title":"7-1 DoS attack","tags":["computer protection"]},"rawMarkdownBody":"\r\n## DoS attack : 서비스 거부 공격\r\n\r\n- 취약점 공격형\r\n  - Boink, Bonk, TearDrop\r\n  - Land\r\n- 자원 고갈형\r\n  - Ping of death\r\n  - SYN flooding\r\n  - HTTP flooding\r\n  - Smurf\r\n  - Mail bomb\r\n\r\n### TearDrop\r\n\r\n- TCP 오류 제어 로직의 불완전한 구현을 악용\r\n- 클라이언트 측에서 의도적으로 패킷의 시퀀스 넘버와 길이를 조작\r\n- 패킷들이 부분적으로 겹치거나 빠진 패킷이 있어 reassemble 불가\r\n\r\n> 대응\r\n>\r\n> - 수신되는 패킷의 frame alignment를 확인하여 filtering\r\n\r\n### LAND (local area network denial) Attack\r\n\r\n- 일종의 packet spoofing 공격\r\n- source 와 destination IP address 를 모두 target host 의 IP address로 설정하고 TCP SYN 패킷을 전송\r\n- target host는 자신에게 지속적으로 응답을 하게됨( 보내는 사람도 나... 받는 사람도 나...?)\r\n\r\n> 대응\r\n>\r\n> - source와 destination IP address 유효성 검증\r\n\r\n---\r\n\r\n### Ping of Death\r\n\r\n- ping 명령어에 최대한 긴 패킷을 실어서 공격 대상에게 전송\r\n- IPv4 패킷 크기는 65535 바이트까지 가능하나 경유 네트워크 특서엥 따라 전송중에 수백 - 수천개의 패킷으로 분할됨\r\n- 분할된 패킷이 다시 합쳐져서 전송되는 일은 거의 없으므로 공격 대상 시스템은 대량의 작은 패킷을 수신하게 됨\r\n\r\n> 대응\r\n>\r\n> - 주로 방화벽에서 ping이 사용하는 ICMP를 차단하여 해결\r\n\r\n### SYN flooding\r\n\r\n- 시스템에서 허용하는 동시 사용자 수 제한과 TCP 3-way handshake 특성을 악용\r\n- 공격자는 가상의 클라이언트로 위조한 SYN 패킷을 여러 개 만들어 서버에 보냄으로써 서버의 가용 동시 접속자 수를 모두 점유 ( 모두 SYN Received 상태로 만듦)\r\n\r\n> 대응\r\n>\r\n> - SYN Received 상태의 대기 시간을 줄이는 등 다양한 해법 존재\r\n\r\n### HTTP flooding\r\n\r\n웹 서버에 대한 도스/디도스 공격\r\n\r\n**기본적인 공격**\r\n\r\n- Get flood\r\n  - image와 같은 특정 static content를 지속적으로 요구\r\n- POST flood\r\n  - 서버 내의 database 검색 등 특정 동작을 지속적으로 요구\r\n\r\n> 대응\r\n>\r\n> - traffic profiling(특정적인 HTTP 요청 패턴을 검출하고 차단)\r\n\r\n**보다 진화된 공격**\r\n\r\n- slow HTTP POST (= RUDY (RU-Dead-Yet?))\r\n  - 서버가 POST 데이터를 모두 수신하지 않았다고 판단하면 전송이 다 이루어질때 까지 연결을 유지하는 특성을 활용, POST 메소드로 대량의 데이터를 장시간에 걸쳐 분할 전송하여 연결을 장시간 유지함으로써 서버의 자원 잠식\r\n  - 예를 들어 Content-Length를 100000byte로 하고 데이터는 일정한 간격으로 1byte씩 전송\r\n- slow HTTP header (slowloris attack)\r\n  - HTTP header 정보를 비정상적으로 조작하여 웹서버가 완전한 header 정보를 기다리도록 함\r\n  - 예를 들어, HTTP에서 header의 끝을 개행문자 /r/n (CR LF)로 구분하므로, header 시작 후 개 행 문자 없이 의미없는 문자열을 보내면 서버는 계속 연결을 유지\r\n\r\n> 대응\r\n>\r\n> - 세션 임계치 설정, 세션 타임아웃 시간 제한\r\n\r\n### Smurf attack\r\n\r\n- Direct broadcast\r\n  - 기본적인 broadcast는 destination IP address 255.255.255.255로 패킷을 전송하며, 이는 라우터 경계내에서만 동작함\r\n  - direct broadcast: 라우터를 넘어가서 broadcast를 해야 하는 경우 IP address 의 일부분만 broadcast 주소로 채움\r\n- Smurf attack\r\n  - Direct broadcast를 악용하여, source IP address를 특정 주소(피해자 의 IP address)로 조작한 ICMP request 를 broadcast\r\n  - 피해자는 수많은 ICMP reply를 받아 과부하 상태가 됨\r\n\r\n> 대응\r\n>\r\n> - 각 호스트와 라우터들로 하여금 broadcast address 일 경우 무시하도록 설정\r\n"},{"excerpt":"Compilation System Compilation System Pre-processing : c코드 형태, #include, define등 전처리 컴파일러 : 어셈블리어 형태로 어셈블러 : 기계어 형태로 링커 : 여러 코드파일들을 하나의 실행파일로 합쳐줌 ex. printf.o + hello.o excutable 파일 text segement: 기계…","fields":{"slug":"/3-1/"},"frontmatter":{"date":"April 20, 2022","title":"3-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Compilation System\r\n\r\n## Compilation System\r\n\r\n- Pre-processing : c코드 형태, #include, define등 전처리\r\n- 컴파일러 : 어셈블리어 형태로\r\n- 어셈블러 : 기계어 형태로\r\n- 링커 : 여러 코드파일들을 하나의 실행파일로 합쳐줌 ex. printf.o + hello.o\r\n\r\n### excutable 파일\r\n\r\ntext segement: 기계어\r\n\r\ndata segment : global 변수들, read only data(string), system data\r\n\r\n%rbx : 레지스터\r\n\r\n(%rbx) : 메모리\r\n\r\n## Stack\r\n\r\n- 지역변수나 함수간에 주고받는 인자등을 저장해둠\r\n- 레지스터에 모든 데이터를 다 담아둘 순 없으니까\r\n- top 방향으로 쌓이고 없어질때도 top부터 없어짐\r\n- bottom이 address high임 띠용\r\n- top의 주소만 알면 push, pop가능\r\n\r\n- **%rsp가 stack의 top을 가리키고 있다**\r\n\r\n- push src\r\n\r\n  %rsp 8 감소\r\n\r\n- pop dst\r\n\r\n  %rsp 8증가\r\n"},{"excerpt":"Process 여기부터 중요하네 ... os는 프로세스를 중심으로 관리 Process Concept program은 passive process는 active 컴퓨터내에서 돌아가는 일의 단위 실행중인 프로그램 특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름 excution stream : 한줄한줄 실행하고있는 바로 그 상태! proces…","fields":{"slug":"/3-2/"},"frontmatter":{"date":"April 20, 2022","title":"3-2 프로세스 탐구","tags":["OS"]},"rawMarkdownBody":"\r\n## Process\r\n\r\n여기부터 중요하네 ...\r\n\r\nos는 프로세스를 중심으로 관리\r\n\r\n## Process Concept\r\n\r\n> program은 passive\r\n>\r\n> process는 active\r\n\r\n컴퓨터내에서 돌아가는 일의 단위\r\n\r\n실행중인 프로그램\r\n\r\n**특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름**\r\n\r\nexcution stream : 한줄한줄 실행하고있는 바로 그 상태!\r\n\r\nprocess state : 아래 참고\r\n\r\n프로그램 : 실행시키기전까지는 프로그램\r\n\r\n코드 시퀀스. 기계어의 나열\r\n\r\n프로그램을 실행시킨게 프로세스\r\n\r\n실행되서 메모리에올라가서 한줄한줄 실행중~><\r\n\r\n프로그램은 여러개의 프로세스가 될 수 있다. ex. 크롬 브라우저 여러개 생성\r\n\r\n### process state (= process context)\r\n\r\n- Memory context\r\n- Hardware context\r\n- System context\r\n\r\n0과 max는 메모리 상대주소를 가리킴\r\n\r\n#### Memory context\r\n\r\n- text : 컴파일 되어서 기계어로 된 code와 data\r\n- 파일안에 이미 존재하고 있는 data : 글로벌 변수\r\n\r\n- stack : 지역변수, 함수인자, 함수호출되고 리턴될 주소\r\n\r\n- heap : 동적으로 할당된 data (ex. new malloc)\r\n\r\n(도서관 관리)\r\n\r\n#### Hardware context\r\n\r\nCPU register, I/O registers\r\n\r\n(도서관 관리)\r\n\r\n#### System context\r\n\r\nProcess table, open file table, page table\r\n\r\n(책장 주변 환경 관리)\r\n\r\n### 📌 Multiprogramming vs Multiprocessing\r\n\r\n- 유니 프로그래밍 : 하나의 프로세스가 메모리에 올라간다\r\n\r\n- 멀티 프로그래밍 : 메모리 관점! 메모리에 여러개가 올라가는가\r\n\r\n  동시에 여러 개의 프로그램이 실행되어서 메모리안에 여러개의 컨텍스트를 올려놓은 상태\r\n\r\n ![](./uni-multi.png)\r\n\r\n- 멀티 프로세싱 : cpu 관점 - cpu가 여러 프로세스를 동시에 번갈아가며 처리하고있는가\r\n\r\n 여러 개의 프로세스가 cpu를 번갈아가며 사용하면서 실행중. cpu가 multiplexed됨\r\n\r\ncpu를 쓰려는 프로세스들을 관리할 방법이 필요하다!\r\n\r\n각각의 프로세스들을 관리하기위해 만든게 process control block\r\n\r\n### 📌 Process Control Block\r\n\r\n- process state\r\n\r\n- program counter : 몇 번째 라인을 수행중인지\r\n\r\n- 레지스터들\r\n\r\n- 스케줄링 information\r\n\r\n  등등...\r\n\r\n각각의 프로세스에게 할당되어있다!\r\n\r\nos는 이 프로세스 컨트롤 블록을 보고 프로세스를 관리\r\n\r\n### 📌 Process table\r\n\r\n각각의 프로세스들의 pcb를 모아둔것들\r\n\r\n초창기 유닉스는 pcb를 array로 구현\r\n\r\n길이가 고정되어있어서 일정 길이 이상으로 늘어나지못함\r\n\r\n지금은 linked list형태로 사용중\r\n\r\n### 📌 Process State (좀 더 자세하게...?)\r\n\r\n앞에 있는건 context라고 하기로 하자...\r\n\r\n얘는 진짜 딱 프로세스의 상태\r\n\r\n- new : 프로세스 생성\r\n- running : 레디들중에 선택\r\n- waiting : running중 cpu에서 나와야 할 때 (ex. I/O or event wait)\r\n- ready :\r\n  - new하고 성공적으로 만들어지면 옴\r\n  - 러닝중 인터럽트\r\n- terminated : 프로세스 종료\r\n\r\nprocess life cycle\r\n\r\n큐를 사용해서 구현\r\n\r\n### 📌 State Transition\r\n\r\n- Ready queue\r\n\r\n  말그대로 레디중인애들\r\n\r\n- Device quete (I/O waiting queue)\r\n\r\n  I/O이벤트등으로 디스크를 기다리고 있는 프로세스들... 각각의 이유별로 큐를 만들어서 따로 관리\r\n\r\n- job queue\r\n\r\n 시스템에 있는 모든 프로세스들을 따로 만들어놓은 큐\r\n\r\n- 이 linked list를 구현할때 그냥 pcb를 가져와서 구현함\r\n\r\n- cpu에서 일하고있는 큐는 위 셋 중 어떤 큐에도 들어가있지않다\r\n\r\n- 시간이 다 돼서 쫓겨난 애들은 레디큐로\r\n\r\n### 📌 Schedulers\r\n\r\n레디큐에서 cpu로 보낼애를 선택하는 법\r\n\r\n- 📌 Short-term scheduler (= CPU scheduler)\r\n  - 어떤애를 cpu로 보낼건지!\r\n  - 짧은 시간 간격으로 돌면서 다음애 돌 애를 지속적으로 바꿔줌\r\n  - 밀리세컨드 이하로 반복\r\n  - 여러개의 프로세스가 동시에 움직이는 것 같지만 사실은 밀리세커드 단위로 바뀌고 있는 것\r\n  - 자주 호출돼서 빨라야 함!\r\n- long-term scheduler (= job scheduler)\r\n  - 없는 os도 있음\r\n  - 레디큐에 넣을 프로세스들을 선별\r\n  - cpu scheduler가 본선느낌이라면 얘는 예선느낌\r\n  - 하나의 컴퓨터에서 너무 많은 프로세스를 만들어버리면 pcb도 많아짐... 책장 부족!\r\n  - degree of multiprogramming : 멀티프로그래밍의 정도를 나눔. 프로그램 몇 개가 메모리에 있을지 결정\r\n\r\n#### 📌 스케줄러를 위한 프로세스의 두 종류\r\n\r\n- I/O-bound process\r\n  - I/O 요청을 처리, 대기하는데 시간이 많이 걸림\r\n- CPU-bound process\r\n  - I/O는 모르겠고~ cpu를 오래써야 끝날 수 있는 프로세스\r\n\r\n job scheduler는 저 두 개를 적절히 섞어준다\r\n\r\n### CPU Switch From Process to Process\r\n\r\n#### 📌 Context switch\r\n\r\n1. 원래 돌고 있던 프로세스의 컨텍스트를 save\r\n\r\n2. 새로 올 프로세스의 컨텍스트를 가져옴\r\n\r\n- 오버헤드. 스위치하는동안에는 누구도 일을 하지 않음\r\n- 자주 일어나면 안좋음\r\n- 이걸 위해 레지스터를 여러개 구비해놓기도. (책을 치우고 갈 필요가 없음)\r\n\r\n## 📌 Process Creation & Termination\r\n\r\n> 두 가지 방법 존재\r\n>\r\n> 1. 새로운 프로세스 만들기\r\n> 2. 클론하기\r\n>\r\n> 보통 클론\r\n\r\n- 📌 process creation :\r\n\r\n  1. disk storage에서 프로그램의 code, data를 읽어 메모리에 넣는다\r\n  2. stack공간을 만든다(empty stack)\r\n  3. pcb 만들고 초기화\r\n  4. 레디큐에 프로세스를 넣는다\r\n\r\n- 리눅스는 컴퓨터 부팅될 때 첫 프로세스만 이렇게 만듦\r\n\r\n- 나머지 프로세스는 기존의 프로세스를 클론해서 만든다\r\n\r\n- 기존에 있던 메모리 공간을 그대로 복사해온다\r\n\r\n- 복사하고 exec()을 통해 새로운 프로그램을 메모리에 올려버린다(이걸 안하면 기존 것과 똑같은 프로그램)\r\n\r\n- 프로세스를 만드는 시간이 줄어든다! 개이득!\r\n"},{"excerpt":"fork() fork()라는 system call은 new process를 생성한다 (cloning) system call : 사용자가 os커널한테 요청하는 api fork() process 현재 프로세스 중지하고 state를 저장 현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (전부 똑같은건 아니…","fields":{"slug":"/4-1/"},"frontmatter":{"date":"April 20, 2022","title":"4-1","tags":["OS"]},"rawMarkdownBody":"\r\n## fork()\r\n\r\n- fork()라는 system call은 new process를 생성한다 (cloning)\r\n\r\nsystem call : 사용자가 os커널한테 요청하는 api\r\n\r\n#### fork() process\r\n\r\n1. 현재 프로세스 중지하고 state를 저장\r\n2. 현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (**전부 똑같은건 아니고 PID에 차이를 준다. os는 pid를 가지고 구분. fork()의 return value도 바꿔준다**)\r\n3. 새로운 프로세스를 레디큐에 삽입\r\n\r\n#### fork() return value\r\n\r\n1. r < 0 : 오류\r\n2. r > 0 : 부모 프로세스일 경우 chd의 pid를 반환\r\n3. r = 0 : 자식 프로세스일 경우\r\n\r\n## exec()\r\n\r\n새 프로세스의 메모리 공간을 바꿔치기\r\n\r\n(새로운 프로그램의 경로)\r\n\r\nex) execlp(\"/bin/ls\", \"ls\", NULL)\r\n\r\n- 오버헤드 단점 : 복사 비용이 너무 큼\r\n\r\n- COW ( copy on write)\r\n\r\n  전부 복사하지말자!\r\n\r\n 실제로는 pointer structure를 만들어서 부모의 code, data 영역을 가리키게 해줌\r\n\r\n (**stack은 복제해야함** : 두 프로세스를 다르게 관리해야하므로)\r\n\r\n 해당 데이터 영역을 수정해야할때 복제, 부모랑 데이터가 달라지는 순간 실제 복사가 일어남\r\n\r\n windows는 아예 새로 만듦...?\r\n\r\n## Process Termination\r\n\r\n![](./create-terminate.png)\r\n\r\n### exit()\r\n\r\n프로세스가 정상적으로 종료됐는지는 exit()안에 담아서 보낸다\r\n\r\n1. status data를 parent에게 전달\r\n\r\n   parent는 wait()로 받음\r\n\r\n2. 해당 프로세스는 자신의 리소스를 전부 deallocated\r\n\r\n#### exit return value\r\n\r\n- 0이면 정상종료\r\n\r\n- 0이 아니면 비정상 종료\r\n\r\n(사실 os가 진짜 비정상 종료라고 인식하진않고 관습적인... 표현임. 부모 프로세스한테 그냥 0이 아니라고 알려줄뿐)\r\n\r\n- wait() 호출하면 자식의 종료 상태가 wait(\\$status)로 전달\r\n\r\n정상적으로 종료되지않았을 때 exit()외에 abort()라는 시스템 콜을 호출할 수도 있다\r\n\r\n### abort()\r\n\r\n비정상 종료를 명시적으로 호출\r\n\r\n명시적 : 시스템 자체적으로 비정상 알림\r\n\r\nex. 메모리를 과도하게 요청함\r\n\r\n#### 좀비 프로세스\r\n\r\n부모가 wait을 안해줘서, 안거둬줘서 자식이 죽었는데 pcb에 계속 남아 있음\r\n\r\n다른 데이터는 모두 deallocate하고,\r\n\r\n나에게 남은건 부모에게 보낼 exit status뿐...⭐\r\n\r\n#### 고아 프로세스\r\n\r\n부모가 wait을 하기전 먼저 죽음\r\n\r\n1번 프로세스인 init이 좀비랑 고아를 거둬들어서 정상적인 종료를 돕는다\r\n\r\n- 웹 예시\r\n- 여러 개의 탭 : renderer\r\n- 왜 멀티 프로세싱?\r\n- 하나의 프로세스로 하면 특정 페이지의 로딩이 길어질 때 전체의 pending time에 영향을 줌\r\n- 프로세스간 통신 필요 :  📌 **Inter-process Communication (IPC)**\r\n  - 정보 공유 ex. shared memory, message passing\r\n  - 모듈화\r\n\r\n#### 📌 IPC\r\n\r\n**shared memory**\r\n\r\n진짜 같은 메모리의 주소를 공유\r\n\r\n**message passing**\r\n\r\nmessage queue에 메세지를 보냄... 우체통같은거임\r\n\r\n## 📌 CPU 스케줄러\r\n\r\n**하나의 프로세스의 전체 시간은 cpu burst와 I/O burst로 나뉜다**\r\n\r\n- cpu burst(cpu execution) : cpu를 연속적으로 계속 사용하는 상태\r\n\r\n  보통 5ms 이하\r\n\r\n- I/O burst (I/O wait) : I/O를 기다릴 때, I/O를 기다릴 때는 cpu를 사용하지않음\r\n\r\n### 📌 CPU 스케줄러는 언제 실행되나?\r\n\r\n1. I/O 요청을 하고 기다리게 되는 경우 : (running -> waiting) : **nonpreemptive**\r\n2. 계속 돌 수 있는데 쫓겨나는 경우 : (running -> ready) : **preemptive**\r\n3. I/O 요청이 다 끝난 경우 : ( waiting -> ready) : **preemptive**\r\n4. 돌던 프로세스가 종료 : (terminates) : **nonpreemptive**\r\n\r\n1,4번은 현재 cpu에서 돌고있는애가 자리를 내어줌(좀 더 능동적...?) : **nonpreemptive**\r\n\r\n1 : 나 아이오 기다려야돼~\r\n\r\n4 : 나 끝남~\r\n\r\n2,3번은 잘돌고있었는데 영문도 모르고 쫓겨남\r\n\r\n2 : ? 더 돌 수 있는데 시간 끝남\r\n\r\n3 : ? 전에 하던에 아이오끝나서 쫓겨남\r\n\r\ncpu 스케줄러는 policy(shedulling policy)랑 mechanism(dispatcher)을 잘 구별해서 만드는게 중요하다!\r\n\r\n1. 📌 scheduling policy : 선택(한 프로세스) : 여러개가 선택될수도?\r\n2. 📌 dispatcher : 바꿔주는 행동 그 자체\r\n\r\n바꿔주는 동작 그 자체는 계속 쓰면 되지만\r\n\r\npolicy는 시간이 지나면 바뀔수도있음\r\n\r\n하나의 시스템 안에서도 여러가지의 policy를 사용할수도있다\r\n"},{"excerpt":"AES 현대 Symmetic 암호는 Stream 암호와 Block암호로 구분된다 Block암호에는 대표적으로 AES가 있다 Advanced Encryption의 표준\nDES : 56bit크기의 key 키 크기가 작아서 취약\n키의 크기도 늘리고 성능 유지한게 AES AES structure  ➡  ➡  같은 input이라도 key값에 따라 output차이가…","fields":{"slug":"/aes-process/"},"frontmatter":{"date":"April 18, 2022","title":"5-2 AES Process","tags":["computer protection"]},"rawMarkdownBody":"\r\n## AES\r\n\r\n- 현대 Symmetic 암호는 Stream 암호와 Block암호로 구분된다\r\n\r\n- Block암호에는 대표적으로 AES가 있다\r\n\r\n- Advanced Encryption의 표준\r\n  DES : 56bit크기의 key 키 크기가 작아서 취약\r\n  키의 크기도 늘리고 성능 유지한게 AES\r\n\r\n## AES structure\r\n\r\n`128bit input` ➡ `Encryption` ➡ `128 output`\r\n\r\n같은 input이라도 key값에 따라 output차이가 발생한다\r\n\r\n### 궁극 목적\r\n\r\n#### **Bit randomizion effect**\r\n\r\nBlock Cipher : finite field 사용\r\n비트를 랜덤해보이도록 만들어서 최대한 인풋과 아웃풋의 연관관계가 없어보이게\r\n\r\n- Field multiplication과 Field inversion을 통해 랜덤하게 변형\r\n  -> 그래서 finite field를 사용한다!\r\n  _덧셈(뺄셈)은 반복하면 같아지는 효과가 있어서 제외_\r\n\r\n왜 덧셈은 반복하면 같아질까?\r\n\r\nfield : 사칙연산 덧셈 : randomize효과가 실질적으로 없음. 무작위로 바뀌지않고 계속 유지되는 성질 XOR 같은거 더하면 상쇄됨 연산을 반복한다고해서 복잡도가 올라가지않음\r\n\r\n### Rationale for Binary Field\r\n\r\nn비트의 int는 2^n 개 표현 가능\r\n그러나 모듈러 2^n은 field가 될 수 없음 ex) 2^3 = 8\r\n-> `GF(2^n)`사용 GF안의 모든 polynomial들이 n비트 넘버를 표현\r\n\r\nirreducible polynomial :\r\n(GF기준으로 x2 + 1도 인수분해 가능.)\r\n![](./ex.png)\r\n\r\n1. 모드2 이므로 2x 추가\r\n2. `+`와 `-`가 같으므로 `x^2 - 1`로 변환\r\n\r\n### State\r\n\r\n> AES에서 쓰는 기본 자료구조  \r\n> 128bit : byte를 16개(4x4)의 형태이다\r\n> plain text, cipher text모두 128bit 단위로 암호화된다.\r\n\r\nround key == subkey  \r\nround key의 비트는 똑같지만 개수가 많아짐 : expanded key\r\n\r\n![](./key.png)\r\n\r\n- key는 bit 수가 다른 여러가지 key가 있지만 plaintext는 항상 128bit로 고정이다\r\n\r\n> key size, 비트수가 커지면 round수도 커진다  \r\n> 각 round별로 키가 하나씩 사용된다  \r\n> round수가 늘어나면 각 라운드마다 쓰일 서브키(라운드키) 개수가 증가한다  \r\n> 각각의 서브키 하나의 크기는 128bit로 고정되어있다. 개수만 늘어나는거임!\r\n\r\n> 첫라운드전 한 번 + 각 라운드별로 서브키가 하나씩 사용됨  \r\n> 즉, 라운드키는 라운드 개수+1만큼 필요  \r\n> 서브키가 16byte 라운드가 10일경우 Expanded Key Size는  \r\n> 16\\*11 = 176\r\n\r\n### AES Encryption Process\r\n\r\n---\r\n\r\n![](aes-process.png)\r\nState (4x4)  \r\n: 평문을 4x4형태에 맞게 열(세로)로 나열함\r\n\r\n**initial transformation**  \r\n: 평문state와 key state를 xor\r\n\r\n**round** : 4가지 프로세스를 반 ~ 복  \r\n(마지막 라운드에선 Mix Columns 수행을 안하긴 함)\r\n\r\n**key expansion(key schedule)** = 서브키를 만들어내는 과정\r\n\r\n### Detailed Structure\r\n\r\n---\r\n\r\n- Feistel Cipher는 반으로 나눠서 반만 업데이트했지만 AES는 전체를 업데이트\r\n\r\n- 결과적으로 AES에서 내부적으로 하는일은 전체적인 데이터의 블록(4x4)들을 substitution과 permutation을 이용해서 업데이트함\r\n\r\n> key가 128bit = 4 word, round가 10일 때,  \r\n> 필요한 라운드키는 4\\*11 word 총 word 44개가 필요  \r\n> 하나의 열에 8bit짜리 4개가 존재(4byte 한 줄) 이 4개를 합쳐서 하나의 w로  \r\n> 이를 w[0] ~ w[43]으로 표현할 것임\r\n\r\n![](./aes-ed.png)\r\n구현상의 편의성때문에 마지막 프로세스에선 Mix columns없음\r\n\r\n## 4개의 프로세스\r\n\r\n> 3가지의 substitution과 1가지의 permutation으로 이루어진다\r\n\r\n1. Substitute bytes : (Substitution)\r\n2. Shift Rows : (Permutation)\r\n3. Mix Columns : 여러 라운드로 진행됨 (Substitution)\r\n4. Add Round Key (such as XOR) (Substitution)\r\n\r\n`Shift Row`는 byte들의 위치를 바꿔주고 나머지 연산들은 byte들을 다른 byte로 대체해주는 역할을 한다\r\n\r\n**각 stage들은 역연산이 가능하다.**  \r\n즉, 복호화할 때는 순방향이 아니라 역방향으로 진행한다\r\n얘는 암호화 과정과 복호화 과정이 똑같지않음\r\n\r\n입력의 일부분이 출력의 여러부분에 분산해서 영향을 미치도록 만들면서 입력과 출력간의 관계가 잘 드러나지않게 하는 것이 최종 목적\r\n\r\n---\r\n\r\n### 1. Substitute Bytes\r\n\r\n---\r\n\r\n![](./subbyte1.png)\r\nbyte단위로 업데이트, 치환을 해준다.\r\n\r\n4x4 byte(128bit)중 하나의 byte를 S-box라고 함\r\n\r\n![](./s-box.png)  \r\nS-box각 바이트들을 다른 바이트로 대체해주는 규칙  \r\n모든 S-box사용자들이 같은 규칙을 씀(key의 일부가 아니라 정해진 방법) :\r\n\r\n서로 다른 8bit가 다른 8bit와 1대1연결되어있다(역연산이 가능해야하므로)\r\n\r\n> ex)\r\n>\r\n> 8bit가 00000000일 경우, x : 0000 / y : 0000으로 보고 63을 매칭시켜준다.\r\n\r\n4x4의 state의 각 byte, 총 16개의 byte를 S-box에 보낸다\r\n\r\n16개의 byte를 독립적으로.\r\n\r\n#### 😨 S-box 연산과 역연산\r\n\r\n![](./s-box-inverse.png)\r\n\r\n1. 😨 Inverse in GF(2^8) :\r\n   각 byte에 대한 역원을 구한다.\r\n\r\n​ 00000000 : 다른 수들은 모두 곱셈의 역원이 있지만 0의 역원은 0이므로 0은 그대로 0\r\n\r\n2. 😨 Byte to bit column vector\r\n\r\n​ s-box안의 bit를 b7(최상위비트)~b0(최하위비트)에 차례대로 넣는다\r\n만약 00000001을 넣어야한다면  \r\n b7부터 차례대로 00000001이 들어간다 (b0 = 1)\r\n\r\n3. 😨 행렬곱한다!\r\n\r\n`00000000`이 들어갔다고 칠 때\r\n\r\n우선 `00000000` 과 옆의 행렬을 곱해서(bn \\* 각 행의 n번째원소) 차례대로 `(1)`b0~b7에 다시 넣는다 (지금은 0이 들어갔으므로 행렬곱해도 다 0으로 나옴)\r\n\r\n옆에 bit `(2)`**11000110** 를 GF에서 mod 2 하던것처럼 xor  \r\n`(1)`의 bit(이 예시에서는 00000000)와 `(2)`의 앞 bit부터 `xor`시킨다\r\n\r\n4. 😨 bit column vector to byte\r\n   결과값은 01100011으로(최상위 비트부터 읽는다) 0을 S-box에 통과시키면 63이 된다.\r\n   <br/><br/><br/>\r\n\r\n---\r\n\r\n---\r\n\r\n<br/><br/>\r\n\r\n**예시 하나 더!**\r\n\r\n- Inverse in GF(2^8)\r\n\r\n인풋이 x: 0000, y: 0001일때, 1의 역원은 1이므로 00000001이 들어간다\r\n\r\n00000001을 최상위 비트(b7)부터 담는다\r\n<br/><br/>\r\n\r\n- Byte to bit column vector\r\n\r\n| `b0` | `b1` | `b2` | `b3` | `b4` | `b5` | `b6` | `b7` |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |\r\n\r\n<br/>\r\n\r\n- 행렬곱\r\n\r\n_b0~b7이_ `10000000`이고, 행렬의 첫 번째 행이 `10001111` 이라면\\_\r\n\r\nbn과 n번째 원소를 곱하고\r\n\r\n곱한 결과들을 모두 더해서 bn에 넣는다\r\n\r\n이걸 8번 수행(b0~b7에 모두 집어넣음)\r\n\r\n`10000000` \\* `10001111` = 1 + 0 + ...+0 = 1, b0에는 1이 들어간다\r\n\r\n- 옆에 bit `11000110`과 b0~b7을 `xor`연산한다\r\n\r\n`11000110` xor `11111000` = `00111110`\r\n<br/>\r\n\r\n- bit column vector to byte\r\n\r\n`00111110`을 최상위비트(b7)부터 읽는다 : `01111100`\r\n\r\n`01111100`을 16진수로 읽으면 `7C` 즉 output은 `7C`이다.\r\n<br/><br/>\r\n\r\n---\r\n\r\n---\r\n\r\n<br/><br/>\r\n입력이 `X`(00~256), `X`의 iverse를 `Z`, 행렬을 `A`라고 할 때,  \r\nZ를 bit 벡터로 표현한뒤 A를 곱하고 그 결과에 상수 C를 더한다.  \r\nZA + C = Y(00~FF)(결과)\r\n\r\n반대로 역연산할경우 6과 3을 사용해 00임을 알 수 있다\r\n\r\n#### 😨 **역연산**\r\n\r\n역연산을 하려면? Y가 들어갔을 때 Z가 나오게 하면 된다  \r\nY - C = ZA  \r\n-A (Y - C) = Z (사실 +나 -나 동일, -A는 A의 역행렬)\r\n\r\n인풋과 아웃풋의 상관관계를 예측하기 어려운 암호가 좋은 암호\r\n\r\n-> linear 함수를 사용 자제. linear할 경우 몇 개의 p-c 쌍으로 연립방정식을 사용해 암호를 풀 수도 있음.  \r\n그래서 nonlinearity인 곱셈이나 곱셈의 역원 사용\r\n\r\n### 2. Shift Rows\r\n\r\n---\r\n\r\n![](./sr.png)\r\n\r\nplaintext를 4byte씩 잘라서 column으로 나열함  \r\n나열한 column끼리만 연산하면 잘 안 섞임  \r\n그래서 SR 필요\r\n\r\nRow, 행만 움직임. 열은 움직이지않음\r\n\r\n- 첫 번째 행은 안움직임\r\n- 두 번째 행은 왼쪽으로 한 칸\r\n- 세 번째 행은 왼쪽으로 두 칸\r\n- 네 번째 행은 왼쪽으로 세 칸 (= 오른쪽으로 한 칸)\r\n\r\n동작 자체는 간단하나 column에 대한 연산만 반복하면 잘 안섞임\r\n\r\n![](./ex2.png)\r\n\r\n### 3. Mix Columns\r\n\r\n---\r\n\r\n![](./mc.png)\r\n한 컬럼의 일 부분이 다른 컬럼의 여러 부분에 영향을 미치게 한다\r\n\r\n마찬가지로 Columns만 움직임\r\n\r\ncell하나가 하나의 byte\r\n\r\n8bit를 다항식의 개수로 본다.(GF(2^8)의 폴리노미얼로 표현되는 원소가 된다)\r\n\r\n열에 있는 네 개의 cell과 주어진 행렬과 행렬곱 시킨다\r\n\r\n> 행렬의 수는 GF(2)로 표현된 다항식으로 만약 cell이 abcd고 곱할 행렬의 행이 2 3 1 1 이라면  \r\n> 행렬곱 결과는 xa + (x+1)b + c + d 가 된다\r\n\r\n일종의 substitution연산\r\n\r\n이에 대한 역연산은 결과값에 역행렬을 곱해주면 입력값이 나온다\r\n\r\n### 4. Add Round Key\r\n\r\n---\r\n\r\n단순히 `xor` : 128bit의 State를 128bit 라운드키와 `xor`\r\n\r\n그러나 Round key expansion은 복잡\r\n\r\n## 전체적인 프로세스\r\n\r\n---\r\n\r\n![](./aes-process2.png)\r\n\r\nAdd Round Key 전에는 input이 같으면 모두 똑같이 나오지만 Round key에 따라 같은 input이더라도 다른 output이 나온다.\r\n\r\n**AES의 안전성을 보장하는 가장 큰 요인은 key이다**\r\n\r\n![](./aes-process3.png)\r\n\r\n`ShiftRows`로 인해\r\n\r\n1. 첫 번째 행은 이동 안함.\r\n2. 두 번째 행은 오른쪽으로 세 칸(=왼쪽으로 한 칸) 이동\r\n3. 세 번째 행은 오른쪽으로 두 칸 이동\r\n4. 네 번째 행은 오른쪽으로 한 칸 이동\r\n\r\n바뀐 한 byte로 인해 `MixColumns`를 하면 더 다른 다항식이 만들어진다.\r\n\r\n## key expansion\r\n\r\n---\r\n\r\n![](./key-expansion.png)\r\n\r\nnonlinearity\r\n\r\nDiffusion: 어떤 한 비트의 변화가 여러 비트에 영향을 미치게 만드는 효과\r\n\r\nw0 ~ w3이 K0\r\nw4 ~ w7이 K1\r\n\r\n### 함수 g\r\n\r\n입력받은 word를 8bit씩 쪼개 4byte로 만든다  \r\n위치를 그림과 같이 이동시키고  \r\nS-box를 사용해 치환한다  \r\n치환한 값을 어떤 상수(4byte)와 xor한다\r\n\r\n## AES의 장점\r\n\r\n안전성도 안전성이지만 여러가지 프로세스적면에서 효율적\r\n\r\n1. 8bit의 기본 연산을 사용하는 cpu에서 잘동작한다.\r\n2. xor이나 shift 오퍼레이션등 간단한 연산 사용\r\n\r\n_우리가 사용하는건 32-bit processor인데 8bit연산이 효율적일까?_  \r\n32bit에서도 잘동작함.  \r\nBS, SR, MC의 세 오퍼레이션을 하나로 합칠수있음  \r\n4table lookups + 4XORs로 끝낼 수 있다\r\n"},{"excerpt":"Malware (malicious software) 허가되지않은 일을 하기 위해 악의적으로 설계된 소프트웨어 (의도적이지 않은 결함은 bug라고 하며 멜웨어는 의도적인 소프트웨어) 트로이 목마 : 정상 프로그램으로 위장한 악성 프로그램 Root kit : 시스템의 root 권한을 획득하고 악성코드의 존재를 숨김 Backdoor : 정상 인증 절차를 우회하…","fields":{"slug":"/cp-danger/"},"frontmatter":{"date":"April 18, 2022","title":"4-1 다양한 보안 위협","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Malware (malicious software)\r\n\r\n허가되지않은 일을 하기 위해 악의적으로 설계된 소프트웨어\r\n\r\n(의도적이지 않은 결함은 bug라고 하며 멜웨어는 의도적인 소프트웨어)\r\n\r\n- 트로이 목마 : 정상 프로그램으로 위장한 악성 프로그램\r\n- Root kit : 시스템의 root 권한을 획득하고 악성코드의 존재를 숨김\r\n- Backdoor : 정상 인증 절차를 우회하여 시스템에 접속할 수 있게 하는 뒷문\r\n- 감염형 malware\r\n  - Virus : 정상처럼 보이는 프로그램 안에 숨음, 다른 프로그램들 감염\r\n  - Worm : 얘 자체가 프로그램, 능동적으로 전파, 스스로 복제\r\n- 랜섬웨어\r\n\r\n### Ransomware (ransom + ware)\r\n\r\n피해자의 기기 및 데이터를 장악(주로 암호화)해서 접근이 불가하게 만들고 민감한 데이터를 공개하는 것을 막거나 데이터를 복원하려면 비용을 지불하도록 유됴\r\n\r\n---\r\n\r\n## 블랙마켓\r\n\r\n암시장\r\n\r\n온라인으로도 유용됨\r\n\r\n제품 : 신용카드, 체크카드, 페이팔 계정, 개인정보, 악성프로그램등\r\n\r\n서비스 : 호스팅, DDoS 봇넷, 소프트웨어 불법 대여, ranswomware as a service (RaaS) 등\r\n\r\nex) 실크로드\r\n\r\n### 실크로드\r\n\r\n최초의 현대적인 darknet marker\r\n\r\n`다크웹`을 이용하기 때문에 일반 인터넷으로는 접근 불가능\r\n\r\n지금은 없음\r\n\r\n---\r\n\r\n## Darknet\r\n\r\n접근을 위해서는 특정 소프트웨어가 필요한 오버레이 네트워크\r\n\r\n주로 소규모 P2P 네트워크로 연결되거나 Tor, Freenet, ITP 등 별도적인 소프트웨어 상에서 동작\r\n\r\n### Tor (The onion router)\r\n\r\n대표적인 다크넷 제공 오픈 소스 소프트웨어 중 하나\r\n\r\n`onion routing`을 사용한 traffic anonymization technique 적용\r\n\r\n사용자의 네트워크 사용 패턴 및 위치를 숨김으로서, Network surveilance 나 traffic analysis 방지\r\n\r\n`onion routing` : 라우팅이 숨겨짐. 트래픽 익명화. 쓰는 사용자가 많아야 유리\r\n\r\n악용 사례만 있는 것은 아님. 기밀성 보장\r\n\r\n## Deep Web\r\n\r\n일반 검색 엔진으로는 드러나지 않는 웹 컨텐츠\r\n\r\n얘도 악용 사례만 있는 것은 아님. 일부가 다크웹으로 사용됨\r\n\r\n넓은 의미에서는 웹 메일(ex. gmail)의 inbox, OTT(ex. netflix)의 컨텐츠 등을 포함 : gmail 주소로 바로 gmail에 들어갈 수 없음\r\n\r\n대부분 합법적인 사이트\r\n\r\n---\r\n\r\n## 0-day\r\n\r\n0-day 공격은 컴퓨터 소프트웨어의 취약점을 공격하는 기술적 위협으로 해당 취약점에 대한 패치가 나오기 전에 이루어진다.\r\n\r\n공격의 수행 사용자와 프로그램 개발자가 잘 모르는 것이 보통\r\n\r\n공격에 사용되는 코드를 exploit이라고 함\r\n\r\n## APT (advanced persistent threat)\r\n\r\n0-day들을 조합해서 사용하는 고급 공격\r\n\r\n다양한 보안 위협들을 양산하여 특정 대상에게 지속적으로 가하는 일련의 행위\r\n\r\nex) shady rat, stuxnet(산업 시설 감시 및 파괴)\r\n\r\n## Steganography\r\n\r\n미디어 파일안에 데이터를 숨기는 기술\r\n"},{"excerpt":"Multiple Encryption 암호화를 두 번 적용하면 더 강력해지지않을까? 를 실현! 암호화를 두 번 적용 - 키가 두 개 존재 K1를 써서 나온 결과에 또 K2를 써서 암호화 두 번  C = E(K2, E(K1, P )) P = D(K1, D(K2,C)) 파훼법: Meet in the Middle Attack 중간 결과 X = E(K1, P ) …","fields":{"slug":"/multi-enc/"},"frontmatter":{"date":"April 18, 2022","title":"6-2 Modes of Operation","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Multiple Encryption\r\n\r\n암호화를 두 번 적용하면 더 강력해지지않을까? 를 실현!\r\n\r\n암호화를 두 번 적용 - 키가 두 개 존재\r\n\r\nK1를 써서 나온 결과에 또 K2를 써서 암호화 두 번\r\n\r\n![](./multiple.png)\r\n\r\nC = E(K2, E(K1, P ))\r\n\r\nP = D(K1, D(K2,C))\r\n\r\n파훼법: **Meet in the Middle Attack**\r\n\r\n중간 결과 X = E(K1, P ) = D(K2,C)\r\n\r\n중간 결과가 같은 쌍을 찾는다\r\n\r\n## Triple-DES with two keys\r\n\r\n세 번 돌리자!\r\n\r\n![](./triple.png)\r\n\r\n그러나 세 번 돌리니까 너무 오래 걸림 ...ㅠㅠ\r\n\r\n다른 방법!!! -> AES 표준\r\n\r\n## Modes of Operation\r\n\r\n모든 Block Cipher에게 적용됨 ex) DES AES\r\n\r\n### 1. ECB(Electronic CodeBook) Mode\r\n\r\n![](./ecb.png)\r\n\r\n> 암호화하려는 메시지를 여러 블록으로 나누어 각각 암호화함\r\n>\r\n> 어떤 입력이 들어오면 어떤 출력이 테이블처럼 나감\r\n>\r\n> same input -> same output\r\n\r\n- 만약 Plain text가 128bit보다 커진다면? 한 블록으로 안돼서 여러 블록으로 자를것\r\n\r\n- 각각의 블록들에 대해 같은 key를 적용한다(key는 여러개의 서브키로...)\r\n- Permutation cipher처럼 입력과 출력이 대응되어 있음 : 같은 key를 넣고 같은 plaintext를 넣으면 같은 ciphertext가 나옴\r\n\r\n- 병렬진행가능\r\n- 블록모드\r\n\r\n- 양이 많은 데이터를 암호화하는것은 추천하지않음. 짧은 데이터에서 사용됨\r\n- 모든 블록이 같은 암호화 키를 사용하기 때문에 보안에 취약함\r\n\r\n### 2. CBC (Cipher Block Chaining) Mode\r\n\r\n![](./cbc.png)\r\n\r\n> 각 블록은 암호화되기 전에 이전 블록의 암호화 결과와 XOR됨\r\n\r\n- block ciphering이 여러번 수행됨, xor사용\r\n\r\n- 문제 : 에러가 전파됨\r\n\r\n- CBC로 쉽게 MAC (=MIC)을 구현할 수 있다\r\n\r\n​ Message Actheticate Code\r\n\r\n​ Message Integrity Code\r\n\r\n- 블록 모드\r\n\r\n> **암호화가 목적이 아닌 Integrity, Athentication이 목표일 때:**\r\n>\r\n> 여러 C 1...n중 마지막 Cn만 취한다.\r\n>\r\n> key를 가지고 Encryption을 순방향으로 돌린다. 돌려서 얻은게 C'n\r\n>\r\n> Cn과 C'n이 같은지 확인한다\r\n>\r\n> 만약 P1...n중 뭐든 1bit라도 오류가 생겼다면 둘은 같지않다.\r\n>\r\n> 이걸로 올바른 key를 가진 사람에게서 데이터가 전송된 것이므로 Authentication 가능 & 데이터가 문제없이 전송됐는지 확인 가능 Integrity\r\n\r\n<br/>\r\n\r\n### 3. CFB (Cipher FeedBack) Mode\r\n\r\n![](./cfb.png)\r\n\r\n> 암호화된 결과를(그림의 C) 피드백\r\n>\r\n> CFB 모드에서는 암호 알고리즘이 생성하는 비트열을 키 스트림이라고 부름\r\n>\r\n> 키 스트림을 생성하기 위해 의사난수 생성기(암호 알고리즘)를 사용함\r\n>\r\n> 초기화 벡터(IV)가 의사난수 생성기의 seed에 해당\r\n\r\n- Block Cipher를 Stream Cipher처럼 사용 - 스트림 모드\r\n- 실제로 block이 적용되는건 xor할때뿐\r\n\r\n- CBC Mode와 비슷해 보이지만 Stream Mode이다\r\n\r\n- Plain text가 생성되기 전까지 그 다음 key stream을 만들 수 없다. (Stall)\r\n- 이를 개선한 것이 OFB. 피드백하는 부분이 바뀜\r\n- CBC처럼 에러가 전파됨 (MAC 구현 가능)\r\n- ECB, CBC 모드에서는 암호 알고리즘을 이용하여 평문 블록을 암호화했지만 CFB는 평문블록을 암호 알고리즘으로 직접 암호화하지않는다. (평문블록과 암호문블록 사이 암호화가 없음 )\r\n\r\n> 📌 **Tip!**\r\n>\r\n> Stream Mode인지 Block Mode인지 구별하려면?\r\n>\r\n> `Decryption`을 할 때 **Encrypt**를 똑같이 사용한다면 Stream Mode이다  \r\n> Block Mode는 블록 단위 별로 암호화하지만 Stream Mode는 블록으로 나누지않고 plain text자체를 한 번에 암호화 한다는 것을 기억!\r\n\r\n### 4. OFB (Output FeedBack) Mode\r\n\r\n![](./ofb.png)\r\n\r\n> 암호 알고리즘(그림의 Encrypt)의 출력을 암호 알고리즘의 입력으로 피드백\r\n>\r\n> CFB는 암호화된 결과를(그림의 C) 피드백\r\n\r\n- Block Cipher를 Stream Cipher처럼 사용\r\n- Stream Mode이다\r\n- Cipher에 피드백이 아니라 Output에 피드백\r\n\r\n- No Stalling (Preprocessing) : plaintext가 오기전에 쭉 해둘수있다\r\n- 병렬화가 안됨. 결국 앞 단계에서 결과가 나와야 뒷 단계가 진행됨 (No Parallelism) 자원이 많아도 성능을 향상시키는데 한계가 존재\r\n- 에러 전파가 안됨 (아웃풋을 피드백하는거라서)\r\n\r\n### 5. CTR (Counter) Mode\r\n\r\n![](./ctr.png)\r\n\r\n- Stream Mode\r\n\r\n- 병렬화하면서 동시에 같은 블럭이 다른 블럭으로 나올 수 있게 되어있음(Plaintext가 같더라도 Ciphertext가 다르게 나온다)\r\n- 카운터를 입력으로 줌. 카운터는 숫자 ex) 1\r\n- 피드백이 없지만 Counter들끼리 연관되어있다 1, 2, 3 ...\r\n- Counter가 달라서 Plaintext이 같아도 다른 Ciphertext이 나옴\r\n- Random access : 꼭 첫번째 Plaintext부터 Encryption 안해도 됨. 150번째 P부터 하고싶다면 Counter를 150으로 시작하면된다\r\n\r\n### 다섯가지 특징 비교\r\n\r\n![](./check.png)\r\n\r\n> 에러 전파 : cipher text의 오류가 계속 전파될 수 있는지. 즉, c가 다음 프로세스에 영향을 주는지를 체크  \r\n> 병렬 : p를 c로 도출하는 각 프로세스가 독립적일 수 있는지  \r\n> Pre-processing\r\n>\r\n> plaintext가 없어도 미리 복잡한 연산을 먼저 할 수 있는가\r\n>\r\n> ECB, CBC,CFB 는 plain text가 있어야 Encrypt할 수 있으므로 불가\r\n\r\n> CTR : Confidentiality\r\n>\r\n> CBC : MAC - Integrity, Authenticataion\r\n>\r\n> CCM (CTR with CBC-MAC)\r\n\r\nMode, Block Cipher의 실제 사례를 봐보자!\r\n\r\n### IEEE 802.11 (WPA2/3)\r\n\r\n> 무선 통신 표준\r\n>\r\n> AES-CCMP\r\n\r\n무선랜을 검색해보면 access point들 뜸.\r\n\r\nWPA2를 이용해서 보호됨 : 암호를 입력해야 access가능\r\n\r\n삼성 스마트폰, 애플 모두 무선랜에 접속가능. 표준이 있기 때문\r\n\r\n### TLS v1.3 (IETF RFC 8446)\r\n\r\n> Transport Layer Security\r\n>\r\n> Transport층에 보안을 제공한다\r\n\r\n- AES 128bit\r\n\r\n- 이전에는 SSL이라 불렸으나 버전이 올라가면서 TLS로 변경\r\n\r\n- `https` : http프로토콜을 TLS위에 올린 어플리케이션\r\n"},{"excerpt":"Symmetric Cipher Model 대칭 암호 모델 시메트릭 : 대칭 어시메트릭 : 비대칭 고전 암호는 무조건 시메트릭이다 고전 암호는 크게 과 으로 나뉜다  : 평문을 치환 - 아예 다른 글자로 대체  : 평문안의 각 글자들을 지들끼리 위치 이동시킨다 은 아예 다른 글자로 바뀌지만 은 원래 있던 글자들은 유지된다 특징 : encryption 알고리…","fields":{"slug":"/symmetric-cipher/"},"frontmatter":{"date":"April 18, 2022","title":"3-2 Symmetric Cipher Model (고전 암호)","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Symmetric Cipher Model\r\n\r\n> 대칭 암호 모델\r\n>\r\n> 시메트릭 : 대칭\r\n>\r\n> 어시메트릭 : 비대칭\r\n\r\n고전 암호는 무조건 시메트릭이다\r\n\r\n고전 암호는 크게 `Substitution`과 `Transposition`으로 나뉜다\r\n\r\n- `Substitution` : 평문을 치환 - 아예 다른 글자로 대체\r\n- `Transposition ` : 평문안의 각 글자들을 지들끼리 위치 이동시킨다\r\n\r\n`Substitution`은 아예 다른 글자로 바뀌지만 `Transposition`은 원래 있던 글자들은 유지된다\r\n\r\n> 특징 :\r\n>\r\n> encryption 알고리즘이 강해야한다.\r\n>\r\n> 수신자와 송신자는 secret key를 가지고 있어야한다\r\n\r\n### 공격자의 공격 분류\r\n\r\n---\r\n\r\n(위로 올라갈수록 어렵)\r\n\r\n## Substitution Technique\r\n\r\n---\r\n\r\n평문을 치환 - 대체\r\n\r\nex) Caesar Cipher\r\n\r\n- Monoalphbetic ciphers : 인풋이 같다면 미리 정해진 규칙에 의해 똑같이 변환된다.\r\n\r\n- Polyalphabetic ciphers : 인풋이 같더라도 아웃풋이 다를 수 있다.\r\n\r\n### 🔒 Caesar Cipher\r\n\r\n---\r\n\r\n알파벳을 3칸 옮김\r\n\r\nC = E(3,p) = (p+3) mod 26 : 알파벳이 26개\r\n\r\n> `일반화` C = E(k,p) = (p+k) mod 26\r\n>\r\n> `복원` P = D(k,C) = (C-k) mod 26\r\n\r\n`파훼법` Brute-Force : key의 모든 후보들을 다 돌려서 모든 경우를 구해봄\r\n\r\nkey의 수가 작아서 가능함\r\n\r\n그래서 발전한게 `Monoalphabetic Cipher` ex) Permutation\r\n\r\n### 🔐 Monoalphabetic Ciphers\r\n\r\n---\r\n\r\n인풋이 같다면 미리 정해진 규칙에 의해 똑같이 변환된다.\r\n\r\n#### 🔒 Permutation\r\n\r\n각 알파벳마다 임의의 글자 할당\r\n\r\n**그럼 안전할까?**\r\n\r\nNO!!!\r\n\r\n1. 암호화된 글자가 나오는 빈도수에 따라 추정\r\n2. 두글자, 세글자씩 짝 지어서 나오는 글자로도 추정 가능 ex) th, the\r\n\r\n**이런 약점을 없애려면?**\r\n\r\n1. 통계적인 정보를 없애거나\r\n\r\n   ▶ **글자를 묶어서 치환시킨다** ex) Playfair Cipher\r\n\r\n2. 완화시켜야한다\r\n\r\n   ▶ **날마다 다른 글자로 대응시킨다**\r\n\r\n### 🔒 Playfair Cipher\r\n\r\n---\r\n\r\n두글자를 두글자로 바꿔준다\r\n\r\n5x5 행렬 사용\r\n\r\n**규칙!**\r\n\r\n1. 두 글자씩 잘랐을 때, 똑같은 두 글자가 연속이면 잘 안나오는 다른 글자를 껴넣는다\r\n\r\n   > ba ll oo n -> ba lx lo on\r\n   >\r\n   > ll이 연속되었으므로 l과 l 사이 x를 넣어 연속되지않게한다\r\n\r\n2. 두 글자가 같은 열일 때\r\n\r\n   > 오른쪽으로 한 칸씩 옮긴다.\r\n   >\r\n   > ex) 'ar' 은 'RM' 으로 변환된다\r\n\r\n3. 두 글자가 같은 행일 때\r\n\r\n   > 2번과 같은 규칙. 아래로 한 칸씩 옮긴다.\r\n   >\r\n   > ex) 'mu' 는 'CM' 으로 변환된다\r\n\r\n4. 두 글자의 열과 행이 다를 때\r\n\r\n   > 두 글자를 포함시킨 사각형 구조를 만들어 대칭되는 꼭지점으로 변환한다.\r\n   >\r\n   > ex)\r\n   >\r\n   > 'hs' -> 'BP'\r\n   >\r\n   > 'ea' -> 'IM'\r\n\r\nI/J중 뭘로 하든 상관없음\r\n\r\n**두 개씩 짝지어서 변환했으므로 통계 추정하기가 더 힘들어짐**\r\n\r\n### 🔐 Polyalphabetic Ciphers\r\n\r\n---\r\n\r\n- 한글자씩 대응\r\n\r\n- `but` 대응 규칙이 여러개임\r\n\r\n- `monoalphabetic substitution` 규칙을 여러개 사용할 것\r\n\r\n- `key`에 따라 여러 개의 규칙 중 어떤 것을 선택할지 결정하게됨\r\n\r\nex) vigenere cipher\r\n\r\n### 🔒 Vigenere Cipher\r\n\r\n---\r\n\r\n- 시저 암호를 여러 개 사용함\r\n\r\n- message를 암호화하기 위해서 message와 길이가 똑같은 key가 필요\r\n\r\n- 현실적으로 그 만큼 긴 길이의 key를 만들긴 힘들어서 일정 길이의 key를 반복시킨다\r\n\r\n- **key의 번호에 맞게 각 글자를 암호화한다.** (a = 0, b = 1, ...)\r\n\r\n![](./vigenere.png)\r\n\r\n**파훼법**\r\n\r\n1. 사이클 길이를 가정한다 (key는 어떤 단어가 반복되므로 사이클이 존재)\r\n2. 사이클 길이에 맞는 통계분석을 실시\r\n\r\n그러나 `autokey`가 등장했다면?\r\n\r\nkey다음에 평문을 이어붙여 길게만든다\r\n\r\n: 사이클 추정이 불가능하다!!!\r\n\r\n**but ... 어쨌든 key에서 가장 많이 나오는 글자로 추정이 가능하다**\r\n\r\nkey도 plaintext도 영어이기때문에 가장 많이 나오는 글자가 존재\r\n\r\n어렵겠지만 추정이 가능한듯??\r\n\r\n### 🔒 Vernam Cipher\r\n\r\n---\r\n\r\n알파벳을 그대로 사용하지않고 알파벳을 어떤 코드 체계를 통해서 bit 시퀀스로 바꾼다. 그 bit 시퀀스를 keyword에 해당하는 다른 bit 시퀀스와 더한다.\r\n\r\n```\r\n(p + k) mod 2\r\n```\r\n\r\nmod 2의 재미난 성질 ~ 더하기와 빼기가 같답니다~\r\n\r\n```\r\n+` = `-` = `xor\r\n```\r\n\r\n**key bit stream을 사용해 최대한 key의 길이를 길게!**\r\n\r\n### 🔒 One-Time Pad\r\n\r\n---\r\n\r\nkey를 극단적으로 길게 만들어서 사이클이 없게\r\n\r\n```\r\nrandom key\r\n```\r\n\r\n`unbreakable` : 깨지지않음. 랜덤이라 파훼불가능. perfect secrecy!!!\r\n\r\n문제 : 현실적이지않음... 실용적x, 엄청 긴 램덤키가 필요하기때문\r\n\r\n데이터가 적고 안전성이 좋은 채널에서 사용\r\n\r\n## Transpostion Cipher\r\n\r\n---\r\n\r\n평문안의 각 글자들을 지들끼리 위치 이동시킨다\r\n\r\nex) Rail Fence Cipher\r\n\r\n### 🔒 Rail Fence Cipher\r\n\r\n---\r\n\r\nplaintext를 대각선 형태로 쓰고 행으로 읽음\r\n\r\ndepth(몇 개의 행)\r\n\r\n### 🔒 Row Transposition Cipher\r\n\r\n---\r\n\r\n레일 펜스보다 복잡함\r\n\r\nkey는 1~n까지의 수, key에 해당하는 열 순으로 읽음\r\n\r\n### 🔒 Steganography\r\n\r\n---\r\n\r\n평범한 메시지인척 비밀 메시지 숨겨놓기~\r\n\r\n- 캐릭터 마킹 : 타자가 된 글자에 연필로 일부 글자 덮어쓰기\r\n- Invisible ink : 열 가하면 보이는 잉크\r\n- Pin punctures : 잘안보이는 구멍\r\n- Typewriter correction ribbon : 타자된 글자기에 리본...을 흡수 ..뭐요? 어쨌뜬 타자기를 활용해서 글자를 보일락말락하게\r\n\r\n`단점` :\r\n\r\n오버헤드, 조그만 양을 숨기기위해 많은 데이터 필요\r\n\r\n숨겼다는 사실만 알면 들키기 쉬움\r\n\r\n`장점` :\r\n\r\n평범하게 보임. 암호문이라는 것을 눈치채기어려움\r\n"},{"excerpt":"난수 생성 난수는 왜 필요? 그냥 대부분의 암호에 필요하다... 보통 key에 사용됨 암호의 안전성은 key에 기반하기때문에 key생성이 중요함 난수의 조건 Randomness  : 나올 수 있는 수들의 분포가 균일해야한다  : 서로 독립적. 긴 시퀀스로 봤을 때 부분 부분간의 연관관계가 없어야함. 반복되는 구간이 존재하지않는다. Unpredictabil…","fields":{"slug":"/pseudo-random/"},"frontmatter":{"date":"April 18, 2022","title":"7-2 난수 생성","tags":["computer protection"]},"rawMarkdownBody":"\r\n## 난수 생성\r\n\r\n> **난수는 왜 필요?**\r\n>\r\n> 그냥 대부분의 암호에 필요하다... 보통 key에 사용됨\r\n>\r\n> 암호의 안전성은 key에 기반하기때문에 key생성이 중요함\r\n\r\n#### 난수의 조건\r\n\r\n- Randomness\r\n\r\n  `Uniform distribution` : 나올 수 있는 수들의 분포가 균일해야한다\r\n\r\n  `Independence` : 서로 독립적. 긴 시퀀스로 봤을 때 부분 부분간의 연관관계가 없어야함. 반복되는 구간이 존재하지않는다.\r\n\r\n- Unpredictability\r\n\r\n  예측이 불가능해야한다\r\n\r\n  어떤 구간을 보고 그 다음 구간을 예측할 수 없어야한다\r\n\r\n### Pseudorandom Numbers\r\n\r\n> 난수를 만드는 것은 자원이 많이 드는 일\r\n>\r\n> 진짜 랜덤은 아니지만 랜덤처럼 보이는 시퀀스를 만들어내는 알고리즘이 더 일반적\r\n>\r\n> Deterministic algorithm\r\n\r\n- TRNG = 진짜 난수 생성기\r\n- PRNG = 수도 난수 생성기 : 무한 stream 출력\r\n- PRF = 수도 난수 함수 : 길이가 정해져있는 value 출력\r\n\r\n### TRNG\r\n\r\n- entropy를 만들어내는 함수로 entropy source라고도 불린다\r\n- 물리적인 특성들을 가지고와서 사용하는 경우가 많다\r\n\r\n ex) keystroke timing, disk electrical activity, mouse movements\r\n\r\n- 보통 TRNG로 seed를 만들고 PRNG를 돌려서 더 긴 시퀀스를 만들어낸다\r\n\r\n- 아날로그 소스들을 받아서 바이너리 아웃풋으로 내보낸다\r\n\r\n- 경우에 따라서 bias가 있기도 한다 : 이럴경우 bias를 처리해줘야함\r\n\r\n### PRNG\r\n\r\n- deterministic algorithm\r\n- key stream을 만들어낸다\r\n- input이 정해지면 output도 정해진다\r\n- 그렇기에 seed값을 안전하게 잘 보호해야함\r\n\r\n### PRF\r\n\r\n- 길이가 고정된 아웃풋을 만들어낸다\r\n\r\n## PRNG와 PRF의 조건\r\n\r\n- Randomness\r\n- Unpredictability\r\n- Characteristics of the seed : seed를 안전하게 보관한다\r\n\r\n진짜 난수는 아니지만 난수성을 만족\r\n\r\nseed를 모르면 PRNG가 만들어낸 아웃풋이 랜덤처럼 보여야한다\r\n\r\n## Randomness 정량적 평가 방법\r\n\r\n- Frequency test: 0과 1이 몇 개씩 나오는지 확인\r\n\r\n- Runs test : 같은 비트가 반복되면 안됨\r\n\r\n- Maurer's universal statistical test : 시퀀스를 압축을 시켰을 때 잘 되는지\r\n\r\n등등 15가지가 존재\r\n\r\n## Seed Requirements\r\n\r\n- 시드는 secure하고 unpredictable해야한다\r\n\r\n- 수도랜덤넘버를 사용하기도하지만 시드는 보통 진짜 랜덤, TRNG로 만든다\r\n\r\n## Algorithm Design\r\n\r\n**PRNG 알고리즘 설계**\r\n\r\n- 이미 존재하는 암호 알고리즘을 기반으로 만들거나\r\n- 난수 생성 자체를 목적으로, 전용으로 만들어서 쓸 수도있음\r\n\r\n## Linear Congruential Generator : 안전 x\r\n\r\n- 많이 생성하는 난수 생성기이나 암호학적으로는 사용할 수 없음\r\n\r\n- X0은 seed\r\n\r\n- 1차식이기 때문에 위험\r\n\r\n## PRNG Using Block Cipher Modes of Operation\r\n\r\n- CTR mode\r\n- OFB mode\r\n\r\n### NIST CTR_DRBG\r\n\r\n- Counter mode\r\n- 굉장히 많이 쓰임. Intel cpu에서도 사용\r\n- entropy source가 있어야함. entropy소스로 부터 seed를 받아서 카운터 기반의 PRNG를 돌려서 긴 수도 랜덤 시퀀스를 만들어낸다\r\n- 3DES와 AES를 사용\r\n\r\n## Stream Cipher Desing Considerations\r\n\r\n수도 랜덤 생성 전용 스트림 함수\r\n\r\n- period가 길어야 함. seed값이 같으면 계속 넘버를 생성할 경우 일정 싸이클이 반복되게된다\r\n- true random number stream처럼 보여야한다. - 분포나 연관관계 없어보여야함\r\n- key length가 최소한 128bit - 키가 짧으면 공격자가 추측해보기 쉬움\r\n- 비슷한 key length를 가지는 블록싸이퍼와 비슷한 안전성을 갖길 기대\r\n\r\n### RC4\r\n\r\n키 사이즈 변경 가능\r\n\r\n바이트 단위로 연산가능\r\n\r\nSSL에 사용됐었음\r\n\r\n후속버전임 TLS에서도 쓰였음\r\n\r\n무선랜에서도 쓰였\r\n\r\n**그러나 broken됐음...**\r\n\r\n### ChaCha20\r\n\r\nSalsa20암호를 살짝 바꾼...\r\n\r\n## TRNG and Entropy Source\r\n\r\n- nondeterministic\r\n- Sound/Vide, Disk driver 등을 모아서 trun random number를 만들기위한entropy source로 사용한다\r\n\r\n## Conditioning\r\n\r\nentropy source가 있으면 다 해결?\r\n\r\nbias가 있을수도\r\n\r\n후처리필요\r\n\r\n후처리를 해서 bias를 없앴을때 동전던지기를 몇번 한 효과가 있을것이냐를 디지털화된 노이즈 소스가 제공하는 난수성이 어느정도냐 entropy ratio\r\n\r\nbias를 conditioning알고리즘으로 돌려서 랜덤 효과를 늘림\r\n\r\n## Intel Digital Random Number Generator\r\n\r\nbias가 있어도 AES를 돌리다보면 random한 것 처럼 변함\r\n\r\nRing Oscillator기반의 entropy source에다가 AES CBC MAC을 집어넣어서 컨디셔닝을 해서 TRNG를 만들고 AES couter mode를 돌려서 PRNG를 만든다\r\n\r\nintel에서 이걸 써먹을 수 있는 라이브러리를 줌\r\n\r\n"},{"excerpt":"MITRE 미국의 비영리 단체로 보안에 대한 자료들이 올라와있음 CVE, CWE, CAPEC CVE 많이 나오는 공격들. 알려져있는 취약점 CWE CVE에 기반해서 만든 분류 체계 CAPEC 공격들을 추상화해서 신경써서 분석해야할 것들을 분류 OWASP (Open Web Application Securty Project) 웹 응용 보안을 다루는 오픈 커뮤…","fields":{"slug":"/web-hack/"},"frontmatter":{"date":"April 18, 2022","title":"5-1 Web Hacking Overview","tags":["computer protection"]},"rawMarkdownBody":"\r\n## MITRE\r\n\r\n> 미국의 비영리 단체로 보안에 대한 자료들이 올라와있음  \r\n> CVE, CWE, CAPEC\r\n\r\n### CVE\r\n\r\n많이 나오는 공격들. 알려져있는 취약점\r\n\r\n### CWE\r\n\r\nCVE에 기반해서 만든 분류 체계\r\n\r\n### CAPEC\r\n\r\n공격들을 추상화해서 신경써서 분석해야할 것들을 분류\r\n\r\n## OWASP (Open Web Application Securty Project)\r\n\r\n웹 응용 보안을 다루는 오픈 커뮤니티\r\n\r\n📌 Broken Access Control :\r\n\r\n말그대로 access control에 문제가 생김\r\n\r\n📌 Crypographio Failures :\r\n\r\n암호화 하는 것에 문제\r\n\r\n📌 Injection :\r\n\r\nCross-site Scripting이나 sql injection등 정상적이지않은 명령을 주입\r\n\r\n📌 Insecure Design : 보통 구현이 잘못되는데 얘는 디자인 자체가 잘못된\r\n\r\n📌 Security Misconfiguration :\r\n\r\n보안 설정 잘못함\r\n\r\n📌 Vulnerable and Outdated Components :\r\n\r\n취약점에 대한 패치가 나왔으나 적용을 안해서 여전히 취약점이 남아있음\r\n\r\n📌 Identification, and Authentication Failures :\r\n\r\n사용자 식별, 인증 실패\r\n\r\n📌 Software and Data Integriry Failures\r\n\r\n인터그리티가 확인이 안됨. 전자서명이 안된 프로그램을 설치하거나\r\n\r\n📌 Security Logging and Monitoring Failures\r\n\r\n사고가 발생되면 수습을 해야함. 사고 발생자에게 경고를 주거나 사고에 대한 분석, 포렌식을 하는데 문제\r\n\r\n📌 Server-Side Request Forgery\r\n\r\n서버 취약점을 공격\r\n\r\n## Web 기본 지식\r\n\r\n- 사용자, 브라우저, 웹 서버, 백엔드\r\n\r\n보안 관점에서 브라우저는 프로그램이고 사용자는 프로그램이 아님\r\n\r\n브라우저 : 사용자 입력을 받아 소통\r\n\r\n사용자가 실제로 볼 수 있게 처리 : rendering\r\n\r\n### 브라우저와 웹 서버 간의 통식\r\n\r\n보통 http사용\r\n\r\n보안성을 추가한 https\r\n\r\n- HTTP : 브라우저와 웹 서버 사이의 통신을 정의하는데 사용 TCP 프로토콜 상에서 돌아감\r\n\r\n- HTTPS : 보안 계층에 SSL/TLS도 추가. 웹 서버가 브라우저에게 인증서를 제공함으로써 보안성 있는 통신을 할 수 있도록 함\r\n\r\n> https를 사용하면 웹 통신이 안전할까?\r\n\r\n> 어느부분은 맞고 어느 부분은 틀리다\r\n\r\n> 브라우저와 웹 서버간의 통신은 안전할지라도 사용자라는 취약점이 존재해서 무조건 안전한 것은 아님\r\n\r\n### 웹서버\r\n\r\n- 웹서버 : 브라우저 요청 사항을 처리하는 일에 중점을 둔다.\r\n\r\n* 웹 서버는 어떤 동작을 수행할지 결정하기 위해 HTTP헤더 뿐만 아니라 URL을 사용한다\r\n\r\n- get, post를 처리해줄 수 있는 최소한의 서버 ex. 아파치\r\n\r\n* 웹 서버는 서버 측 스크립트와 함께 동작한다\r\n\r\n* 서버 측 스크립트 (= Web Application Server, WAS) ex. python, java\r\n\r\n* 서버 측 스크립트는 코드를 실행시켜서 응답을 바로 생성하거나 데이터베이스와 같은 다른 백엔드 서버와 연결한 다음 해당 정보를 이용해서 적절한 응답을 생성한 후 보낸다 파일 db등과 연결하려며 WAS가 필요\r\n\r\n_보통 웹서버는 잘 나와있는 솔루션을 뜨고 웹 어플리케이션 서버는 개발자가 개발_\r\n\r\n> 백엔드 서비스 : 서버 측 스크립트와 연결된 부가적인 서비스를 백엔드라고함\r\n\r\n> 웹 서버의 백그라운드에서 실행되는 서비스\r\n\r\n> 정보를 저장하는데 쓰이는 데이터베이스등이 있다\r\n\r\n## Web Hacking Overview\r\n\r\n### 📌 Injecting Malicious Data\r\n\r\n- vaildatior를 만족하지 않는​ 부적절한데이터를 강제로 주입  \r\n  Browser WS WAS\r\n\r\n![](./injecting.png)\r\n\r\n​ 1. 웹서버에 들어오기 전에 이미 err발견하지만 강제로 침입\r\n브라우저 내에서 발생하거나, 브라우저에서 체크했으나 웹 통신중 이상함 발견\r\n\r\n- HTTP Header Manipulation : 헤더의 `REFERER`를 조작해서 프로모션 받기 가능\r\n- Cookie Poisoning :\r\n  쿠키: 세션 아이디 등 임시 정보가 담겨있음  \r\n   남의 쿠키를 저장해서 사용하면 타인 아이디로 로그인 가능\r\n\r\n### 📌 Exploiting Uhchecked Input\r\n\r\n- 웹 서버가 정상 입력으로 간주하게 되어서, 백엔드 서비스 등에 2차 피해를 일으키는 공격\r\n\r\n* 게시판과 같이 동적으로 생성되는 Page에 조작된 코드를 넣어서 다른 사용자에게 공격자가 원하는 코드를 실행하게 함\r\n\r\n​ 2. 여기까지오고 나중에 DB 가서 보니까 err\r\nWAS에서 ok해서 DB에 보냈지만 DB에서 에러 발생\r\n"},{"excerpt":"APIView를 활용한 뷰 만들기 Serializer 정의 첫 번째 인자로 인스턴스를 받음 instance는 객체 post, put하는데 사용 두 번째 인자로 데이터를 받음 data는 form에서 requests.POST'name'가져오는것처럼 data를 받아오는 거인듯 Form 에서 첫 번째 인자는 data지만 시리얼라이저의 생성자의 첫 번째 인자는 i…","fields":{"slug":"/serializer/"},"frontmatter":{"date":"April 18, 2022","title":"REST","tags":["django","DRF"]},"rawMarkdownBody":"\r\n# APIView를 활용한 뷰 만들기\r\n\r\n## Serializer 정의\r\n\r\n```python\r\nclass PostSerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n\r\nserializer = PostSerializer(data=request.POST)\r\n\r\nif serializer.is_valid():\r\n    return JsonResponse(serializer.data, status=201)\r\n#form의 __clean_data처럼 serializer.data를 통해 유효성 검사를 거친 데이터를 가져올 수 있다.\r\n#이건 장고 restframework의 기능을 안쓰고 form의 기능만 쓴 것\r\n#drf를 적용하려면 APIView 클래스 혹은 @api_view 장식자를 사용한다\r\nreturn JsonResponse(serializer.errors, status=400)\r\n```\r\n\r\n- 첫 번째 인자로 인스턴스를 받음\r\n\r\n  - instance는 객체 post, put하는데 사용\r\n\r\n- 두 번째 인자로 데이터를 받음\r\n\r\n  - data는 form에서 requests.POST['name']가져오는것처럼 data를 받아오는 거인듯\r\n\r\n    \r\n\r\n\r\n> Form 에서 첫 번째 인자는 data지만 시리얼라이저의 생성자의 첫 번째 인자는 instance이다\r\n\r\n```python\r\nPostSerializer(Post.objects.first()) # 인스턴스 객체를 넘겨준다\r\nPostSerializer(Post.objects.all(), many = True) # 다수도 가능\r\nPostSerializer(Post.objects.first()).data # 직렬화된 데이터가 나온다\r\n```\r\n\r\n\r\n\r\n## APIView\r\n"},{"excerpt":"Groups 두 가지에 대한 순서쌍 어떤 연산과 집합으로 합쳐서 정의  연산은 +도 될 수 있고 *도 될 수 있음. +일 경우엔 additive 그룹이라 부르고 * 경우엔 multiplicative 그룹이라고 부름 그룹을 만족시키는 필수 성질  : 닫혀있음 G안에 있는 a와 b가 있을 때 그 둘을 연산한 (a · b) 도 G안에 있어야한다  : 결합법칙 …","fields":{"slug":"/finite-field/"},"frontmatter":{"date":"April 18, 2022","title":"4-2 finite field (Galois Field)","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Groups\r\n\r\n두 가지에 대한 순서쌍\r\n\r\n어떤 연산과 집합으로 합쳐서 정의\r\n\r\n`·` 연산은 +도 될 수 있고 \\*도 될 수 있음.\r\n\r\n+일 경우엔 additive 그룹이라 부르고 \\* 경우엔 multiplicative 그룹이라고 부름\r\n\r\n### 그룹을 만족시키는 필수 성질\r\n\r\n1. `Closure` : 닫혀있음\r\n\r\nG안에 있는 a와 b가 있을 때 그 둘을 연산한 (a · b) 도 G안에 있어야한다\r\n\r\n2. `Associative` : 결합법칙\r\n\r\n   (a · b) · c = a · (b · c)\r\n\r\n3. `Identity element` : 항등원\r\n\r\n   a · e = a 를 만족시키는 항등원 e가 G에 존재한다\r\n\r\n   additive 그룹일경우 e = 0, multiplicative 그룹일경우 e = 1\r\n\r\n4. `Inverse element` : 역원\r\n\r\n   a · -a = e인 역원 a-1이 존재\r\n\r\n### Abelian group\r\n\r\n5. `Commutative` : 교환 법칙\r\n\r\n   G안의 모든 a와 b에 대해서 a · b = b · a 가 만족한다\r\n\r\n### Cyclic Group\r\n\r\nG안에 어떤 원소 a가 있는데 G의 모든 요소들을 aⁿ 형태로 나타낼 수 있을 때 `cyclic`하다고 한다\r\n\r\n이 때 a를 `generator`라고 부르고 그룹을 `generate`했다고함\r\n\r\n모든 `cyclic`그룹은 `abelian` 그룹이다.\r\n\r\nExponentiation : 그룹 연산을 반복해서 적용\r\n\r\nex) a³ = a · a · a\r\n\r\n## Fields\r\n\r\n어떤 집합과 연산 두 가지를 가지고 정의\r\n\r\n_(Group은 연산이 한 가지)_\r\n\r\n(GF로는 연산값을 mod했을 때 mod값이 전부 G에 포함인듯?\r\n\r\nGF(7) = [ {0, ... , 6}, + mod 7, \\* mod 7])\r\n\r\n- 그룹의 성질 1번 ~ 5번 모두 만족 (덧셈, 곱셈 모두에 대해서 abelian group 성립)\r\n\r\n- zero divisors 가 없음\r\n\r\n  만약 ab = 0이라면, a or b = 0이어야함\r\n\r\n- 덧셈과 곱셈에서 분배 법칙이 성립한다\r\n\r\n> 덧셈에서 그룹이라는 의미는 :\r\n>\r\n> 뺄셈 a - b는 a + (b의 역원)으로도 표현이 가능하다.\r\n>\r\n> 그룹의 모든 원소는 덧셈의 역원이 존재하므로 덧셈에서 그룹이라는건 뺄셈도 가능하다는 뜻\r\n>\r\n> 마찬가지로 곱셈에서 그룹이\r\n>\r\n> 라는 의미는:\r\n>\r\n> 그룹의 모든 원소는 곱셈의 역원이 존재하므로 나눗셈이 가능하다\r\n\r\n즉, 필드는 덧셈, 뺄셈, 곱셈, 나눗셈이 그 집합을 떠나지않고 잘 정의가 되는 구조\r\n\r\n유리수, 실수, 복소수는 모두 필드의 예시가 될 수 있으나\r\n\r\n정수는 필드가 될 수 없다\r\n\r\nwhy? **곱셈의 역원이 없는 수가 있기 때문**\r\n\r\nex) 3의 곱셈의 역원은 1/3 (not 정수!!)\r\n\r\n## Finite fields (=Galois Field)\r\n\r\n유한체 : 원소의 개수가 유한한 집합\r\n\r\nFinite fileds의 원소 개수는 반드시 pⁿ개 이다 (p는 소수)\r\n\r\nex) GF (15) - (x), GF(7) - (o)\r\n\r\n### 📌 GF(p) - Prime field\r\n\r\n원소의 개수가 pⁿ개인데 n이 1\r\n\r\n곱셈의 역원이 없는 정수들도 있지만\r\n\r\nmodulo와 서로소인수는 모두 곱셈의 역원이 있다\r\n\r\n**즉, modulo가 prime number라면 0을 제외한 모든 수(1~p-1)가 곱셈의 역원이 존재한다**\r\n\r\n\\# 덧셈의 역원 (mod 7)\r\n\r\n![](./addmod.png)\r\n\r\n\\# 곱셈의 역원 (mod 7)\r\n\r\n![](./mulmod.png)\r\n\r\n곱셈의 역원을 구하려면 `Extended euclid algorithm`을 써야함\r\n\r\n곱셈의 역원 테이블을 보면 대칭임 (= Abelian group, 교환법칙이 가능하다는 뜻 )\r\n\r\nGF(7) = [ {0, ... , 6}, + mod 7, \\* mod 7] <- 두 가지 연산을 모아서 필드가 정의됨\r\n\r\n지금까지 얘기한 것은 `Prime field`!\r\n\r\n> GF(pⁿ) 인데 n = 1\r\n\r\n이제 `Binary field`에 대해서 알아보자\r\n\r\n> GF(pⁿ) 인데 p = 2\r\n\r\n`Binary field`를 쓰는 이유는?\r\n\r\nDES같은 암호에서 입력이 64bit들어오면\r\n\r\nAES는 128bit 8bit로 나눠서 사용(256가지 조합. 2의 8승)\r\n\r\n256은 prime 아님 . 복잡해 ~~~\r\n\r\nbinary 쓰는게 맘 편함 ~ ㅎ 256가지 가지고 얍하려면 바이너리가 좋음\r\n\r\nGF(2^8)\r\n\r\n### 📌 Polynomial Divison\r\n\r\nf(x) = q(X)g(X) + r(x)\r\n\r\nr(x) = f(x) mod g(x)\r\n\r\n만약 r(x)가 0, (= g(x)가 f(x)를 나눴다면)\r\n\r\ng(x)|f(x)\r\n\r\ng(x) 는 f(x)의 `factor` or `divisor`이라고 부른다.\r\n\r\n#### irreducible\r\n\r\n> 어떤 다항식 f(x) 가 필드 F에 대해서 `irreducible`하다\r\n>\r\n> f(x)를 차수가 더 작은 두 개 이상의 다항식 곱으로 나타낼 수 없다\r\n>\r\n> 즉, 인수분해 될 수 없음\r\n>\r\n> prime과 비슷한 개념\r\n\r\n### 📌 GF(2) = Binary Field\r\n\r\n각 계수별로 mod 2 연산을 수행\r\n\r\nmod 2를 하면 덧셈과 뺄셈이 같아진다 `xor`\r\n\r\n`x` = `-x` = `xor`\r\n\r\n### 📌 Polynomial GCD\r\n\r\n두 다항식 a(x)와 b(x)의 GCD c(x)도 존재한다.\r\n\r\nc(x)는 a(x)와 b(x) 둘을 나눌 수 있다\r\n\r\n유클리드 알고리즘을 가지고 구할 수 있다\r\n\r\ntable 5.3은 GF(2³)\r\n\r\n![](./gf.png)\r\n\r\n> **Addition mod - 덧셈의 역원**\r\n>\r\n> (mod 2 이므로 같은 것을 더하면 0이 된다.)\r\n>\r\n> (x² + 1) 과 (x+1)을 더했을 때\r\n>\r\n> x² + x + 2 (2는 mod2로 인해 사라진다)\r\n>\r\n> 결과 : x² + x\r\n>\r\n> 좀 더 기계적?으로 보자면\r\n>\r\n> (x² + 1) = 101, (x+1) = 011\r\n>\r\n> 101과 011을 xor 연산하면 110. 즉, x² + x\r\n>\r\n> xor하는 이유는 mod 2에서 덧셈 = 뺄셈 = xor\r\n\r\n> **Multiplication mod**\r\n>\r\n> (x² + 1) 과 (x+1)을 곱했을 때 결과는 x³ + x² + x + 1\r\n>\r\n> modulo x³ + x + 1 인데 모듈러보다 결과값이 크므로 모듈러로 mod해준다\r\n>\r\n> (x³ + x² + x + 1) mod x³ + x + 1 는 x²\r\n>\r\n> 비트로 계산하려면 `xor`과 `shift`를 사용한다!!\r\n>\r\n> (x² + 1) = 101, (x+1) = 011\r\n>\r\n> 101 \\* 011 = 1111 = (1000 + 111)\r\n>\r\n> 1000을 mod 1011하면 결과는 011!\r\n>\r\n> (mod의 최고 차항을 mod로 나누면 최고차항을 뺀 나머지 다항식이 나머지가 된다. 예시로 x³ 을 x³ + x + 1로 나누면 나머지는 x + 1 )\r\n>\r\n> 1111 = (1000+111) = 011 + 111 = 100 즉, x²이다\r\n"},{"excerpt":"classification of Symmetric Encryption 현대에서 쓰이는 Symmetric Encryption은 Stream Cipher와 Block Cipher로 나뉜다.  Stream Cipher : key를 seed값으로 써서 bit stream generation 알고리즘을 돌림. 평문과 key를 연산 ideal case : One-t…","fields":{"slug":"/steam-block/"},"frontmatter":{"date":"April 18, 2022","title":"4-2 Stream Cipher와 Block Cipher","tags":["computer protection"]},"rawMarkdownBody":"\r\n## classification of Symmetric Encryption\r\n\r\n현대에서 쓰이는 Symmetric Encryption은 Stream Cipher와 Block Cipher로 나뉜다.\r\n\r\n![](./sb.png)\r\n\r\n- **Stream Cipher** : key를 seed값으로 써서 bit stream generation 알고리즘을 돌림. 평문과 key를 `xor`연산\r\n\r\n  ideal case : One-time pad\r\n\r\n- **Block Cipher** : 평문을 128bit단위로 잘랐다면 또 다른 128bit로 변경. 어떻게 변경할건지의 규칙이 key.\r\n\r\n  같은 평문이라도 어떤 key냐에 따라서 다른 cipher text생성\r\n\r\n  **key에 의해서 block cipher의 동작이 결정됨.**\r\n\r\n  **동작은 본질적으로 block 단위를 다른 블록으로 덮어쓰는 역할을 함**\r\n\r\n  (이 두 개가 중요함. 다른건 그냥 흐름정도만 이해)\r\n\r\n### Feistel Cipher\r\n\r\n**Block Cipher의 일종**\r\n\r\n> plain text를 두 부분으로 자르고 연산 반복  \r\n> <font size =\"2px\">(_두 개로 잘랐으니까 블록임. 암튼 블록임._) </font>  \r\n> 연산을 각각 한 다음에 두 개를 교차함  \r\n> 암호화와 복호화가 키 순서를 제외한 전체가 같은 계산을 반복한다\r\n\r\n- 많은 블록암호가 Feistel Cipher 형식을 취한다.\r\n\r\n- 물론 Feistel Cipher 형식이 아닌 블록암호도 있다 (ex. AES)\r\n\r\n- 내부적으로 substitution과 permutation으로 구성되어있다\r\n\r\n* Substitutions : 각 plaintext의 요소나 그룹 bit들을 다른 ciphertext 그룹으로 대체. 치환\r\n* Permutations : 각 원소의 순서를 바꿈. 위치이동. 전치. (permutation cipher와 혼동하면 안됨. 걔는 substitution의 일종)\r\n\r\nex) DES\r\n\r\n![](./des.png)\r\n\r\n치환, 전치 (두 개로 자르고 교차한다)\r\n\r\n라운드키, 서브키\r\n\r\n### Substitution-Permutation Network (SPN)(ex. AES)\r\n\r\n교차가 없음\r\n\r\nex) AES\r\n\r\n![](./aes.png)\r\n"},{"excerpt":"Access Control 접근제어 시큐리티 서비스 중 한 가지 어떤 공격에 대응하는 가장 효율적인 방법 중 하나 공격이 일어나기 전에 막는다 어떤 access 권한들이 있고 어떻게 허용할 것인지 엄격하게 정의 인가되지않은 공개, 부적절한 변경으로부터 데이터와 리소스를 보호하는 절차 Access Control의 Security policy 📌 Discre…","fields":{"slug":"/access-control/"},"frontmatter":{"date":"April 16, 2022","title":"1-2 Access Control","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Access Control\r\n\r\n---\r\n\r\n> 접근제어\r\n\r\n- 시큐리티 서비스 중 한 가지\r\n\r\n- 어떤 공격에 대응하는 가장 효율적인 방법 중 하나\r\n\r\n- 공격이 일어나기 전에 막는다\r\n\r\n- 어떤 access 권한들이 있고 어떻게 허용할 것인지 엄격하게 정의\r\n\r\n- 인가되지않은 공개, 부적절한 변경으로부터 데이터와 리소스를 보호하는 절차\r\n\r\n## Access Control의 Security policy\r\n\r\n---\r\n\r\n### 📌 Discretionary access control (`DAC` : 임의적 접근제어)\r\n\r\n​ 필수적인 요구조건이 있는 것이 아니라 사용자가 임의적으로 정함\r\n\r\n​ 정보의 소유자가 해당 정보에 대한 read, write, execute 권한을 모두 정함\r\n\r\n​ 사용자의 id나 groupid에 기반해서 제약 조건을 건다\r\n\r\nex) ACL(Access control list)\r\n\r\n`장점 ` : 주체별로 어떤 동작이 가능한지 세세하게 설정할 수 있다\r\n\r\n`단점` : 사용자를 어떻게 믿을 것 인지, 원치않게 권한이 상승할 수 있다\r\n\r\n### 📌 Mandatory access control (`MAC` : 강제적 접근 제어)\r\n\r\n​ 관리자가 접근 제어\r\n\r\n​ 규칙 기반 : **rule-based access control**\r\n\r\n​ ex)\r\n\r\n- Security label(중요도에 따라 계층이 나뉨)\r\n\r\n- Bell-LaPadula model\r\n  - read-up (x) : 2급이 1급 정보를 볼 수 없음\r\n  - write-down (x) : 1급 내용을 2급에 덮어쓸 수 없음\r\n- sandboxing : 벽을 두고 서로 넘어가지 못하게 함\r\n\r\n## Access Control Models(Implementations)\r\n\r\n---\r\n\r\n정책을 구현하는 실질적인 방법\r\n\r\n### 📌 Access Control Matrices(ACM)\r\n\r\n---\r\n\r\n- permissions을 정리하는 2차원 테이블\r\n\r\n- 객체와 주체가 있고 각 주체들이 객체들에 대해 어떤 동작을 할 수 있는지 명세\r\n\r\n- 직접적으로 구현하는 것은 비효율적. 공간이 어마어마!\r\n\r\n- 대부분 줄여서 사용\r\n\r\n- ex) 대부분의 entry들은 비어있을것. 이를 압축해서 표현\r\n\r\n### 📌 Access Control Lists (ACL)\r\n\r\n---\r\n\r\n![](./acl.png)\r\n\r\n- **객체 위주로 압축**, DAC의 일종\r\n\r\n- 간소화한 ACL : Unix File access control\r\n\r\n- 유닉스는 owner, group owner, other users 이렇게 세 가지로 뭉뚱그려서 표현\r\n\r\n- id별로 다 표시하진않음. ACM보다 정밀도가 떨어짐. 세부적 컨트롤이 어려움\r\n\r\n- ex) 특정 부분에 대한 access나 어떤 특정한 사용자를 제외한 모든 사용자는 접근이 불가같은 세부적인 컨트롤은 어렵다\r\n\r\n### 📌 Capabilities (CL)\r\n\r\n---\r\n\r\n![](./cl.png)\r\n\r\n- **주체 위주로 압축**\r\n\r\n​ 잘 사용되진않음\r\n\r\nex)\r\n\r\n> 놀이공원 티켓 : 어떤 놀이기구는 되고 어떤 앤 안됨\r\n>\r\n> android app permission : 이 앱은 어떤 리소스 접근은 되고 어떤건 안됨\r\n\r\n### 📌 Role-based Access Control (RBAC)\r\n\r\n---\r\n\r\n- 역할 기반\r\n\r\n- 주체가 어떤 역할, 직책을 가지고 있느냐가 중요\r\n\r\n- task 기반으로 자세하게 명령 가능. 세부적 컨트롤이 가능\r\n\r\n- 사용자 id 기반으로 권한을 부여한다면 본의 아니게 필요 이상 권한을 부여하게되기도하는데 역할 기반으로 권한을 줌으로써 세밀하게 task 설정 가능\r\n\r\n- 특정 작업에 대해서 권한 설정 가능\r\n\r\nex) create a credit account\r\n\r\n## User Authentication\r\n\r\n---\r\n\r\n사용자 인증\r\n\r\naccess control을 하기 위해선 누구인지 검증해야함\r\n\r\nidentification : 여러 주체들이 섞여있는 가운데서 누구인지 식별 가능\r\n\r\nAuthentication : 어떤 객체가 누구라고 주장했을 때 맞는지 확인\r\n\r\n- **유저가 알고있는 지식 기반**\r\n\r\n[비밀번호, PIN 등]\r\n\r\ndirect input vs challenge-response\r\n\r\ndirect input : 바로 입력하기\r\n\r\nchallenge-response : 질문에 답변해야 인증\r\n\r\n문제 : 패스워드 공간 문제(무작위 때려맞추기 공격 위험), 통계적인 분포, 어깨너머로 엿봄등\r\n\r\n- **유저가 지닌 물건 기반**\r\n\r\n[ID카드, security token, SIM, REID, OTP 등]\r\n\r\n문제 : 도난이나 분실 위험\r\n\r\n- **유저 자체나 행위 (생체 인증)**\r\n\r\n[지문, 얼굴, 서명 등]\r\n\r\n문제 : 프라이버시 문제, 바꾸기 어려움\r\n\r\n- **Two-factor authentication**\r\n\r\n위의 두 가지를 섞어 사용\r\n"},{"excerpt":"Divisibility b는 0이 아니다 b는 a의 divisor, a는 b의 multiple ex) 17|0, -5|30 a|1 이면 a는 ±1 a|b, b|a 이면 a = ±b 0이 아닌 모든 정수 b는 0의 약수가 된다 ( 나머지가 0이긴하니까... ) b|g and b|h 이면 b|(mg + nh) Division Algorithm 📌 Euclid…","fields":{"slug":"/number-theory/"},"frontmatter":{"date":"April 16, 2022","title":"2-2 Number Theory","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Divisibility\r\n\r\n---\r\n\r\n```\r\n`a/b` = `a=mb` = `b|a`\r\n```\r\n\r\n_b는 0이 아니다_\r\n\r\nb는 a의 divisor, a는 b의 multiple\r\n\r\nex) 17|0, -5|30\r\n\r\n- a|1 이면 a는 ±1\r\n- a|b, b|a 이면 a = ±b\r\n- 0이 아닌 모든 정수 b는 0의 약수가 된다 ( 나머지가 0이긴하니까... )\r\n- b|g and b|h 이면 b|(mg + nh)\r\n\r\n### Division Algorithm\r\n\r\n---\r\n\r\n```\r\na = qn +r 일 때\r\n 0 ≤ r < n;\r\n q = [a/n] (작거나 같은 수 중 최대)\r\n```\r\n\r\n### 📌 Euclidean Algorithm : `for GCD`\r\n\r\n---\r\n\r\nfor `GCD`\r\n\r\ngcd(a,b) -> gcd(b, a mod b)\r\n\r\na>b 일 때, r이 0이 될 때까지 반복한다\r\n\r\n![](./ec1.png)\r\n\r\n### 모듈러 연산\r\n\r\n---\r\n\r\n```\r\na = qn +r\r\n0≤ r < n\r\n```\r\n\r\n-11 mod 7 = 3\r\n\r\n-11 = 7\\*-2 +3\r\n\r\n### 📌 합동(congruent)\r\n\r\n---\r\n\r\n(a mod n) = (b mod n)\r\n\r\n-> `a ≡ b (mod n)` : 우와! 합동이다!\r\n\r\n만약 `a ≡ 0 (mod n)`이라면, n|a이다.\r\n\r\n-> a를 n으로 나눴을 때 나머지가 0이라는 뜻이므로\r\n\r\nex)\r\n\r\n> 73 ≡ 4 (mod 23)\r\n>\r\n> : 73을 23으로 나눴을 때의 나머지와 4를 23으로 나눴을 때의 나머지가 같다\r\n>\r\n> 21 ≡ -9 (mod 10)\r\n\r\n#### 📌 Properties of Congruences\r\n\r\n---\r\n\r\n1. a ≡ b (mod n) iff n|(a-b)\r\n2. a ≡ b (mod n) 이면, b ≡ a (mod n)\r\n3. a ≡ b (mod n) & b ≡ c (mod n) 이면, a ≡ c(mod n)\r\n\r\n1번 증명 : 만약 `n | (a-b)` 이면 `(a-b) = kn`\r\n\r\n-> `a = b + kn`\r\n\r\n> `(b + kn) mod n` = b mod n\r\n\r\n따라서 `a mod n` = `b mod n`, 즉 `a ≡ b(mod n)`\r\n\r\n### 📌 Modular Arithmetic\r\n\r\n---\r\n\r\n1. [(a mod n) + (b mod n)] mod n = (a + b) mod n\r\n2. [(a mod n) - (b mod n)] mod n = (a - b) mod n\r\n3. [(a mod n) * (b mod n)] mod n = (a \\* b) mod n\r\n\r\n**증명**\r\n\r\na = r1 + jn,\r\n\r\nb = r2 + kn 이라고 할 때\r\n\r\n(a+b) mod n = (r1 + jn + r2 + kn) mod n\r\n\r\n= ( r1 + r2 +(j+k)n ) mod n \\# mod n 에 의해 (j+k)n 은 0이 된다.\r\n\r\n= ( r1 + r2 ) mod n\r\n\r\n= a (mod n) + b (mod n)\r\n\r\n### 📌 Arithmetic Modulo 8\r\n\r\n---\r\n\r\n항등원 : 연산을 해도 처음 값과 똑같이 나오게 해주는 수\r\n\r\n> 덧셈의 항등원 : 0, 곱셈의 항등원 : 1\r\n\r\n📌 역원 : 연산을 했을 때 항등원이 나오게 해주는 수\r\n\r\n덧셈의 역원은 모든 수에게 있지만 곱셈의 역원은 특정한 수에게만 있다\r\n\r\n**곱셈의 역원이 존재하려면 Modulo와 서로소여야한다.**\r\n\r\n> 덧셈의 역원 : [ a + (역원) ] mod n = 0\r\n>\r\n> ex) modulo 8에서 3의 역원은 5이다 : **(3+5) mod 8 = 0**\r\n>\r\n> 곱셈의 역원 : [ a * (역원) ] mod n = 1\r\n>\r\n> ex) modulo 8 에서 5의 역원은 5이다. : **(5\\*5) mod 8 = 1**\r\n\r\n### Properties of Modular Arithmetic for Int in Zn\r\n\r\n---\r\n\r\nZ : 모든 정수의 집함\r\n\r\nZn : Z를 n으로 나눴을 때 나머지가 되는 정수들의 집합\r\n\r\n= {0, 1, 2, ... , n-1}\r\n\r\n교환 법칙, 결합 법칙, 분배 법칙, 항등원, 역원\r\n\r\n(곱셈의 역원은 있을 수도 있고 없을 수도 있으니 정의되어있지않음)\r\n\r\n### 📌 Extended Euclidean Algorithm : `for 곱셈의 역원`\r\n\r\n---\r\n\r\n```\r\nfor 곱셈의 역원\r\n```\r\n\r\n![](./eea1.png)\r\n\r\n> modulo 1759에서 550의 곱셈의 역원은 355이다\r\n>\r\n> modulo 550에서 1759의 곱셈의 역원은 439이다\r\n>\r\n> 원래 1759 \\* -111 이지만 -111은 음수이므로 -111을 mod 550해서 양수로 만든다\r\n>\r\n> -111 mod 550 = 439\r\n\r\n### 📌 Fermat's Theorem\r\n\r\n---\r\n\r\n**prime numbers**\r\n\r\n어떤 정수 a는 (n제곱 형태의 ) prime numbers들의 곱 형태들로 표현할 수 있다\r\n\r\n편의상 앞으로 prime number를 **p**로 나타내겠음\r\n\r\n![](./fc.png)\r\n\r\n- p는 prime이고 a는 p로 나눠지지않는 양의 정수일 때 :a와 p가 서로소\r\n\r\n  a mod p = 0\r\n\r\n  **a(^p-1) mod p 를 했을 때 1이 나옴**\r\n\r\n- p는 prime이고 a는 양의 정수\r\n\r\n  a(^p) ≡ a (mod p)\r\n\r\n### Euler totient function\r\n\r\n---\r\n\r\n1부터 n까지의 양수 중 n과 서로소가 되는 수들의 개수\r\n\r\n![](./euler1.png)\r\n\r\np와 q가 prime number라면 서로소가 되는 수들의 개수는 p-1, q-1이다\r\n\r\n![](./euler2.png)\r\n\r\n### Primality test\r\n\r\n---\r\n\r\nprime인지 아닌지 test\r\n\r\n![](./pt.png)\r\n\r\n#### Trial division\r\n\r\n처음부터 무식하게 다 나눠보기\r\n\r\n#### Fermat test\r\n\r\n확률적인 방법\r\n\r\n페르마의 정리 : 만약 p가 prime이고 a와 p가 서로소라면,\r\n\r\n무조건 `a(^p-1) ≡ 1 (mod p)` 이다. (a는 유클리드 알고리즘을 사용해 구한다)\r\n\r\n`a(^p-1) ≡ 1 (mod p)` 가 아니라면 p는 prime이 아니다\r\n\r\n`a(^p) ≡ a (mod p)`\r\n\r\n왜냐면 a(^p-1) 였을 때 mod p 하면 1이었으니까 ...\r\n\r\n그 1에다가 a곱하고 mod p하면 a가 나올 수 밖에 없음 (둘이 서로소니까 나눠질 가능성은 0)\r\n\r\n#### Miller-Rabin test\r\n\r\n- Fermat test (기본적으로는 페르마 테스트)\r\n- NSR (nontrivial sqare root) test (에 추가)\r\n\r\n      `x² mod n = 1` 이 참일 때 x가 1 또는 n-1이 아니라면 n은 prime이 아니다\r\n\r\n​ ex) 4² mod 15 = 1 , 그러므로 15는 prime이 아니다\r\n\r\n#### Deterministic algorithm\r\n\r\nmiller-rabin은 틀릴 확률이 조금이지만 있음. trial처럼 100%맞는 알고리즘은 없을까?\r\n\r\nAKS 알고리즘\r\n\r\ntrial보다는 빠르지만 miller-rabin보다 느림\r\n\r\n#### Hybrid\r\n\r\nex) trialdivison + MR/Fermat\r\n\r\nprime인지 test할 수 n을 루트n까지 다 하지하고 어느정도만 trial division을 수행하다가 어느정도까지 수행을 했으면 MR/Fermat로 넘어가는\r\n\r\n### 📌 Power of Integers, Modulo 19\r\n\r\n거듭 제곱\r\n\r\n![](./mod19.png)\r\n\r\n- 페르마의 정리에 의해 18제곱에서는 모두 1 `a(^p-1) ≡ 1 (mod p)`\r\n\r\n- 수마다 특정 사이클이 존재한다\r\n\r\n- 사이클 내 중복인 수는 존재하지 않는다\r\n\r\n- 18까지 사이클이 유지되는, 사이클내에 1부터 17까지 전부 있는 수들은 `generator`라고 부른다. ex) 2, 3, 10, 13, 14, 15\r\n\r\n- `generator`의 n제곱 형태인 수들은 `generator`의 사이클을 축약해서 가지고 있다\r\n\r\n- 이전 mod 결과값?에 a를 곱해서 바로 다음의 mod 결과값을 구할 수 있다.\r\n\r\n  ex) 2를 예시로 볼 때 2의 5제곱 mod 19값인 13에서 바로 2를 곱한 26을 mod 19하면 2의 6제곱 mod 19값인 7이 나온다.\r\n\r\n### 📌 Discrete log\r\n\r\n![](./dis.png)\r\n\r\nex) 2와 17과 19를 인자로 주고 (2^n) mod 19 = 17일 때, n은 몇인가? 를 구하는 것을 디스크립트 로그라고한다. : 답은 10\r\n\r\n이후 정수 소인수분해와 디스크리트 로그에 기반한 암호화가 나옴\r\n\r\n수학적으로 풀기 어렵기 때문\r\n"},{"excerpt":"OSI 보안 구조 Security attack Security mechaism Security service Threat & Attack 📌 Security attack 💥 passive attack 공격이 일어난 뒤 시스템에 변형이 일어나지않음 두 가지 타입이 존재 release of message contents traffic analysis ex) …","fields":{"slug":"/osi-structure/"},"frontmatter":{"date":"April 16, 2022","title":"1-1 OSI 보안 구조","tags":["computer protection"]},"rawMarkdownBody":"\r\n## OSI 보안 구조\r\n\r\n1. Security attack\r\n2. Security mechaism\r\n3. Security service\r\n\r\n## Threat & Attack\r\n\r\n### 📌 Security attack\r\n\r\n---\r\n\r\n#### 💥 **passive attack**\r\n\r\n> 공격이 일어난 뒤 시스템에 변형이 일어나지않음\r\n>\r\n> 두 가지 타입이 존재\r\n>\r\n> 1. release of message contents\r\n> 2. traffic analysis\r\n\r\nex) 메세지 도청, 메세지 복사\r\n\r\n- `release of message contents`\r\n\r\n  암호화로 방어\r\n\r\n- `traffic analysis` :\r\n\r\n  암호화된 패킷 자체가 유통되고있다는게 약점이 됨, 어느 시간대에 패킷이 많이 유통되는지도 힌트가 될 수 있음\r\n\r\n  Tor로 방어\r\n\r\n#### 💥 **active attack**\r\n\r\n> 시스템 자원이나 동작을 변형시킴\r\n\r\nex) 메세지 가로챔, 메세지 전송자 흉내내서 다른 메세지 전송\r\n\r\n- `Masquerade` : 다른 사람인척 (수신자인척 메세지 보냄)\r\n\r\n- `Replay` : 100원 보내는 동작이 있다면 이걸 10000번 수행\r\n\r\n- `Modification of messages` : 메시지 내용 수정\r\n\r\n- `Denial of service` : 메시지 수신 막기\r\n\r\n#### 그렇다면 active attack이 더 치명적일까?\r\n\r\n> 답은 경우에 따라 다르다!\r\n>\r\n> 패시브 어택의 경우 공격받았는지 조차 모름\r\n>\r\n> 피해를 받았음을 알면 대응이 가능할수도있음\r\n\r\n### 📌 Security service\r\n\r\n---\r\n\r\n> 1. Data Confidentiality\r\n> 2. Data Integrity\r\n> 3. Availability\r\n> 4. Authentication\r\n> 5. Nonrepudation (for accountability)\r\n> 6. Access Control\r\n\r\n#### Data Cofidentiality\r\n\r\n> 기밀성 보호에 초점\r\n\r\n패시브 어택에 대한 방어 (아무도 못 봐)\r\n\r\n트래픽 보호(어디서부터 어디로 가는지, 빈도, 패킷길이등)\r\n\r\n#### Data Integrity\r\n\r\n> 메시지가 변경되는 것에 초점\r\n\r\n단일 메세지, 메세지 스트림에 적용 가능\r\n\r\n커넥션이 없는 경우 : 단일 메세지 - 메세지 변조에 초점, 어떤 부분이 복제, 삭제, 추가 되었는가\r\n\r\n커넥션이 있는 경우 : 메세지 스트림 - reordering(메세지 순서가 바뀜)\r\n\r\n**원래의 상태가 바뀌지않는것에 중심을 둔다**\r\n\r\n#### Availability Service\r\n\r\n> 서비스 제공에 초점\r\n\r\nDOS(denial-of-service attack) 공격에 초점\r\n\r\n#### Authentication\r\n\r\n> 사용자 인증에 초점\r\n\r\n`Peer entity authentication` : 양방향 소통중 상대방이 누구인지 인증. 사용자를 인증\r\n\r\n`Data origin authentication` : 데이터가 전송될 때 그 데이터가 내가 기대하는 사람으로부터 받은게 맞는지 확인 (Masquerade등 막음:진위여부판단)\r\n\r\n#### Nonrepudiation (for accountability)\r\n\r\n> 책임 소재를 가리는 것에 초점\r\n\r\n사용자가 부인하지않게. 누군가 메세지를 보냈다면 그 사람이 보냈다는걸 확인할 수 있게\r\n\r\n#### Access Control\r\n\r\n(CIAAA 의 조건에 들어가진않지만 다섯개와 연결된 개념)\r\n\r\n커뮤니케이션 링크를 통해 호스트 시스템&app에 접근하는 것을 제어\r\n\r\n`identified` : 이 사람이 누구인지 먼저 신원 확인\r\n\r\n`authenticaticated` : 이 사람이 누구라고 주장할 때 맞는지 검증\r\n\r\n![](./core-concepts.png)\r\n\r\n **Attacks** : 보안 공격의 종류\r\n\r\n **Security Services** : 보안이 제공하는 서비스\r\n\r\n **Security Mechanisms** : 서비스 목적을 달성시키기위한 재료. 도구\r\n\r\n`Message authentication` 또는 `Digital signature`를 사용해 **Integrity**와 **Authenticity** 를 지킬 수 있다.\r\n\r\n`Digital signature`는 `Message authentication` 와 달리 **Accountablility (Nonrepudiation)**도 달성할 수 있다\r\n\r\n## Fundamental Security Design Principle\r\n\r\n---\r\n\r\n보안 디자인 설계 룰\r\n\r\n- Economy of mechanism : 작고 간단하게. 비용적&관리적측면에서 경제적으로!\r\n\r\n- Fail-safe defaults : 보안의 기본 정책은 exclusion이 아닌permission에 기본해야한다. ex) 이건 안돼(x) 이것만 허용(o)\r\n\r\n- Complete mediation : access 할 때 마다 모든 access 확인, 각각의 자원마다 체크한다.\r\n\r\n- Open design : 개방형 설계, 보안 시스템을 열고 모두가 볼 수 있게한다. 집단 지성\r\n\r\n- Separation of priviledge : 권한 세분화, 하나 뚫렸을 때 전체가 망가지지않게\r\n\r\n- Least privilege : 권한 최소화\r\n\r\n- Least common mechanism : 공유 메커니즘 최소화\r\n\r\n- Psychological acceptablility : 심리적으로 받아들일수있게 , 심리적 압박감&불편함 최소화 - 사용자 편의성 관련, 사용자에게 투명해야함. 사용자는 시큐리티 매커리즘이 있는지 모르게 해주는게 좋음\r\n\r\n- Isolation : 분리, public과 critical 분리. 중요한 시스템은 public이 접근할 수 없게 분리해야한다\r\n\r\n- Encapsulation : 캡슐화. 안의 내부적인 구성에 대해서는 알려주지않아도된다.\r\n\r\n- Modularity : 모듈별로 설계, 한 쪽의 에러가 다른 쪽에 영향을 끼치지않게\r\n\r\n- Layering : 겹치는 보호\r\n\r\n- Least astonishment : 사용자를 놀라게하면안됨. 사용자가 예상할 수 있는 범위내에서 동작해야함\r\n\r\n## Attack Surfaces\r\n\r\n---\r\n\r\n시스템이 있을 때 거기에 존재하는 취약점들을 말함\r\n\r\n공격자가 뚫고 들어갈 수 있는 표면\r\n\r\n### Attack Surface Categories\r\n\r\n---\r\n\r\n#### Network attack surface\r\n\r\n네트워크를 통해서 공격\r\n\r\n#### Software attack surface\r\n\r\n프로그래밍이 잘못되었다는 등의 이유로 소프트웨어를 통해 공격\r\n\r\n#### Human attack surface\r\n\r\n사람을 공격!\r\n\r\n중요 시스템을 다루는 사람을 공격!\r\n\r\n## Attack Tree\r\n\r\n---\r\n\r\n어떤 대상을 공격하는 체계\r\n\r\nbranching과 계층이 있다\r\n\r\n\\+ Cyber kill chain : 어택 트리와 마찬가지로 공격의 절차를 보여준다. 어택 트리가 공격의 목표에 다다르기위해 어떤 기술들을 쓸 수 있는지 트리형식으로 보여줬다면 사이버 킬 체인은 실제로 공격에 도달하기 위해 공격자가 뭐하고 뭐하고 뭐해야하는지 쭉 나열되어있음\r\n\r\n### Model for Network Security\r\n\r\n---\r\n\r\n![](./model.png)\r\n\r\n### Standards\r\n\r\n표준을 정하는 기관들\r\n\r\nNIST, ISOC, ITU-T, ISO\r\n\r\n그 외 TTA, KS, IEEE 등 더 있음\r\n"},{"excerpt":"보안이란? 자동화된 정보 시스템을 보호 정보 시스템 자원의 confidentiality, integrity, availability 보존 보안의 요구 조건 : CIA + AA 📌 기밀성 (Confidentiality)  중요한 정보가 허가받지않은 개인 주체에 의해서 공개되거나 가용될 수 없다. 허가받은 사람만 중요한 정보를 볼 수 있어야 한다    개인이…","fields":{"slug":"/cia-aa/"},"frontmatter":{"date":"April 16, 2022","title":"1-1 컴퓨터 보안의 요구 조건 (CIA + AA)","tags":["computer protection"]},"rawMarkdownBody":"\r\n**보안이란?**\r\n\r\n- 자동화된 정보 시스템을 보호\r\n\r\n- 정보 시스템 자원의 confidentiality, integrity, availability 보존\r\n\r\n## 보안의 요구 조건 : CIA + AA\r\n\r\n### 📌 기밀성 (Confidentiality)\r\n\r\n- `Data Confidentialiy`\r\n\r\n  중요한 정보가 허가받지않은 개인 주체에 의해서 공개되거나 가용될 수 없다.\r\n\r\n  허가받은 사람만 중요한 정보를 볼 수 있어야 한다\r\n\r\n- `Privacy`\r\n\r\n      개인이 자신과 관련되어 어떤 정보들이 저장되는지, 누구에게 공개될 수 있는 지 제어를 하고 영향을 미친다\r\n\r\n      정보의 주권을 자신이 가지고있다\r\n\r\n### 📌 무결성 (Integrity)\r\n\r\n- `Data Integrity`\r\n\r\n      미리 정의되거나 허가된 방법으로 integrity되어야 한다.\r\n\r\n​ 허가 받지 않은 상태로 변경이 불가하다.\r\n\r\n​ 변경이 되었을 때 바로 확인이 가능해야한다.\r\n\r\n- `System Integrity`\r\n\r\n      시스템의 허가받지않은 변경을 막을 수 있어야한다.\r\n\r\n      시스템의 허가받지않은 변경이 불가하다\r\n\r\n### 📌 가용성 (Availability)\r\n\r\n정상적인 유저에게 정상적인 서비스를 제공한다\r\n\r\n### 📌 책무성 (Accountability)\r\n\r\n어떤일이 벌어졌을 때 책임 소재를 가릴 수 있다\r\n\r\n### 📌 인증 (Authentication)\r\n\r\n누가 진짠지 아닌지 확인할 수 있다\r\n\r\n<br/>\r\n\r\n## 컴퓨터 보안의 어려움\r\n\r\n---\r\n\r\n- 항상 공격자가 유리, 잠재적 공격에 모두 반응해야함\r\n\r\n- 계속 지켜봐야함\r\n- 시큐리티 매커리즘 : 여러 알고리즘의 조합이 어려움\r\n- 보안에 대한 투자 비용 대비 효용성 떨어짐\r\n"},{"excerpt":"Background decision-making : data를 토대로 분석해 더 나은 방향 추진 buying pattenrn : 물건을 사는 패턴 분석 large-scale에서 중요한 역할 Feature of Data Mining : 미래 예측 ai가 나오면서 예측이 더 쉬워짐 visulaization : 시각화, 그래프나 도표 Approach of Da…","fields":{"slug":"/datamining/"},"frontmatter":{"date":"April 14, 2022","title":"작성중","tags":["ai","inha"]},"rawMarkdownBody":"\r\n### Background\r\n\r\n---\r\n\r\ndecision-making : data를 토대로 분석해 더 나은 방향 추진\r\n\r\nbuying pattenrn : 물건을 사는 패턴 분석\r\n\r\nlarge-scale에서 중요한 역할\r\n\r\n### Feature of Data Mining : 미래 예측\r\n\r\n---\r\n\r\nai가 나오면서 예측이 더 쉬워짐\r\n\r\nvisulaization : 시각화, 그래프나 도표\r\n\r\n### Approach of Data Mining\r\n\r\n---\r\n\r\n**Supervised data** : 많은 인풋과 그에 따른 아웃풋 제공.(많은 표본들) 이후 인풋을 보고 아웃풋 예측\r\n\r\n**Unsupervised data** :\r\n\r\nL :{b,c,e} 4개 중에 2개 서포트 (50%)\r\n\r\nL -c :=e 4개 중에 3개 (75%)\r\n"},{"excerpt":"CBV api 사용해보기2 : crud CreateView DeleteView","fields":{"slug":"/CBV-api2/"},"frontmatter":{"date":"April 13, 2022","title":"CBV api 사용해보기2 : crud","tags":["django","python"]},"rawMarkdownBody":"\r\n## CBV api 사용해보기2 : crud\r\n\r\n---\r\n\r\n#### CreateView\r\n\r\n```python\r\nclass PostCreateView(CreateView):\r\n    model = Post\r\n    form_class = PostForm\r\n\r\n    def form_valid(self, form):\r\n        self.object = form.save(commit = False)\r\n        self.object.author = self.request.user\r\n        messages.success(self.request, \"포스트 저장 완료\")\r\n        return super().form_valid(form) #CreateView함수의 form_valid()\r\n\r\npost_new = PostCreateView.as_view()\r\n```\r\n\r\n#### DeleteView\r\n\r\n```python\r\nclass PostDeleteView(LoginRequiredMixin, DeleteView):\r\n    model = POST\r\n\r\n    # 성공하면 이동할 url\r\n    #success_url = reverse('instagram:post_list')\r\n    # success_url은 프로젝트 로딩전 호출, 그러나 instagram:post_list가 적힌 프로젝트.urls는 프로젝트 로딩이 되면서 읽어오기때문에 오류가 생긴다.\r\n\r\n    # 그렇다면 어떻게 success_url을 설정할까?\r\n    # 방법1) 함수로 구현\r\n    def get_success_url(self):\r\n        return reverse(\"instagram:post_list\")\r\n    # 함수는 실제로 success_url이 필요할 때 실행된다.\r\n\r\npost_delete = PostDeleteView.as_view()\r\n```\r\n\r\n```python\r\nclass PostDeleteView(LoginRequiredMixin, DeleteView):\r\n    model = POST\r\n\r\n    # 방법1) reverse_lazy 사용\r\n\tsuccess_url = reverse_lazy('instagram:post_list')\r\n    # reverse_lazy는 실제 success_url이 필요할 때 사용한다.\r\npost_delete = PostDeleteView.as_view()\r\n```\r\n"},{"excerpt":"Messages Framework 현재 User를 위한 1회성 메시지를 담는 용도  인스턴스를 통해 메시지를 남긴다. ​ 즉, View에서만 사용 가능 메시지는 1회 노출되고 사라진다 View를 통한 템플릿 시스템을 통해 노출을 하면 템플릿 내에서 JS를 통한 노출도 가능 Message Levels를 통한 메시지 분류 파이썬 로깅 모듈의 Level을 차용…","fields":{"slug":"/messages/"},"frontmatter":{"date":"April 13, 2022","title":"Django의 Messages Framework","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n## Messages Framework\r\n\r\n---\r\n\r\n현재 User를 위한 1회성 메시지를 담는 용도\r\n\r\n- `HttpRequest` 인스턴스를 통해 메시지를 남긴다.\r\n\r\n​ 즉, View에서만 사용 가능\r\n\r\n- 메시지는 1회 노출되고 사라진다\r\n\r\n- View를 통한 템플릿 시스템을 통해 노출을 하면 템플릿 내에서 JS를 통한 노출도 가능\r\n\r\n### Message Levels를 통한 메시지 분류\r\n\r\n---\r\n\r\n파이썬 로깅 모듈의 Level을 차용\r\n\r\n레벨에 따라 로깅 여부 판단\r\n\r\n​ 혹은 템플릿에서 다른 스타일로 노출\r\n\r\n**레벨 종류**\r\n\r\n- DEBUG : 디폴트 설정으로 무시되는 레벨, 개발 관련된 메세지이며, 실서비스에서는 무시\r\n- INFO : 해당 유저에 대한 정보성 메세지\r\n- SUCCESS : 액션이 성공적으로 수행되었음을 알림.\r\n- WARNING : 실패가 아직 발생하진않았지만, 임박했다.\r\n- ERROR : 액션이 수행되지 않았거나 다른 Failure가 발생했다.\r\n\r\n### Messages 등록\r\n\r\n---\r\n\r\n\\# views.py\r\n\r\n```python\r\nfrom django.contrib import messages\r\n\r\ndef post_new(request):\r\n    ...\r\n    if form.is_valid():\r\n        post = form.save()\r\n        #messages.add_message(request, messages.SUCCESS, \"새 글이 등록되었습니다.\")\r\n        message.success(request, \"새 글이 등록되었습니다.\")\r\n        return redirect(post)\r\n```\r\n\r\n### Messages 소비\r\n\r\n---\r\n\r\n**messages context_processor를 통해 messages 목록에 접근**\r\n\r\n.tag 속성을 통해 레벨을 제공\r\n\r\n.message 속성을 통해 내용을 제공 (=str(message))\\\r\n\r\n\\# template/post_new.html\r\n\r\n```html\r\n{% if messages %}\r\n<ul class=\"messages\">\r\n  {% for message in messages %}\r\n  <li>[{{ message.tag }}] {{ message.message }}</li>\r\n  {% endfor %}\r\n</ul>\r\n{% endif %}\r\n```\r\n\r\n### Bootstrap4 스타일과 대응\r\n\r\n---\r\n\r\n![](./bs.png)\r\n\r\n부트스트랩4와 바로 대응 시키려면 **messages tag**를 변경하면된다!\r\n\r\n#### messages tags 변경하기\r\n\r\n---\r\n\r\n\\# settings.py\r\n\r\n```python\r\nfrom djangp.contrib.messages import constants as messages_constants\r\n\r\nMESSAGE_TAGS = {\r\n    messages_constants.DEBUG : 'secondary',\r\n    messages_constants.ERROR : 'danger',\r\n}\r\n```\r\n\r\n\\# html\r\n\r\n```html\r\n{% if messages %} {% for message in messages %}\r\n\r\n<div class=\"alert alert-{{ message. tag }}\">{{ message.message }}</div>\r\n\r\n{% endfor%} {% endif %}\r\n```\r\n"},{"excerpt":"HttpRequest를 받아 HttpResponse로 응답한다 HttpRequest 객체 **클라이언트로부터의 모든 요청 내용을 담고 있으며 ** 함수 기반 뷰 : 매 요청시마다 뷰 함수의 첫번째 인자 로 전달 클래스 기반 뷰 : 매 요청시마다 를 통해 접근 패킷 헤더 : get data는 헤더에만 필요한 정보가 있음. 바디 사용 x 공백 바디 : pos…","fields":{"slug":"/httprequest-httpresponse/"},"frontmatter":{"date":"April 12, 2022","title":"HTTPRequest와 HttpResponse","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n**HttpRequest를 받아 HttpResponse로 응답한다**\r\n\r\n## HttpRequest 객체\r\n\r\n---\r\n\r\n**클라이언트로부터의 모든 요청 내용을 담고 있으며 **\r\n\r\n함수 기반 뷰 : 매 요청시마다 뷰 함수의 첫번째 인자 `request`로 전달\r\n\r\n클래스 기반 뷰 : 매 요청시마다 `self.request`를 통해 접근\r\n\r\n패킷\r\n\r\n[헤더 : get data는 헤더에만 필요한 정보가 있음. 바디 사용 x]\r\n\r\n공백\r\n\r\n[바디 : post 관련 data]\r\n\r\n### Form 처리 관련 속성들\r\n\r\n---\r\n\r\nrequest. ( )\r\n\r\n.method : 요청의 종류 \"GET\" 또는 \"POST\"\r\n\r\n.GET : GET 인자 목록 (QueryDict 타입)\r\n\r\n.POST : POST 인자 목록 (QueryDict 타입)\r\n\r\n.FILES : POST 인자 중에서 파일 목록 (MultiValueDict 타입)\r\n\r\n### MultiValueDict\r\n\r\n---\r\n\r\n> dict을 상속받은 클래스\r\n>\r\n> 동일 key의 다수 value를 지원하는 사전\r\n\r\nhttp 요청에서는 하나의 key에 대해서 여러 값을 전달받을 수 있어야 함.\r\n\r\nURL의 QueryString같은 Key로서 다수 Value지정을 지원\r\n\r\nex) name=TOM&name=Steve&name=Hongo\r\n\r\n## HttpResponse\r\n\r\n---\r\n\r\n어떠한 뷰 함수에 응답 반환값은 무조건 HttpResponse임\r\n\r\n(미들웨어 이미지 캡처)\r\n\r\n## JsonResponse\r\n\r\n---\r\n\r\n`HttpResponse`를 상속받아서 사용 가능\r\n\r\n직렬화 : Json 객체를 문자열로 변환\r\n\r\n장고에는 `Django JSONEncoder`라는게 존재.\r\n\r\n파이썬의 json.JsonEncoder를 상속받아서 DJango 만의 특징에 맞게 변환\r\n\r\n## StreamingHttpResponse\r\n\r\n---\r\n\r\n효율적인 큰 응답을 위함. & 메모리를 많이 먹는 응답\r\n\r\nbut Django는 short-lived 요청에 맞게 디자인!\r\n\r\n​ 큰 응답시에는 극심한 성능 저하로 이어질 수 있음\r\n\r\n​ : 이럴 때는 별도의 웹 서버등 다른 서비스를 이용하는게 좋음\r\n\r\n## FileResponse\r\n\r\n---\r\n\r\n`StreamingHttpResponse`를 상속받음  \r\n파일 내용 응답에 최적화\r\nContent-Length, Content-Type, Content-Disposion 헤더 자동 지정  \r\nContent-Disposion : 파일 다운로드 다이로그\r\n\r\n인자인 `as_attachment`를 True로 주면 Content-Disposion 헤더 지정\r\n"},{"excerpt":"은 HTML Form Field들을 파이썬 클래스화 은 Database Field들을 파이썬 클래스화 시킨다 Form  은 과 달리 textfield가 없음 문자열은 그냥 문자열일뿐 ...  이런식으로 사용 ModelForm 을 지정하면 해당 의 field정보를 가져와서  filed를 구성해준다. 과 연결되어있기때문에 모델 세이브도 가능 Form Mode…","fields":{"slug":"/form-modelform/"},"frontmatter":{"date":"April 12, 2022","title":"Django의 Form과 ModelForm","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n`Form`은 **HTML Form Field들을 파이썬 클래스화**\r\n\r\n`Model`은 **Database Field들을 파이썬 클래스화** 시킨다\r\n\r\n## Form\r\n\r\n---\r\n\r\n`Form` 은 `Model`과 달리 textfield가 없음\r\n\r\n문자열은 그냥 문자열일뿐 ...\r\n\r\n`content = forms.CharField(widget=form.Textarea)`\r\n\r\n이런식으로 사용\r\n\r\n## ModelForm\r\n\r\n---\r\n\r\n`Model`을 지정하면 해당 `Model`의 field정보를 가져와서 `Form` filed를 구성해준다.\r\n\r\n`Model`과 연결되어있기때문에 모델 세이브도 가능\r\n\r\n#Form\r\n\r\n```python\r\nfrom django import forms\r\n\r\nclass PostForm(forms.Form):\r\n    title = forms.CharField()\r\n    content = forms.CharField(widget=form.Textarea)\r\n```\r\n\r\n#ModelForm\r\n\r\n```python\r\nfrom django import forms\r\nfrom .models import Post\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n        #fields = ['title', 'content']\r\n```\r\n\r\nform의 유효성 검사는 fields에 한해서 검사한다.\r\n\r\n#### View에서 ModelForm 활용\r\n\r\n---\r\n\r\n```python\r\ndef post_new(request):\r\n    if request.method == \"POST\":\r\n        form = PostForm(request.POST, request.FILES)\r\n        #파일은 받지않는다면 request.FILES 없어도 됨\r\n        if form.is_valid():\r\n            post = form.save() #모델폼은 바로 모델save가능\r\n            return redirect(post)\r\n    else:\r\n        form = PostForm()\r\n    return render(request, 'myapp/post_form.html', {'form' : form,})\r\n\r\n```\r\n\r\n#### Model Form save함수의 인자commit\r\n\r\n\\# ex) post 작성시 author 입력은 없애고 싶으나 author이 필수항목일 때\r\n\r\n```python\r\npost = form.save(commit = False)\r\npost.user = request.user\r\n#author입력이 안된 form이 오므로 author를 지정해주고 save\r\npost.save()\r\n```\r\n\r\n**True**가 **default**\r\n\r\n**False**로 준다면 **.save()**를 실행하지않는다.\r\n\r\n​ instance.save() 함수 호출을 지연시키고자 할 때 사용한다. (save하긴해야함)\r\n\r\n​ 모델 인스턴스는 만들어졌으나 실제 db에 모델이 생성되지않음\r\n"},{"excerpt":"필드 별로 유효성 검사 함수 추가 적용 MinLengthValidator가 이미 존재하긴함 모델단에도 설정 가능~ models.py에서 설정해 ModelForm에서 사용할수도있다 models.py forms.py 모델단에 지정한 validator를 ModelForm이 알아서 가져감 유효성 검사 호출 로직 form.is_valid() 가 호출되었을 때 1.…","fields":{"slug":"/clean-validators/"},"frontmatter":{"date":"April 12, 2022","title":"장고 폼의 유효성 검사 : clean과 validators","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### 필드 별로 유효성 검사 함수 추가 적용\r\n\r\n---\r\n\r\n```python\r\nfrom django import forms\r\n\r\ndef min_length_3_validator(value):\r\n    if len(value) < 3:\r\n        raise form.ValidationError(\"3글자 이상 입력해주세요\")\r\n\r\nclass PostForm(forms.Form):\r\n    title = forms.CharField(validators=[min_length_3_validators])\r\n```\r\n\r\n_MinLengthValidator가 이미 존재하긴함_\r\n\r\n```python\r\nfrom django.core.validators import MinLengthValidator\r\n\r\nmin_length_3_validator = MinLengthValidator(3)\r\n```\r\n\r\n#### 모델단에도 설정 가능~\r\n\r\n---\r\n\r\n**models.py에서 설정해 ModelForm에서 사용할수도있다**\r\n\r\n#models.py\r\n\r\n```python\r\nfrom django import models\r\n\r\ndef min_length_3_validator(value):\r\n    if len(value) < 3:\r\n        raise form.ValidationError(\"3글자 이상 입력해주세요\")\r\n\r\nclass Post(forms.Model):\r\n    title = models.CharField(max_length=100, validators=[min_length_3_validator])\r\n    content = models.TextField()\r\n```\r\n\r\n#forms.py\r\n\r\n```python\r\nfrom django import forms\r\nfrom .models import Post\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n        #fields = ['title', 'content']\r\n```\r\n\r\n모델단에 지정한 validator를 ModelForm이 알아서 가져감\r\n\r\n### 유효성 검사 호출 로직\r\n\r\n---\r\n\r\n**form.is_valid() 가 호출되었을 때**\r\n\r\n#### 1. form.full_clean() 호출\r\n\r\n​ **1. 각 필드 객체 별로 수행**\r\n\r\n​ 각 필드객체.clean() 호출을 통해 각 필드 Type에 맞춰 유효성 검사\r\n\r\n​ ex) email field가 email 형식인지\r\n\r\n​ `clean()`은 `is_valid()`가 호출되면 내부적으로 수행된다.\r\n\r\n​ **2. Form 객체 내에서**\r\n\r\n​ 필드 이름 별로 Formr객체.clean\\_필드명() 함수가 있다면 호출해서 유효성 검사\r\n\r\n​ Form객체.clean() 함수가 있다면 호출해서 유횽성 검사\r\n\r\n​ # ex)\r\n\r\n```python\r\nimport re\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        field = ['message', 'photo', 'tag_set']\r\n\r\n    def clean_message(self):\r\n        message = self.cleaned_data('message')\r\n        if message:\r\n            message = re.sub(r'[a-zA-z]+','',message)\r\n            #영어 제거\r\n        return message\r\n```\r\n\r\ndrf 시리얼라이저에서는 clean대신 validator\r\n\r\n### Form에서 수행하는 2가지 유효성 검사\r\n\r\n---\r\n\r\n**1. Validator 함수를 통한 유효성 검사**\r\n\r\n값이 원하는 조건에 맞지 않을 때 ValidationError 예외를 발생\r\n\r\n- 리턴 값은 사용되지 않는다\r\n- 인자 하나를 받는다\r\n\r\n**2. Form 클래스 내 clean, clean\\_멤버함수를 통한 유효성 검사 및 값 변경 **\r\n\r\n값이 원하는 조건에 맞지 않을 때 ValidationError 예외를 발생\r\n\r\n- 리턴값을 통해 값 반환\r\n\r\n### 함수형/클래스형 Validator\r\n\r\n---\r\n\r\n#### 함수형\r\n\r\n​ 유효성 검사를 수행할 값 인자를 1개 받은 Callable Object\r\n\r\n#### 클래스형\r\n\r\n​ 클래스의 인스턴스가 Callable Object : \\_\\_call\\_\\_함수 존재\r\n\r\n#### but 빌트인 Validator를 잘 사용하자!\r\n\r\n### 언제 validators를 쓰고, 언제 clean을 사용할까?\r\n\r\n---\r\n\r\n**가급적이면 모든 validators는 모델에 정의하고 ModelForm을 통해 모델의 validators 정보를 가져오기!**\r\n\r\n**clean이 필요할 때는**\r\n\r\n특정 Form에서 1회성 유효성 검사 루틴이 필요할 때\r\n\r\n다수 필드값에 걸쳐서, 유효성 검사가 필요할 때\r\n\r\n필드 값을 변경할 필요가 있을 때 (validator는 값만 체크할 뿐, 값을 변경할 수는 없음)\r\n"},{"excerpt":"플렉스는 한 방향 레이아웃 시스템 그리드는 두 방향 (가로-세로) 레이아웃 시스템  그리드는 플렉스보다 더 복잡한 레이아웃 표현이 가능하다.  이와 같은 구조를 flex로 구현하려면 매우 힘듦...s 그러나 그리드로는 간단하게 구현 가능! 그리드는 어떻게 그리죠? 컨테이너 속성으로 격자를 만들고 아이템 속성으로 격자에 끼워 넣는다 1. 컨테이너 속성으로 …","fields":{"slug":"/grid/"},"frontmatter":{"date":"April 10, 2022","title":"그리드를 어떻게 그리드라","tags":["css"]},"rawMarkdownBody":"\r\n플렉스는 한 방향 레이아웃 시스템\r\n\r\n그리드는 두 방향 (가로-세로) 레이아웃 시스템\r\n\r\n![](./flex-grid.png)\r\n\r\n그리드는 플렉스보다 더 복잡한 레이아웃 표현이 가능하다.\r\n\r\n![](./grid-ex1.png)\r\n\r\n이와 같은 구조를 flex로 구현하려면 매우 힘듦...s\r\n\r\n그러나 그리드로는 간단하게 구현 가능!\r\n\r\n### 그리드는 어떻게 그리죠?\r\n\r\n1. 컨테이너 속성으로 격자를 만들고\r\n2. 아이템 속성으로 격자에 끼워 넣는다\r\n\r\n#### 1. 컨테이너 속성으로 격자 만들기\r\n\r\n```css\r\n.container {\r\n  display: grid;\r\n  grid-template-columns: 300px 300px 300px 300px;\r\n  grid-template-rows: 200px 200px 200px 200px;\r\n}\r\n```\r\n\r\n`grid-template-columns` : 격자의 세로가 몇 개이고 각 격자칸의 크기가 얼마난지 정한다. 위 예시의 경우 세로 4칸이 있고 각 칸은 모두 300px크기이다.\r\n\r\n`grid-template-rows` : 격자의 가로가 몇 개이고 각 격자칸의 크기가 얼마난지 정한다.\r\n\r\n#### fr과 %\r\n\r\n`px`외에도 `fr`, `%`, `em` 등으로 표현할 수 있다.\r\n\r\n`fr` : `%`, `px`등으로 공간이 채워지고 남은 공간을 기준으로 할당한다\r\n\r\n​ 300px 1fr 2fr 이라면 300px만큼 할당하고 남은 공간을 3으로 나눠 1/3과 2/3만큼 나눠 가진다.\r\n\r\n`%`: 남은 공간을 신경쓰지않고 전체 공간을 기준으로 할당한다.\r\n\r\n#### repeat\r\n\r\n`repeat ` 함수를 사용해서 반복적으로 공간을 할당할 수 있다.\r\n\r\n```css\r\n.container{\r\n    display: grid;\r\n    grid-template-columns: repeat(4, 300px)\r\n    grid-template-rows: repeat(4, 200px)\r\n}\r\n```\r\n\r\n#### 2. 아이템 끼워 넣기\r\n\r\n![](./grid-item.png)\r\n\r\n`grid-column` 을 통해 해당 아이템이 차지할 세로 격자칸을 정할 수 있다\r\n\r\n`grid-row` 를 통해 해당 아이템이 차지할 가로 격자칸을 정할 수 있다\r\n\r\n`grid-area`를 사용해 `grid-column` 과 `grid-row`를 동시에 선언할 수 있다.\r\n\r\ngrid-area: r-start / c-start / r-end / c-end\r\n\r\n그러나 나는 나눠서 표현하는게 편함\r\n\r\n반대로 grid-column과 grid-row를 grid-row-start, grid-row-end이런식으로 나눠서 쓸 수 있다.\r\n\r\n#### span\r\n\r\n얼만큼 늘린건지도 쓸 수 있다\r\n\r\n`grid-column : 1/span3;`\r\n\r\n1에서 3개 공간만큼 늘린다는 뜻\r\n\r\n참고 (https://studiomeal.com/archives/533)\r\n"},{"excerpt":"python manage.py shell등을 사용해서 뻥튀기할 모델의 인스턴스를 아무거나 가져온 후  가져온 인스턴스의 pk를 None으로 만든다  그리고 인스턴스를 save 한다면?  짜잔~ 가져온 인스턴스와 내용이 똑같지만 pk는 다른 모델이 생성됩니다~ 물론 for문을 사용해서 한 번에 만들수도있음.","fields":{"slug":"/instance-flex/"},"frontmatter":{"date":"April 10, 2022","title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때","tags":["django"]},"rawMarkdownBody":"\r\npython manage.py shell등을 사용해서\r\n\r\n1. 뻥튀기할 모델의 인스턴스를 아무거나 가져온 후  \r\n   `post = Post.objects.first()`\r\n\r\n2. 가져온 인스턴스의 pk를 None으로 만든다  \r\n   `post.pk = None`\r\n\r\n3. 그리고 인스턴스를 save 한다면?  \r\n   `post.save()`\r\n\r\n짜잔~ 가져온 인스턴스와 내용이 똑같지만 pk는 다른 모델이 생성됩니다~\r\n\r\n물론 for문을 사용해서 한 번에 만들수도있음.\r\n\r\n```python\r\npost_list = list(Post.objects.all())\r\nfor i in range(100):\r\n    post = random.choice(post_list)\r\n    post.pk = None\r\n    post.save()\r\n```\r\n"},{"excerpt":"1. values_list 필드값을 인자로 넣어 생성된 모델 인스턴스들의 해당 필드값을 나열한다.   원래 튜플 형태로 출력되는데 flat = True 를 사용해서 튜플을 없앨 수 있다.  2. _ 이전 출력 결과를 다음 줄에서 _를 사용해 표현할 수 있다.","fields":{"slug":"/queryset/"},"frontmatter":{"date":"April 10, 2022","title":"작성중 : 쓸만해보이는 쿼리셋팁","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### 1. values_list\r\n\r\n필드값을 인자로 넣어 생성된 모델 인스턴스들의 해당 필드값을 나열한다.\r\n\r\n`Post.objects.all().values_list('created_at__year')`\r\n\r\n`Post.objects.all().values_list('created_at__year', flat = True)`\r\n\r\n원래 튜플 형태로 출력되는데 **flat = True** 를 사용해서 튜플을 없앨 수 있다.\r\n\r\n####\r\n\r\n### 2. \\_\r\n\r\n이전 출력 결과를 다음 줄에서 \\_를 사용해 표현할 수 있다.\r\n"},{"excerpt":"HTTP 상태코드 웹서버는 적절한 상태코드로서 응당해야한다 각 HttpResponse 클래스마다 고유한 status_code가 할당 REST API를 만들 때 유용 # response.py HTTP METHOD별 다양한 상태 코드 GET 일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답 POST 201(Created)…","fields":{"slug":"/http-status-code/"},"frontmatter":{"date":"April 10, 2022","title":"HTTP 상태 코드","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### HTTP 상태코드\r\n\r\n---\r\n\r\n웹서버는 적절한 상태코드로서 응당해야한다\r\n\r\n각 HttpResponse 클래스마다 고유한 status_code가 할당\r\n\r\nREST API를 만들 때 유용\r\n\r\n\\# response.py\r\n\r\n```python\r\nfrom django.http import HttpResponse\r\n\r\ndef test_view(request):\r\n    return HttpResponse(status = 201)\r\n```\r\n\r\n```python\r\nclass HttpResponseRedirect(HttpResponseRedirectBase): #HttpResponse를 상속받은 클래스\r\n    status_code = 302\r\n```\r\n\r\n### HTTP METHOD별 다양한 상태 코드\r\n\r\n---\r\n\r\n#### GET\r\n\r\n일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답\r\n\r\n#### POST\r\n\r\n201(Created) 응답. 새 리소스의 URI는 응답의 로케이션 헤더에\r\n\r\n새 리소스를 만들지 않은 경우, 200응답하고 리소스와 관련된 내용을 응답 본문에 포함. 반환할 결과가 없으면 204(내용없음)을 반환할 수도\r\n\r\n400(잘못된 요청)\r\n\r\n#### PUT\r\n\r\n성공- 200(OK) 204(내용없음)\r\n\r\n실패 - 409(충돌)\r\n\r\n#### DELETE\r\n\r\n성공시 204, 리소스가 없으면 404\r\n\r\n#### 비동기작업\r\n\r\n202(수락됨) - 요청은 수락되었지만 아직 완료되지않음\r\n\r\n비동기 요청의 상태를 반환하는 URI를 로케이션 헤더로 변환\r\n\r\n로케이션 헤더를 통해 비동기작업의 진행상황을 알 수 있음\r\n"},{"excerpt":"getabsoluteurl {% raw %}\n 식으로 사용하던 것을  , 와 같이 사용 가능 모델 클래스에 을 구현한다.\n{% endraw %} 장고 템플릿 태그 주석 : {# #}","fields":{"slug":"/get-absolute-url/"},"frontmatter":{"date":"April 10, 2022","title":"detail url을 간단하게 하고싶다면, get_absolute_url","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n#### get_absolute_url\r\n\r\n---\r\n\r\n{% raw %}\r\n`{% url 'blog:post_detail' post.pk %}` 식으로 사용하던 것을\r\n\r\n`redirect(post)` , `{{ post.get_absolute_url }}`와 같이 사용 가능\r\n\r\n모델 클래스에 `get_absolute_url()`을 구현한다.\r\n{% endraw %}\r\n\r\n```python\r\nfrom django.urls import reverse\r\n\r\nclass Post(models.Model):\r\n    ...\r\n    def get_absolute_url(self):\r\n        return reverse('blog:post_detail', args=[self.pk])\r\n```\r\n\r\n장고 템플릿 태그 주석 : {# #}\r\n"},{"excerpt":"view는 무조건 HttpResponse객체를 반환해야한다. CBV Class Based View : View 함수를 만들어주는 클래스  클래스 함수를 통해, View 함수를 생성 상속을 통해 여러 기능들을 믹스인 CBV API Base views , ,  Generic display views ​ , , Generic date views Generic …","fields":{"slug":"/CBV-api/"},"frontmatter":{"date":"April 10, 2022","title":"CBV api 사용해보기","tags":["django","python"]},"rawMarkdownBody":"\r\nview는 무조건 HttpResponse객체를 반환해야한다.\r\n\r\n### CBV\r\n\r\n---\r\n\r\n**Class Based View** : View 함수를 만들어주는 클래스\r\n\r\n- `as_view()` 클래스 함수를 통해, View 함수를 생성\r\n\r\n- 상속을 통해 여러 기능들을 믹스인\r\n\r\n#### CBV API\r\n\r\n---\r\n\r\n- **Base views**\r\n\r\n  `View`, `TemplateView`, `RedirectView`\r\n\r\n- **Generic display views**\r\n\r\n​ `DetailView`, `ListView`,\r\n\r\n- **Generic date views**\r\n\r\n- **Generic editing views**\r\n\r\n  `FormView`, `CreateView`, `UpdateView`, `DeleteView`\r\n\r\n### CBV api 활용 예시(Generic display views)\r\n\r\n---\r\n\r\n```python\r\nclass DetailView:\r\n    def __init__(self, model):\r\n        self.model = model\r\n\r\n    def get_object(self, *args, **kwargs):\r\n        return get_object_or_404(self.model, id = kwargs['id']) #get_object_or_404를 통해 detail을 보고자하는 모델 인스턴스를 찾아 반환한다.\r\n\r\n    def get_template_name(self):\r\n        return '{}/{}_detail.html'.format(\r\n        \tself.model._meta.app_label, #앱이름\r\n            self.model._meta.model_name #모델명\r\n        )\r\n        #ex) instagram앱의 post모델을 가져올경우instagram/post_detail.html 을 반환해준다\r\n\r\n    def dispatch(self, request, *args, **kwargs):\r\n        object = self.get_object(*args, **kwargs)\r\n        return render(request, self.get_template_name(),{\r\n            self.model._meta.model_name: object,\r\n        })# post: 찾고자하는 post객체\r\n\r\n    @classmethod\r\n    def as_view(cls, model):#cls 는 알아서 들어옴\r\n        def view(request, *args, **kwargs):\r\n            self = cls(model)\r\n            return self.dispatch(request, *args, **kwargs)\r\n        return view\r\n```\r\n\r\n#### 1. SingleObjectMixin 클래스의 필드\r\n\r\n**SingleObjectMixin** : 제네릭뷰의 리스트뷰나 디테일뷰에 상속되는 클래스\r\n\r\n`model` : 어떤 모델 객체를 사용할 것 인지. 모델 객체를 통해 해당 모델이 소속된 앱이름도 알 수 있다. 나중에 app/model_detail.html등 template를 자동으로 불러오는데 사용된다.\r\n\r\n`queryset ` : 어떤 쿼리셋을 적용할 것인지. 리스트 해줄 모델 인스턴스들을 정할 수 있다.\r\n\r\n​ 쿼리셋이 없다면 default로 입력된 model명을 사용해서 `model.objects.all()`을 가져온다.\r\n\r\n​ 해당 클래스의 함수를 보면 `self.model._default_manager.all()`이라 되어있는데 `_default_manager`이 `objects`이다.\r\n\r\n물론 쿼리셋을 바꿀수도있다. ex) `queryset = Post.objects.filter(is_public = True)`\r\n\r\n```python\r\nclass PostDetailView(DetailView):\r\n    model = Post\r\n\r\n    def get_queryset(self): #DetailView에 있는 get_queryset함수를 오버라이딩한다.\r\n        qs = super().get_queryset() #defual qs 오버라이딩\r\n        if not self.request.user.is_authenticated:\r\n\t        qs = qs.filter(is_public=True)\r\n        return qs\r\n```\r\n\r\n`pk_url_kwarg` : default값은 pk\r\n\r\n​ url에서 `<int:id>` 형태로 받는 인자를 나타낸다. 예시와 같이 id의 경우 `pk_url_kwarg = 'id' `로 바꿔준다.\r\n\r\n`context_object_name` : render등으로 {'post' : post} 식으로 넘겨줄때 key이름을 정함. default로 `모델명`과 `'object'` 사용 가능\r\n\r\n#### 2. ListView\r\n\r\n---\r\n\r\n1개의 모델에 대한 List 템플릿 처리  \r\n모델명소문자\\_list 이름의 쿼리셋을 템플릿에 전달(object_list도 같이 전달해준다)  \r\n페이징 처리 지원 가능\r\n\r\n페이징 예시\r\n\r\n```python\r\nListView.as_view(model=Post, paginate_by = 10)\r\n```\r\n\r\n필드인 `page_obj`를 통해 현재 페이지를 확인할 수 있다\r\n`<Page 3 of 11>` 로 표기됨\r\n\r\ndjango-bootstrap4를 설치해서 꾸미기가능\r\n\r\n```html\r\n{% load bootstrap4%} {% bootstrap_pagination page_obj size = \"small\"\r\njustify_content = \"center\" %}\r\n```\r\n\r\n_view.py_\r\n\r\n```python\r\nfrom django.view.generic import ListView\r\nfrom shop.models import Item\r\n\r\nitem_list = ListView.as_view(model=Item)\r\n```\r\n\r\n_urls.py_\r\n\r\n```python\r\nfrom django.urls import path\r\n\r\nurlpatterns = [\r\n    path('items/', item_list, name='item_list'),\r\n]\r\n```\r\n\r\n단순 리스트 기능만 제공. 검색 기능등 다른 기능은 직접 추가해야함\r\n\r\n#### 3. DetailView\r\n\r\n---\r\n\r\nviews.py\r\n\r\n```py\r\nfrom django.views.generic import DetailView\r\n\r\npost_detail = DetailView.as_view(model = Post, pk_url_kwarg = 'id')\r\n\r\n#pk_url_kwarg는 urls.py에서 적은 url에 들어갈 인자이다.\r\n#만약 urls.py에 path('post/<int:pk>/',post_detail)\r\n#이라고 적었다면 pk_url_kwarg는 생략 가능하다\r\n#post_detail = DetailView.as_view(model = Post)\r\n```\r\n\r\nurls.py\r\n\r\n```python\r\nurlpatterns = [\r\n    path('post/<int:id>/', post_detail)\r\n]\r\n\r\n```\r\n\r\n상속을 통한 CBV 속성정리\r\n\r\n```python\r\nclass PostDetailView(DetailView):\r\n    model = Post\r\n    pk_url_kwarg = 'id'\r\n\r\npost_detail = PostDetailView.as_view()\r\n```\r\n\r\n#### 4. RedirectView\r\n\r\n---\r\n\r\n```python\r\nurlpatterns = [\r\n    path('', RedirectView.as_view(url = '/instagram/'))\r\n]\r\n# url 주소가 서버/instagram/인 곳으로 리다이렉트해줌\r\n\r\nurlpatterns = [\r\n    path('', RedirectView.as_view(pattern_name='instagram:post_list'))\r\n]\r\n\r\n# url path를 적을 때 설정한 name을 사용해서 이동시킴 앱:name\r\n```\r\n"},{"excerpt":"장식자(Decorators) 어떤 함수를 감싸는 (Wrapping) 함수 django.contrib.auth.decorators  : 로그아웃일 때 login_url로 redirect ex 1) ex 2)  : 지정 함수가 False를 반환하면 login_url로 redirect  : 지정 퍼미션이 없을 때 login_url로 redirect django…","fields":{"slug":"/view-decorators/"},"frontmatter":{"date":"April 10, 2022","title":"decorator를 사용해서 Django view 꾸며보기","tags":["django","python"]},"rawMarkdownBody":"\r\n### 장식자(Decorators)\r\n\r\n---\r\n\r\n어떤 함수를 감싸는 (Wrapping) 함수\r\n\r\n#### django.contrib.auth.decorators\r\n\r\n---\r\n\r\n`login_required ` : 로그아웃일 때 login_url로 redirect\r\n\r\nex 1)\r\n\r\n```python\r\nfrom django.contrib.auth.decorators import login_required\r\n\r\n@login_required\r\ndef protected_view(request):\r\n    return render(request, 'myapp/secret.html')\r\n```\r\n\r\nex 2)\r\n\r\n```python\r\nfrom django.contrib.auth.decorators import login_required\r\n\r\ndef protected_view(request):\r\n    return render(request, 'myapp/secret.html')\r\n\r\nprotected_view = loginrequired(protected_view)\r\n```\r\n\r\n`user_passes_test` : 지정 함수가 False를 반환하면 login_url로 redirect\r\n\r\n`permission_required` : 지정 퍼미션이 없을 때 login_url로 redirect\r\n\r\n#### django.views.decorator.http\r\n\r\n---\r\n\r\n`required_http_methods` : 데코레이터에 인자로 넣어준 메소드만 사용가능함\r\n\r\n`required_GET`\r\n\r\n`required_POST`\r\n\r\n`require_safe` : HEAD 요청이나 GET요청 허용\r\n\r\n### @method_decorator()\r\n\r\n---\r\n\r\n`@method_decorator()`를 통해 특정 메소드에만 데코레이터를 지정할 수 있다.\r\n\r\nex) `@method_decorator(login_required, name ='dispatch')`\r\n\r\n해당 함수 바로 위에 쓴다면 name인자 생략 가능\r\n\r\n근데 번거로운 방법이라 잘 사용안하는듯?\r\n\r\n```python\r\nclass PostListView(LoginRequiredMixin, ListView):\r\n    ...\r\n```\r\n\r\n이런 방법도 있음\r\n"},{"excerpt":"JSON 응답뷰 만들기 router를 사용해 두 개의 url생성 urls.py +HTTPie  JSON 직렬화 모든 프로그래밍 언어의 통신에서 데이터는 필히 문자열로 표현되어야함. 송신자 : 객체를 문자열로 반환하여 데이터 전송 - 직렬화 수신자: 수신한 문자열을 다시 객체로 변환하여 활용 - 비직렬화 쿼리셋타입의 객체 를 json으로 직렬화한다면? 에러…","fields":{"slug":"/json/"},"frontmatter":{"date":"April 07, 2022","title":"작성중 : json 응답뷰 만들기","tags":["django","DRF"]},"rawMarkdownBody":"\r\n### JSON 응답뷰 만들기\r\n\r\n---\r\n\r\n```python\r\nclass PostViewSet(ModelViewSet):\r\n    queryset = Post.objects.all() # 다룰 데이터의 범위\r\n    serializer_class = PostSerializer\r\n```\r\n\r\nrouter를 사용해 두 개의 url생성\r\n\r\n> urls.py\r\n\r\n```python\r\nfrom rest_framework.routers import DefaultRouter\r\nfrom . import views\r\n\r\nrouter = DefaultRouter()\r\nrouter.register('post', views.PostViewSet) #2개의 URL을 만들어줌\r\n#router.urls에 리스트 형태로 2개의 패턴이 생김 url pattern list\r\n\r\nurlpatterns = [\r\n    path('', include(router.urls)),\r\n]\r\n```\r\n\r\n+HTTPie\r\n\r\n`pip install httpie`\r\n\r\n### JSON 직렬화\r\n\r\n---\r\n\r\n모든 프로그래밍 언어의 통신에서 데이터는 필히 문자열로 표현되어야함.\r\n\r\n송신자 : 객체를 문자열로 반환하여 데이터 전송 - 직렬화\r\n\r\n수신자: 수신한 문자열을 다시 객체로 변환하여 활용 - 비직렬화\r\n\r\n쿼리셋타입의 객체 를 json으로 직렬화한다면?\r\n\r\n에러 - 룰추가 필요\r\n\r\nlist/dick/set comprehension\r\n\r\n1. 직접 변환\r\n\r\n```python\r\ndata =[\r\n    {'id':post.id, 'title':post.title, 'content':post.content}\r\n    for post in Post.objects.all()\r\n]\r\n\r\njson.dumps(data, ensure_ascii=False)\r\n```\r\n\r\n번거로움\r\n\r\n2. 직접변환 룰 지정\r\n"},{"excerpt":"큐마다 다른 폴리시 - 멀티레벨 큐 어떤 프로세스가 cpu바운드인지 io바운드인지 알 수 있? 그냥 프로세스만 받아서는 알기 어려움 멀티레벨큐 : 사용어렵 잘 설계해야함 멀티레벨 피드백 큐 여러 개의 큐를 두고 각각의 큐에 대해서 서로 다른 스케줄링 알고리즘을 가져감 프로세스가 여러가지 큐를 옮겨 다닐 수 있음 어떻게 옮겨가는가? 사용자가 결정해야함 피드…","fields":{"slug":"/6-2/"},"frontmatter":{"date":"April 06, 2022","title":"os 6-2","tags":["OS"]},"rawMarkdownBody":"\r\n큐마다 다른 폴리시 - 멀티레벨 큐\r\n\r\n\r\n\r\n어떤 프로세스가 cpu바운드인지 io바운드인지 알 수 있?\r\n\r\n그냥 프로세스만 받아서는 알기 어려움\r\n\r\n\r\n\r\n멀티레벨큐 : 사용어렵 잘 설계해야함\r\n\r\n## 멀티레벨 피드백 큐\r\n\r\n여러 개의 큐를 두고 각각의 큐에 대해서 서로 다른 스케줄링 알고리즘을 가져감\r\n\r\n프로세스가 여러가지 큐를 옮겨 다닐 수 있음\r\n\r\n\r\n\r\n어떻게 옮겨가는가? 사용자가 결정해야함\r\n\r\n피드백 방법에 근거해서 결정함. 이전 스케줄링의 결과가 다음 큐를 결정한다\r\n\r\n* 한 프로세스가 특정 큐에 종속되는게아니라 계속 옮겨다닐 수 있음\r\n\r\nex) 네개큐. 라운드로빈. 타임퀀텀만 다르게가져감\r\n\r\n타임퀀텀이 짧은건 I/O 바운드 어플리케이션에게 유리함. 긴건 cpu 바운드\r\n\r\n- 처음에는 다 Q0으로 들어감(프로세스가 어떤 애인지 모름)\r\n\r\n- 만약 프로세스가 주어진 타임 퀀텀(타임 슬라이스)을 다 쓴다면 프라이어리티를 하나 낮춘다 : 타임퀀텀이 부족해서 끝남 -> Q1으로 내려줌.\r\n- 블로킹되어서 끝났다면. 아이오요청을하면서 기다려야해서 waiting queue로 내려옴. 반대로 increase. 프라이어리티를 높인다(아이오바운드일 확률)\r\n\r\n동일한 나이스 밸류를 가지면(동일한 타임퀀텀)\r\n\r\n\r\n\r\n##  Linux Scheduling\r\n\r\n### Completely Fair Scheduler (CFS)\r\n\r\n큐레벨 말고도 스케줄링 클래스라는게 존재\r\n\r\n#### Scheduling classes\r\n\r\n두 개의 클래스가 존재\r\n\r\n* default\r\n* real-time : 주어진 시간내에 반드시 그 일을 끝내야하는\r\n\r\nreal-time이 default보다 큰 우선순위를 갖는다\r\n\r\n**quantum based(고정된 시간)가 아닌 proportion(각각의 프로세스에게 전체시간중에 얼만큼을 할당해줄지. 비율을 어떻게 할당해줄지)**\r\n\r\n*  Variable quantum size\r\n\r\n\r\n\r\n#### nice value\r\n\r\ndefault class에서 -20 + 19\r\n\r\n낮은 숫자가 높은 우선순위\r\n\r\n> -20은 시스템 앱처럼 굉장히 중요한 애들이 가져가고\r\n>\r\n> 19는 cpu bound인 애들 등이 가져간다\r\n\r\n\r\n\r\n#### virtul run time (상대적인 실행 시간)\r\n\r\n* 시스템은 가장 낮은 virtual run time을 선택\r\n\r\n> 동일한 nice value를 가지는 두 개의 프로세스 존재(p1, p2)\r\n>\r\n> nice value가 같으면 할당받을 수 있는 time quantum도 동일(20ms라고 가정)\r\n>\r\n> p1 (20) - p2 (20) - p1(20)\r\n>\r\n> 현재 p1(40), p2(20)만큼 돌았음\r\n>\r\n> 이 때 둘의 nice value가 같기 때문에 p2선택\r\n\r\n​\t\t\r\n\r\n| nice value | 우선순위 | weight |    할당된 시간     | scale factor |  virtul run time   |\r\n| :--------: | :------: | :----: | :----------------: | :----------: | :----------------: |\r\n|     0      |   높음   |   3    | 45(더 많이 돌게함) |      1       | 40(더 작은걸 실행) |\r\n|     5      |   낮음   |   1    |         15         |      3       |         60         |\r\n\r\n오래 수행되는 애들은(ex. cpu bound) virtul run time을 증가시켜서 선택 가능성을 감소시킨다\r\n\r\nfor starv방지. 공평한 스케줄링\r\n\r\n\r\n\r\n> 서로 다른 nice value를 가지는 두 개의 프로세스 존재\r\n>\r\n> p1 weight : p2 weight = 3:1\r\n>\r\n> time quantum은 동일 (nice value가 달라도 time quantum은 같을 수 있다)\r\n>\r\n> p1 (20) - p2 (20) - p1(20)\r\n>\r\n> * 총 60의 시간 중 weight에 의해 계산된 적정 cpu time 비율 (p1-45, p2-15)\r\n> * 실제 차지한 cpu time ( p1(40), p2(20) )\r\n>\r\n> \r\n>\r\n> scale factor (weight의 역수) : **priority가 높으면 scale factor도 높여줌**\r\n>\r\n> p1 scale factor = 1\r\n>\r\n> p2 scale factor = 3\r\n>\r\n> virtual runtime = 실제 cpu time x scalefactor\r\n>\r\n> p1의 virtual runtime은 40 * 1 = 40\r\n>\r\n> p2의 virtual runtime은 20 * 3 = 60\r\n>\r\n> virtual runtime이 적은 p1을 고른다\r\n\r\n\r\n\r\n* default의 nice value는 (-20~19)\r\n* real-time 까지 합쳐서 보면 -20 = 100, 19 = 139\r\n"},{"excerpt":"Django admin admin 등록 방법 (1) 기본 ModelAdmin으로 동작 admin 등록 방법 (2) 지정한 ModelAdmin으로 동작 admin 등록 방법 (3) python wrapping 파이썬의 장식자 문법 감싼 대상의 기능을 변경할 수 있다. admin에서 표기되는 모델 객체명 바꾸기 admin에서 모델 객체의 이름은 모델명 obj…","fields":{"slug":"/django-admin/"},"frontmatter":{"date":"April 05, 2022","title":"django ORM","tags":["django"]},"rawMarkdownBody":"\r\n## Django admin\r\n\r\n---\r\n\r\n#### admin 등록 방법 (1)\r\n\r\n---\r\n\r\n```python\r\nadmin.site.register(모델명)\r\n```\r\n\r\n기본 ModelAdmin으로 동작\r\n\r\n#### admin 등록 방법 (2)\r\n\r\n---\r\n\r\n```py\r\nclass ModelAdmin(admin.ModelAdmin):\r\n    pass\r\n\r\nadmin.site.register(모델명, ModelAdmin)\r\n```\r\n\r\n지정한 ModelAdmin으로 동작\r\n\r\n#### admin 등록 방법 (3)\r\n\r\n---\r\n\r\n```py\r\n@admin.register(모델명)\r\n\r\nclass ModelAdmin(admin.ModelAdmin):\r\n    pass\r\n```\r\n\r\n**python wrapping**\r\n\r\n파이썬의 장식자 문법\r\n\r\n감싼 대상의 기능을 변경할 수 있다.\r\n\r\n### admin에서 표기되는 모델 객체명 바꾸기\r\n\r\n---\r\n\r\n**admin**에서 모델 객체의 이름은 **모델명 object (n)**의 형식으로 나온다.\r\n\r\nex) Post object (1)\r\n\r\n이 이름을 바꾸고 싶다면 model선언에서` def __str__(Self):`를 사용한다.\r\n\r\n##### `def __str__(Self):`\r\n\r\n어떤 객체에 대한 문자열 표현을 할 수 있다.\r\n\r\nex)\r\n\r\n```py\r\nclass Post(models.Model):\r\n    message = models.TextField()\r\n    created_at = models.DateTimeField(auto_now_add=True)\r\n    updated_at = models.DateTimeField(auto_now=True)\r\n\r\n    def __str__(self):\r\n        return f\"({self.id})번째 포스트\"\r\n    \t#return \"({})번째 포스트\".format(self.id)\r\n        #return self.message\r\n```\r\n\r\n### list_display 속성 정의\r\n\r\n---\r\n\r\nadmin 테이블에서` list_display`에서 적은 속성명을 표기할 수 있다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message']\r\n```\r\n\r\n#### 1) 모델 필드 외 속성 추가하기\r\n\r\n꼭 모델 필드가 아니더라도 list_display에 추가할 수 있다.\r\n\r\n> Post의 메세지 길이도 list_play속성에 넣고싶다면?\r\n\r\n```python\r\nclass Post(models.Model):\r\n    message = models.TextField()\r\n    created_at = models.DateTimeField(auto_now_add=True)\r\n    updated_at = models.DateTimeField(auto_now=True)\r\n\r\n    def __str__(self):\r\n        return f\"({self.id})번째 포스트\"\r\n    \t#return \"({})번째 포스트\".format(self.id)\r\n    \t#return self.message\r\n\r\n    def message_length(self):\r\n    \treturn len(self.message)\r\n```\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n```\r\n\r\n만약 `message_length`가 자주 쓰이는 로직이라면 모델단에 정의하는게 좋으나 어드민에서만 사용한다면 어드민에서 정의해도 상관없다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n\r\n  def message_length(self, post): #post객체는 admin이 알아서 넘겨줌\r\n        return f\"{len(post.message)} 글자\"\r\n```\r\n\r\n#### 2) list_display_link\r\n\r\n해당 list_display 필드를 누르면 model 객체 상세로 이동한다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n```\r\n\r\n#### 3) search_fields\r\n\r\nadmin 테이블에서 검색 가능\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n  search_fields = ['message']\r\n```\r\n\r\n#### 4) list_filter\r\n\r\nadmin 메인에서 필터 기능 제공\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n  search_fields = ['message']\r\n  list_filter - ['created_at']\r\n```\r\n"},{"excerpt":"1. Static과 Media란? - Static 파일 ​ 개발 리소스로서의 정적인 파일(css, js, image등) ​ 앱/프로젝트 단위로 저장&서빙 - Media 파일 ​ FileField/ImageField를 통해 저장한 모든 파일 ​ DB필드에는 저장 경로를 저장하며 파일은 파일 스토리지에 저장 ​ 프로젝트 단위로 저장&서빙 static 파일은 …","fields":{"slug":"/static-media/"},"frontmatter":{"date":"April 05, 2022","title":"django의 Static & Media 파일","tags":["django"]},"rawMarkdownBody":"\r\n### 1. Static과 Media란?\r\n\r\n---\r\n\r\n#### - Static 파일\r\n\r\n​ 개발 리소스로서의 정적인 파일(css, js, image등)\r\n\r\n​ 앱/프로젝트 단위로 저장&서빙\r\n\r\n#### - Media 파일\r\n\r\n​ FileField/ImageField를 통해 저장한 모든 파일\r\n\r\n​ DB필드에는 저장 경로를 저장하며 파일은 파일 스토리지에 저장\r\n\r\n​ 프로젝트 단위로 저장&서빙\r\n\r\n> static 파일은 배포 전 개발에 필요한 정적 파일들이고 Media 파일은 배포 후 사용자가 웹에 저장한 파일들이다 아마도\r\n\r\n`pip install pillow` : 이미지 라이브러리\r\n\r\n이미지 필드를 사용하려면 `pillow`를 다운로드해야함\r\n\r\n```python\r\nclass Post(models.Model):\r\n    image = models.ImageField()\r\n```\r\n\r\n### 2. Media 파일 처리 순서\r\n\r\n---\r\n\r\n1. HttpRequest.FILES를 통해 파일이 전달\r\n\r\n2. 뷰 로직이나 폼 로직을 통해, 유효성 검증 수행\r\n\r\n3. FileField/ImageField 필드에 \"경로(문자열)\"를 저장\r\n\r\n4. settings.MEDIA_ROOT 경로에 파일이 저장됨\r\n\r\n### 3. Media 파일을 위한 settings\r\n\r\n---\r\n\r\n##### `MEDIA_URL`\r\n\r\n각 media 파일에 대한 URL Prefix\r\n\r\n필드명.url 속성에 의해서 참조되는 설정\r\n\r\n##### `MEDIA_ROOT `\r\n\r\n파일 필드를 통한 저장시에 실제 파일을 저장할 ROOT 경로\r\n\r\n```python\r\nMEDIA_URL = \"/media/\"\r\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\r\n```\r\n\r\n+`BASE_DIR` ?\r\n\r\n`seetings.py`에 선언되어있음.\r\n\r\n`BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))`\r\n\r\n현재 파일(settings.py)의 절대경로의 부모의 부모 : 워킹디렉토리, 장고 프로젝트의 루트를 가리킴\r\n\r\n`MEDIA_ROOT = os.path.join(BASE_DIR, '..', 'public', 'media')`\r\n\r\n이렇게 하면 워킹 디렉토리의 부모 dir에서 public이라는 폴더를 생성하고 그 안에 media폴더를 만들겠다는 의미\r\n\r\n`MEDIA_ROOT` 설정을 안하면 디폴트로 워킹디렉토리 바로 아래에 이미지파일들이 쌓인다.\r\n\r\n### 4. urls.py에 등록\r\n\r\n---\r\n\r\nurls.py\r\n\r\n```python\r\nfrom django.conf.urls.static import static\r\n\r\nif settings.DEBUG: #안해도 되긴하는데 배포시에는 접근이 안되게?\r\n    urlpatterns += static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)\r\n```\r\n\r\n### 5. Image 호출\r\n\r\n---\r\n\r\n이미지 객체에는 url이라는 속성이 있어 `img.url`을 통해 해당 이미지의 url을 가져올 수 있다.\r\n\r\n이미지를 띄우고 싶을 때, `<img src = \"{img.url}\"/>`로 불러온다면\r\n\r\n장고 보안에 의해 이미지가 안나타나고 <img ... /> 문자열 그 자체로 나타난다.\r\n\r\n이미지를 나타내고 싶을 때는 `mark_safe()`를 사용한다.\r\n\r\n```python\r\nclass PostAdmin(admin.ModelAdmin):\r\n    def photo_tag(self,post):\r\n        if post.photo:\r\n            return mark_safe(f'<img src = \"{post.photo.url}\"/>')\r\n        return None\r\n```\r\n\r\n### 6. upload_to\r\n\r\n만약 서비스 크기가 커진다면 쌓이는 이미지 파일또한 많아진다.\r\n\r\n이미지 파일이 많아질경우 파일들이 저장되는 위치를 폴더별로 나누려면 `upload_to`를 사용한다.\r\n\r\nex)\r\n\r\n`photo = models.ImageField(blank = True, upload_to ='board/post/%Y/%m/%d')`\r\n\r\n> 이미지 파일들이 작성한 year, month, day에 따라 분류된다.\r\n\r\n문자열이 아니라 함수로도 설정할 수 있다.\r\n\r\n- 문자열로 지정 : 파일을 저장할 중간 디렉토리 경로로서 활용\r\n\r\n- 함수로 지정 : 중간 디렉토리 경로 및 파일명까지 결정 가능\r\n\r\n### 6. FileField\r\n\r\n---\r\n\r\n**File Field**는 **File Storage API**를 통해 파일을 저장\r\n\r\n해당 필드를 옵션 필드를 두고자 할 경우 null이 아닌 `blank = True`를 사용한다.\r\n"},{"excerpt":"Minimax Algorithm max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다. max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다. 위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때 max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다 min(파란색)단인 1 depth…","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"date":"April 04, 2022","title":"Minimax 알고리즘 & alpha-beta 가지치기","tags":["ai","inha"]},"rawMarkdownBody":"\r\n### Minimax Algorithm\r\n\r\n\r\n---\r\n\r\nmax와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다.\r\n\r\nmax(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다.\r\n\r\n<img src =\"http://thumbnail.egloos.net/600x0/http://pds26.egloos.com/pds/201212/11/23/d0091423_50c73a317c0ed.png\"/>\r\n\r\n위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때\r\n\r\nmax(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다\r\n\r\nmin(파란색)단인 1 depth에서는 8과 7중 최소값인 7이 올란간다\r\n\r\n이것을 Minimax Algorithm이라고 하며, 가장 아래 depth부터 올라간다.(depth-first searching)\r\n\r\n### alpha-beta 가지치기\r\n\r\n---\r\n\r\nMinimax Algorithm을 할 때, searching할 필요가 없는 루트는 제거하는 방법이다.\r\n\r\n**Alpha**는 max단에서 정해지는 값이고, **Beta**는 min단에서 정해지는 변수이다.\r\n\r\n**Alpha** 는 이전(상위) 상태들 중에서 AI에게 가장 유리한 상태의 점수, **Beta** 는 이전(상위) 상태들 중에서 상대방에게 가장 유리한 상태의 점수이다.\r\n\r\n**Alpha cut-off** 는 자신이 상대방보다 불리하여, 자신이 그 경우를 선택하지 않을 때 불필요한 연산을 잘라내는 것이고, **Beta cut-off** 는 자신이 상대방보다 유리하여, 상대방이 그 경우를 선택하지 않을 확률이 높을 때 불필요한 연산을 잘라내는 것이다.\r\n\r\n#### 1. Alpha cut-off\r\n\r\n<hr>\r\n\r\n(1)\r\n\r\n<img src =\"http://pds25.egloos.com/pds/201212/12/23/d0091423_50c74f11d7ffe.png\"/>\r\n\r\n각각의 노드에 써있는 순서쌍이 (Alpha, Beta)라고 할 때\r\n\r\n재 1번으로 표시된 노드의 왼쪽 자식의 탐색을 끝냈고, 이제 2번 방향으로 진행해서 1번 -> 2번 -> 3번 -> 4번 노드 순으로 함수를 진행하고 있다고 생각해보자. 알파-베타 함수의 정의에 따라 부모 노드의 alpha, beta 값이 그대로 내려온다.\r\n\r\n위의 예에 대해 설명을 더 하자면, 1번 노드의 왼쪽 자식의 탐색을 끝내고 1번 노드의 알파 값이 5로 변경이 되었다. 이는, 1번 노드에서 현재까지 탐색된 경로들 중 최선의 경로를 선택해서 얻을 수 있는 최대값은 5라는 의미이다. 이제 2번 노드로 함수를 진행할 때, 1번 노드의 왼쪽자식으로부터 얻은 alpha 값을 넘겨주어 진행한다.\r\n3번, 4번 노드로 갈 때도 마찬가지.\r\n\r\n(2)\r\n\r\n<img src =\"http://pds27.egloos.com/pds/201212/12/23/d0091423_50c7501f5a0f1.png\"/>\r\n\r\n이제 5, 6, 7, 8번 노드 순으로 계속 진행한다.\r\n우선, 5번 노드의 하위 두 노드의 상태함수 값의 최소값은 4이므로 5번 노드의 베타값이 갱신이 되었다. 6번 노드의 알파값은 5이고, 5번 노드로부터 얻은 값 4와 비교해봤을 때 5가 더 크므로 6번 노드의 알파값은 변함없다. 7번 노드의 베타값은 6번 노드의 알파값인 5로 갱신되고, 이 때 alpha >= beta 가 되므로 alpha cut-off가 일어난다.\r\n\r\nalpha cut-off는 쉽게 말해서 **\"현재의 경로는 우리가 이미 아까 구해논 최적의 경로 값과 비교했을 때 상대방에게 더 유리한 경로이다. 그렇다면 현재의 경로를 애초에 택하지 않고 다른 경로를 택하면 되므로, 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"** 라는 논리이다.\r\n\r\n그림에서는 빨간색 플레이어가 8번 노드에서 왼쪽 자식으로 수를 두게 되면 최소 5의 상태함수값을 얻고, 오른쪽 자식으로 수를 두게 되면 상대방이 최선의 수를 둘 경우 4(혹은 그 이하 - 아직 나머지 자식들에 대한 탐색이 끝나지 않았으므로 모르는 것이다)의 상태함수값을 얻게 되어, 왼쪽 자식으로 수를 두는 것이 더 낫다. 따라서 더이상 오른쪽 자식의 남은 자식들에 대해 탐색할 필요가 없는 것이다.\r\n\r\n#### 2. beta cut-off\r\n\r\n---\r\n\r\n(1)\r\n\r\n<img src=\"http://pds27.egloos.com/pds/201212/12/23/d0091423_50c753d3207e2.png\"/>\r\n\r\n1 -> 2 -> 3번 노드 순으로 진행한다.\r\n1번에서 13, 16 중에 작은걸 베타 값으로 갱신하여 13을 리턴하였고,\r\n2번 노드에서 알파 값을 13으로 바꾼다. 여기서 alpha >= beta가 되므로 beta cut-off가 일어난다.\r\n\r\nbeta cut-off는 쉽게 말하면 **\"현재의 경로는 우리가 아까 구해논 상대방 입장에서의 최적의 경로 값과 비교했을 때 내가 더 유리한 경로이다. 따라서 만일 상대가 항상 최선의 수를 택한다면, 현재의 경로를 택하진 않을 것이다(만약 상대가 현재의 경로를 택해 준다면 내가 유리해지니까 땡큐고). 따라서 우리도 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"** 라는 논리이다.\r\n\r\n파란색 플레이어가 그림의 3번 노드에서 왼쪽 자식으로 진행하게 되면 7 이하의 상태함수값을 얻게 되고, 오른쪽 자식으로 진행하게 되면 최악의 경우 적어도 13의 상태함수 값을 얻게 된다. 따라서 파란색 플레이어 입장에서는 왼쪽으로 진행하는 편이 더 나은 것이고, 더 이상 나머지를 탐색할 필요성이 없어지는 것이다.\r\n\r\n#### + 예제\r\n\r\n<img src =\"https://t1.daumcdn.net/cfile/tistory/998EA7425AB214BD16\"/>\r\n\r\nsearching은 아래부터 시작한다. i부터 차례대로 depth-first searching을 한다고 가정한다.\r\n\r\nj가 4이므로 max단의 e에는 4이상의 숫자가 들어가게된다.\r\n\r\n1. 만약 k가 4보다 작다면?\r\n\r\n   max단에서 k보다 큰 j를 선택하므로 k를 선택하지않는다.\r\n\r\n2) 만약 k가 4이상이라면?\r\n\r\n   max단의 e가 k를 선택하게된다. 그러나 d의 값이 e(=k)의 값보다 작은 2이므로 상위단인 b에서 e가 아닌 d를 선택하게되므로 똑같이 k로 갈 일이 없다.\r\n\r\n**따라서 e -> k는 가지치기를 하게된다**\r\n\r\n(참고 - http://musicdiary.egloos.com/v/4274653)\r\n"},{"excerpt":"작성중 1. RESTful API의 몇 가지 디자인 원칙 리소스(모델등)를 중심으로 디자인 클라이언트에서 엑세스 할 수 있는 모든 종류의 개체/ 서비스가 리소스에 포함 리소스마다 해당 리소스를 고유하게 식별하는 식별자 존재 ex)  요청/응답 포맷으로 흔히 JSON 사용 균일한(uniform) 인터페이스를 적용 리소스에 표준 HTTP 동사(GET, POS…","fields":{"slug":"/rest/"},"frontmatter":{"date":"April 04, 2022","title":"REST","tags":["django","DRF"]},"rawMarkdownBody":"\r\n작성중\r\n\r\n### 1. RESTful API의 몇 가지 디자인 원칙\r\n\r\n---\r\n\r\n1. 리소스(모델등)를 중심으로 디자인\r\n\r\n2. 클라이언트에서 엑세스 할 수 있는 모든 종류의 개체/ 서비스가 리소스에 포함\r\n\r\n3. 리소스마다 해당 리소스를 고유하게 식별하는 식별자 존재\r\n\r\n   ex) `https://my-trips.com/trips/1/`\r\n\r\n4. 요청/응답 포맷으로 흔히 JSON 사용\r\n\r\n5. 균일한(uniform) 인터페이스를 적용\r\n\r\n   리소스에 표준 HTTP 동사(GET, POST, PUT, PATCH, DELETE)\r\n\r\n### 2. HTTP METHOD별 다양한 상태 코드\r\n\r\n---\r\n\r\n#### GET\r\n\r\n일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답\r\n\r\n#### POST\r\n\r\n201(Created) 응답. 새 리소스의 URI는 응답의 로케이션 헤더에\r\n\r\n새 리소스를 만들지 않은 경우, 200응답하고 리소스와 관련된 내용을 응답 본문에 포함. 반환할 결과가 없으면 204(내용없음)을 반환할 수도\r\n\r\n400(잘못된 요청)\r\n\r\n#### PUT\r\n\r\n성공- 200(OK) 204(내용없음)\r\n\r\n실패 - 409(충돌)\r\n\r\n#### DELETE\r\n\r\n성공시 204, 리소스가 없으면 404\r\n\r\n#### 비동기작업\r\n\r\n202(수락됨) - 요청은 수락되었지만 아직 완료되지않음\r\n\r\n비동기 요청의 상태를 반환하는 URI를 로케이션 헤더로 변환\r\n\r\n로케이션 헤더를 통해 비동기작업의 진행상황을 알 수 있음\r\n"},{"excerpt":"Meta 클래스란? 모델 내부에 정의되는 클래스로 Django모델 자체에 대한 정보, 속성을 추가하는 클래스이다. Meta 클래스는 권한, 데이터베이스의 이름, 단 복수 이름, 추상화, 순서 지정등과 같은 모델에 대한 다양한 사항을 정의하는데 사용할 수 있다. 다음은 Meta 클래스 활용 예시이다. 1. abstract 모델이 추상적인지를 결정한다. 추상…","fields":{"slug":"/meta-class/"},"frontmatter":{"date":"April 03, 2022","title":"Django의 Meta 클래스 활용","tags":["django"]},"rawMarkdownBody":"\r\n## Meta 클래스란?\r\n\r\n모델 내부에 정의되는 클래스로 Django모델 자체에 대한 정보, 속성을 추가하는 클래스이다.\r\n\r\n```python\r\nfrom django.db import models\r\n\r\n#모델 내부에 정의\r\nclass MyModel(models.Model):\r\n    ...\r\n    class Meta:\r\n\t\t...\r\n```\r\n\r\nMeta 클래스는 권한, 데이터베이스의 이름, 단 복수 이름, 추상화, 순서 지정등과 같은 모델에 대한 다양한 사항을 정의하는데 사용할 수 있다.\r\n\r\n다음은 Meta 클래스 활용 예시이다.\r\n\r\n### 1. abstract\r\n\r\n모델이 추상적인지를 결정한다. 추상 클래스는 인스턴스화 할 수 없고 확장 또는 상속만 가능하다.\r\n\r\n```python\r\n class Meta:\r\n        abstract = True\r\n```\r\n\r\n### 2. db_table\r\n\r\n데이터베이스 테이블 이름을 설정한다.\r\n\r\n```python\r\nclass Meta:\r\n    db_table = \"comment\"\r\n```\r\n\r\n기본적으로 Django에서 db table의 이름은 앱이름\\_모델이름으로 정의된다.\r\n\r\nex) _board앱의 Post모델의 경우: board_post로 정의됨_\r\n\r\nMySQL등 장고 외부 데이터베이스와 연동할 때 사용하는듯?\r\n\r\nMySQL 백엔드의 경우 테이블 이름은 소문자로 지정해야하고 Oracle은 테이블 이름에 30자 제한이 있음. 이럴 때 사용하는듯\r\n\r\n### 3. ordering\r\n\r\n모델 필드명을 기준으로 모델 객체의 순서를 정의한다.\r\n\r\n```python\r\nfrom django.db import models\r\n\r\nclass JobPosting(models.Model):\r\n    dateTimeOfPosting = models.DateTimeField(auto_now_add = True)\r\n\r\n\r\n    class Meta:\r\n        ordering = [\"-dateTimeOfPosting\"]\r\n```\r\n\r\n### 4. verbose_name\r\n\r\nDjango 모델을 admin페이지에서 조회할 때 모델 표기 방법을 변경한다.\r\n\r\n```py\r\nclass Meta:\r\n    verbose_name = \"포스트\"\r\n```\r\n"},{"excerpt":"container와 item flex하기전 알아야할 컨테이너와 아이템\n컨테이너가 전체 박스\n아이템이 컨테이너 안에 있는 요소 flex를 사용해서 정렬해주려면 컨테이너에 속성을 추가해준다. 주축 flex-direction속성으로 flex의 주축을 설정할 수 있다 row row-reverse column column-reverse 주축을 기준으로 정렬할때는 …","fields":{"slug":"/flex/"},"frontmatter":{"date":"April 02, 2022","title":"flex 해보기 ㅎㅎ","tags":["css"]},"rawMarkdownBody":"\r\n### container와 item\r\n\r\nflex하기전 알아야할 컨테이너와 아이템\r\n컨테이너가 전체 박스\r\n아이템이 컨테이너 안에 있는 요소\r\n\r\nflex를 사용해서 정렬해주려면 컨테이너에\r\n\r\n```css\r\ndisplay: flex;\r\n```\r\n\r\n속성을 추가해준다.\r\n\r\n### 주축\r\n\r\n```css\r\nflex-direction: row;\r\n```\r\n\r\nflex-direction속성으로 flex의 주축을 설정할 수 있다\r\n\r\n- row\r\n- row-reverse\r\n- column\r\n- column-reverse\r\n\r\n### 주축을 기준으로 정렬할때는 justify-content를 사용\r\n\r\n```css\r\njustify-content: flex-end;\r\n```\r\n\r\n- flex-start\r\n- center\r\n- flex-end\r\n- space-between : 맨 끝 간격제로\r\n- space-around : 맨 끝 간격있음\r\n\r\n### 반대축을 기준으로 정렬할때는 align사용\r\n\r\n- align-items\r\n- align-content - wrap을 했을때\r\n\r\n### wrap\r\n\r\n```css\r\nflex-wrap: wrap;\r\n```\r\n\r\n- wrap\r\n- wrap-reverse  \r\n  wrap을 하면 item이 공간을 벗어날때 다음 줄에 이어서 나오게한다.\r\n"},{"excerpt":"스케줄링 policy : CPU를 누구한테 할당할까\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐 FCFS 가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리 하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함 24, 3, 3 …","fields":{"slug":"/5-2/"},"frontmatter":{"date":"March 30, 2022","title":"OS 스케줄링","tags":["OS"]},"rawMarkdownBody":"\r\n스케줄링 policy : CPU를 누구한테 할당할까\r\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\r\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐\r\n\r\n## FCFS\r\n\r\n가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리\r\n\r\n하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함\r\n\r\n24, 3, 3 <-cpu burst time\r\n\r\n단점: 시피유 버스트 타임이 긴 프로세스가 먼저 선택된다면 하나가 시피유를 독점\r\n솔루션 : 시피유 버스트가 끝날때까지 기다리는게 아니라 일정 시간이 지나면 강제적으로 컨텍스트 스위치를 시켜버리자 time slice\r\n\r\n예제)\r\n\r\nP1 P2 P3순으로 실행(먼저 온 순서)\r\n\r\n- waiting time : 각 프로세스가 도착한 이후에 얼마나 기다렸는가\r\n\r\np2 p3 p1 순으로 왔을 때 훨씬 빨라짐\r\n\r\n## Shortest Job First (SJF)\r\n\r\nKey operations : length of CPU burst\r\n\r\n각각의 cpu 버스트의 길이를 가지고 짧은 애한테 우선순위 할당\r\n\r\noptimal함 : 쉽게 증명 가능\r\n\r\nwaiting time 기준으로는 가장 좋은 policy\r\n\r\n문제) 어떻게 cpu burst 타임을 알 수 있는지\r\n정확한 cpu burst time을 OS가 알 수 없음. 구현불가능!\r\n\r\ntwo variations이 존재\r\n\r\n- non preemptive (양보가 안되는. 우선순위)\r\n\r\n  어떤 SJF정책에 의해서 한 번 씨피유를 점유하면 그 잡이 끝날때까지는 스케줄링이 되지 않는다. 자리 안내줌\r\n\r\n- preemptive(양보가능한)\r\n\r\n  만약 SJF정책에 의해 짧은애가 선택이 되면\r\n  새로운 프로세스가 레디큐에 들어옴\r\n  다시 스케줄링 가능. 새로 들어온 애 먼저 들어가게 해줌 \r\n\r\n  ex)\r\n  끝난 시간 /바로 수행됐다면 끝났을 시간/ waiting time\r\n  p1 16 (0+7) 9\r\n  p2 7 (2+4) 1\r\n  p3 5 (4+1) 0\r\n  p4 11 (5+4) 2\r\n\r\n근데 cpu burst time을 알 수 없음\r\n\r\n노력1. 예측해보자!\r\nexponential averaging\r\n수학적인 컨셉 제공 but 실제로 os에 적용하긴 무리 : 알파값 정하기가 힘듦. 실패케이스\r\nn+1시점의 cpu burst time을 이전의 히스토리를 가지고 예측해보자\r\n\r\ntn : 바로 직전의 실제 cpu burst time\r\n타우n+1 : 이번에 예측할 cpu burst time\r\n타우n : 바로 직전에 예측했던 cpu burst time\r\n\r\n알파를 얼마로 정해야?\r\n알파 = 0 기존에 예측한거 유지\r\n알파 = 1 직전의 실제값만 씀\r\n알파값은 시스템과 응용프로그램에 따라 또 달라짐\r\n이론적인 컨셉만 제공하고 실제 사용은 안함\r\n\r\n더 나은 policy를 찾아야할 필요성\r\n\r\n---\r\n\r\n## Round Robin(RR)\r\n\r\nKey operations : 각각의 프로세스는 각자의 time quantum(q) 동안만 cpu를 차지할 수 있음. q가 끝나면 cpu를 돌려주고 레디큐의 맨 끝으로 돌아감.\r\n\r\nq는 10 - 100 밀리세컨드 정도\r\n\r\nq가 크면 : FIFO. FCFS와 같아짐.\r\nq가 작으면 : 컨텍스트 스위치 오버헤드가 커짐. SJP와 근접해짐.\r\n\r\n많은 os가 라운드로빈이 기반인 스케줄링 사용\r\n\r\n컨텍스트 스위치타임은 보통 <10\r\nq를 10~100으로 잡아서 컨텍스트 스위치타임의 오버헤드가 안보이게\r\n\r\n만약 n개의 프로세스가 있다면 어떤 프로세스가 자기 순서를 받을때까지 최대 (n-1)q 만큼만 기다리면 됨\r\n\r\nbad case) 10개의 프로세스가 100 time을 수행해야함\r\n\r\n1000-10 #waiting time\r\n1000-9\r\n1000-8\r\n.\r\n.\r\n.\r\n\r\n다들 오랜 시간 기다려야함.\r\n균등하게 비효율적.\r\n\r\n즉,  스케줄링 할 대상들이 비슷한 cpu burst time을 가질때 bad\r\n\r\nex) \r\n\r\n* q가 100 \r\n* p1 cpu burst:1 , I/O burst :10\r\n* p2는 그냥 계속 cpu burst\r\n\r\n![](./ex.png)\r\n\r\np1 1ms + 10ms waiting |1ms + 10ms|\r\np2 100ms . . . . . . . . 100ms . . . . . .\r\n1ms 후 100ms 수행\r\n\r\n\r\n\r\nU(CPU) = 100% (cpu가 얼마나 활용되고있는가)\r\n\r\nU(I/O) = 10ms 돌고 91ms 기다림\r\n10/101 = 10%\r\n\r\n단점) I/O 사용이 잘 안됨\r\n\r\n같은 ex, q만 다르다고 가정) q = 1\r\nU(CPU) = 100%\r\nU(I/O) = 거의 90% p1이 cpu burst할때 제외하고는 다 I/O (10/11)\r\n\r\n단점) 컨텍스트 스위칭이 자주 일어남. 오버헤드큼\r\n\r\n타임 퀀텀이 적절해야 라운드로빈 효율적\r\n근데 적절한 타임이 cpu burst와 i/o burst에게 다름\r\ncpu는 클수록. io는 작을수록\r\n\r\n다음해결방안 : (SJ)io bound process한테는 타임 퀀텀을 작게 (LJ)씨피유는 타임퀀텀을 크게\r\n\r\n프로세스마다 다르게 적용함 adaptive policy\r\n\r\n## Priority Scheduling\r\n\r\n각 프로세스마다 우선순위 부여 - 숫자형태로\r\n\r\n더 높은 우선순위 먼저 실행\r\nSJF도 프라이어리티 스케줄링의 일종이라고 볼 수 있음. 얘는 실행시간이 짧은애가 우선\r\n\r\n얘도\r\n프림티브\r\n논프림티브 둘 다 만들 수 있음\r\n\r\n문제) Starvation\r\n어떤 프로세스가 우선순위가 낮음. 우선순위가 더 높은 프로세스가 계속들어온다면 우선 순위가 낮은 프로세스는 실행될 수 없음.\r\n\r\n솔루션) Aging\r\n프라이어티에 나이 개념 도입\r\n대기 시간이 길어지면 우선순위롤 조금씩 올려줌\r\n\r\n## Multilevel Queue\r\n\r\n큐를 분리해서 사용\r\n\r\nforeground - 인터랙티브 : cpu보다 io가 더 느림\r\nbackground - batch : cpu가 긴.\r\n각 프로세스는 한 번 큐가 정해지면 그 큐만 사용? 반배정하듯이\r\n각각의 큐는 서로 다른 policy를 가질 수 있음\r\n\r\n- foreground - RR\r\n\r\n- background - FCFS\r\n\r\n> 반드시 저런건 아님. 설계하기나름\r\n\r\n어떤 큐에 있는 애한테 우선순위를 줄 것인지도 결정 필요\r\n이를 위한 policy도 추가적으로 필요\r\n\r\n- 고정된 프라이어티 스케줄링\r\n\r\n- 타임 슬라이스 (포그라운드한테 일정시간, 백그라운드한테 일정시간)\r\n\r\n  아직은 adaptive아님 아냐 아주 약간 adaptive...?\r\n\r\n실질적으로 사용하는게 Multilevel Feedback Queue\r\n\r\n"},{"excerpt":"📌 Interrupt CPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재 특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다 Interrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음. cpu 내에서 일어난건…","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"date":"March 30, 2022","title":"2-2 Interrupt 메카니즘","tags":["OS"]},"rawMarkdownBody":"\r\n# 📌 Interrupt\r\n\r\nCPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\r\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재\r\n\r\n* 특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다\r\n\r\nInterrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음.\r\n\r\ncpu 내에서 일어난건 trap, exception이라고 부름 인터럽트랑 다르게 취급\r\n\r\nsoftware-generated interrupt라고도 부름\r\n\r\nex. 0으로 나누면 안되는데 0으로 나눴다던지\r\n\r\n OS는 interrupt driven 프로그램 :\r\n\r\n* os내부의 커널은 생각보다 수동적. 밖에서 인터럽트가 들어와야 깨어나서 일을 함\r\n\r\n\r\n\r\n## 📌 Interrupt Handling\r\n\r\n📌 **인터럽트가 오면 어떻게 하죠?**\r\n\r\n* 현재 프로그램을 stop한다(현재 진행중이던 instruction은 시행한다. 하던건 끝내고 스탑함)\r\n* 현재 cpu의 상태를 저장한다(사용하던 레지스터값, pc등)\r\n* 인터럽트 벡터 테이블을 통해 ISR을 알아냄\r\n* ISR로 점프해서 실행\r\n\r\n> 사실 ISR이 커널의 핵심임\r\n\r\n\r\n\r\n![](./timeline.png)\r\n\r\n* cpu는 I/O request보내놓고 할 일 계속함\r\n\r\n* CPU 그래프?의 1에 해당하는 부분은 user-processing\r\n* 0에 해당하는 부분은 interuupt processing\r\n\r\n* I/O가 response(= interrupt)를 보낼때까지 CPU는 user processing mode\r\n* 조금 딜레이된 이유는 하던 명령까지는 하고 끝낸다\r\n\r\nOS는 interrupt driven 프로그램\r\n\r\n\r\n\r\n## OS Design and Implementation\r\n\r\n정답이 있는건아님.\r\n\r\n여러가지 os는 다 다르게 생겼다\r\n\r\n* 골을 세우고\r\n* 스펙을 정한다\r\n\r\n* os는 하드웨어 위에서 일하기때문에 하드웨어에 종속적\r\n* os는 유저에도 맞닿아있고 하드웨어에도 맞닿아있다\r\n* 사용하기도 쉽고 구현하기도 쉽고 유지도 쉬워야...\r\n* **policy와 mechanism을 분리해서 설계해야한다**\r\n\r\n\r\n\r\n* **📌 Policy** \r\n\r\n  뭘 해야하는가! what!!!, 환경, 사용자가 어떻게 사용하는지... 뭐 그런거에 의해 변경될 수 있음\r\n\r\n  \r\n\r\n* **📌 Mechanism**\r\n\r\n  어떻게 해야 하는가!, 어떤거 동작해야하는지, 기계적 how!!!, 하드웨어에 종속적\r\n\r\n\r\n\r\n둘이 변경되는 상황이 달라서 구분해두는게 좋음. 유연성 증가!\r\n\r\n\r\n\r\n## OS Implementation\r\n\r\n* 초창기 os는 어셈블리 기계어\r\n\r\n* 대부분의 os가 c로 설계\r\n* 요즘은 믹스, high-level language도 사용\r\n\r\n> 하이레벨 랭귀지 \r\n>\r\n> 장점 : 다른 하드웨어에 포트하기쉬움, 기계어로 직접 번역되어있지않기때문에 해당 기계어로 번역 가능, 빨리 작성 가능, 간결, 이해하기 쉬움, 디버깅도 쉬움, c도 하이레벨\r\n>\r\n> 단점 : 느림\r\n\r\n**사실 os의 주 성능은 하이레벨랭귀지... 사용여부보다는 policy가 더 중요**\r\n\r\n\r\n\r\n## OS Structure\r\n\r\n* Simple structure - MS-DOS\r\n* More complex - Initial UNIX\r\n* Layered approach\r\n* Microkernel structure \r\n* Hybrid\r\n\r\n\r\n\r\n> 추상화 \r\n>\r\n> 블랙박스화, 각각의 모듈은 다른 모듈의 세부적인 내용에 대해 알 필요 없다. 서로 무슨 일 하는지, 통신만 할 수 있기만 하면 됨\r\n\r\n\r\n\r\n> 분리 (Decomposition)\r\n>\r\n> os는 거대하기때문에 모듈화\r\n\r\n\r\n\r\n### MS-DOS\r\n\r\n윈도우가 나오기전 마이크로소프트웨어에서 만들던 os\r\n\r\n초창기 pc 운영체제\r\n\r\n모듈화가 안되어있음\r\n\r\n필수적인 기능만 존재\r\n\r\n싱글 태스크 - 싱글 유저\r\n\r\n프로그램 -> 커널 ->프로그램 형식의 단순한 형태\r\n\r\n\r\n\r\n### Initial UNIX\r\n\r\n![](./unix.png)\r\n\r\n* 📌 시스템 프로그램과 커널을 나눔\r\n\r\n* 나누긴 했지만 커널은 여전히 하나\r\n* 굉장히 큰 커널 하나! 커널 하나에서 i/o통신, 파일 시스템, cpu스케줄링등 다 하는 중\r\n* 모놀리식 구조라고도 함 (커널이 하나로 이루어져있다. 단순)\r\n\r\n\r\n\r\n### Layered Approach\r\n\r\n* 각각의 레이어는 자신보다 하위 계층과 소통할줄만 알면 된다\r\n* 📌 N이 클수록 상위. 일의 요청이 한 단계 아래로만 일어난다. 레이어1은 레이어0에게 일 요청\r\n* 낮을수록 하드웨어, 높을수록 사용자 인터페이스와 가까운\r\n* 모듈화\r\n* 블랙박스화됨. 각각의 레이어는 다른 레이어가 어떻게 구현되어있는지 모름. 일만 시킬줄알면됨\r\n* 현대 os는 레이어로 이루어져있지않음. 마이크로커널과 모듈화로 되어있음\r\n\r\n\r\n\r\n### Microkernel\r\n\r\n마이크로 : 작음\r\n\r\n커널이 작다!\r\n\r\n> 여러 파트로 나뉘어있으나 커널 파트한테 주는게 아니라 유저 레벨 프로그램으로 만듦. 커널의 마이크로한 기능들이 **유저 레벨 프로그램**처럼 동작함\r\n\r\n* 커널에서 필수적인 부분을 빼고는 제외함\r\n\r\n* 나머지는 유저 레벨 프로그램으로 만들어버림 \r\n\r\n  (os의 일부분... 기능이지만 os 밖에서 작동)\r\n\r\n* 유저 레벨 프로그램끼리는 **메세지 패싱**을 통해 주고받음\r\n\r\n* 예전에는 커널안에 같이 있어서 걍 메모리 주소 access했음\r\n\r\n* 메모리 카피가 일어남. 퍼포먼스 오버헤드 존재\r\n\r\n* 커널이 작아서 커널 업데이트하기가 쉬움, 디버깅도 당연 쉽\r\n\r\n* 커널을 다른 시스템에 적용하기도 쉬움. 작으니까~!\r\n\r\n* reliable. 커널 안에서 돌아가는 기능이 적어지면서 원래는 커널 안의 동작이 여러군데 영향을 끼쳤는데 이젠 밖에서 일어나니까 한 부분에 문제가 발생하도 다른 프로그램에 영향을 덜 끼친다 (같은 의미에서 secure해짐)\r\n\r\n* Mac OS X kernel 다윈의 한 부분이 마이크로커널로 구현됨\r\n\r\n\r\n\r\n### Modules\r\n\r\nloadable kernel modules (LKM)\r\n\r\n* 기본적으로 마이크로 커널과 비슷하게 생김\r\n* 하나의 프로그램으로 나눈게 아니라 동적으로 탑재할 수 있는 라이브러리 형태로 나눔. 기능이 필요할 때 마다 동적으로 사용\r\n* 마이크로커널처럼 핵심적인 os는 적음\r\n* 추가적인 서비스는 커널이 동작하는동안 동적으로 로딩해서 링킹하고 사용한다\r\n* 실질적으로 수행할때는 하나의 커널안에서 수행되어서 메시지 패싱이 필요없음\r\n\r\n\r\n\r\n### Hybrid System\r\n\r\n섞어씀 ㅎ\r\n\r\n모듈로 구성하되 특정 부분은 마이크로 ...\r\n\r\n요즘은 거의 다 섞어 씀\r\n\r\n## 📌 OS Structure 시험 안나온다함 킹받네\r\n"},{"excerpt":"OS(운영체제)란? 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.\n사용자와 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌.\nex) Windows, Linux OS의 역할 reso…","fields":{"slug":"/1-2/"},"frontmatter":{"date":"March 29, 2022","title":"OS의 역할과 역사","tags":["OS"]},"rawMarkdownBody":"\r\n## OS(운영체제)란?\r\n컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.\r\n사용자와 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌.\r\nex) Windows, Linux\r\n\r\n## OS의 역할\r\n\r\n- resource allocator\r\n- program controller\r\n\r\nfor 유저의 편리한 사용\r\nfor 좋은 성능\r\n\r\n- 공유된 컴퓨터\r\n  큰 서버의 shared resource를 어떻게 분배할 것인가\r\n  handheld computers는 리소스가 작음. 배터리 처리\r\n  임베디드 컴퓨터는 유저 인터페이스가 없는 경우가 있어 os가 처리\r\n\r\n## OS의 역사\r\n## 1. (Early 1950s - Mid 1960s)\r\n하드웨어가 비쌈\r\ngoal : 어떻게 하드웨어를 효율적으로 사용할 것인가\r\npunch card를 사용해 하나하나 코딩\r\n사람이 os의 역할을 수행 (operator)\r\n\r\n- 카드를 받고 출력을 해서 유저에게 전달\r\n  📌 **slow job to job **\r\n\r\n---\r\n\r\n### Simple batch monitor(여러개의 job을 묶음)\r\n\r\n저성능 컴퓨터, 고성능 컴퓨터 함께 사용\r\n저성능은 인풋, 아웃풋 \r\n고성능은 연산\r\n\r\n**io할 때는 cpu연산 못함**\r\n\r\n<bold> faster job to job </bold>\r\n\r\n---\r\n\r\n### batch monitor(최초의 os)\r\n\r\n📌 **하드웨어 메커니즘이 나옴 - I/O와 CPU 분리**\r\nI/O를 하는동안 cpu연산을 못해서 분리\r\n\r\ninturrupt : cpu에게 I/O작업이 끝났음을 알려줌\r\n\r\n📌 **버퍼링과 interrupt 핸들링작업이 os에 추가됨**\r\n\r\n- computation과 비동기적(async) I/O가 분리됨\r\n\r\nsync I/O - read : 읽어와야 다음 작업 가능\r\nasync I/O - write : 쓰는 행위는 다음 작업에 영향을 안끼침\r\n(모든 read가 sync, write가 async인건 아니지만 대체로 그러함)\r\n\r\n### Multi-programmed batch monitor\r\n\r\n- 📌 **동시에 둘 이상의 active한 job(시작되었으나 아직 끝나지않은 작업)을 수행**\r\n- sync I/O도 분리\r\n- Degree of multiprogramming >= 1 : active job을 얼마나 수행할 수 있는지\r\n\r\n#### 멀티 프로그래밍이 생기면서 시작된 문제들\r\n\r\n\\* Memory protection and relocation\r\n하나의 job이 실수로 다른 job에 영향을 끼침\r\n다른 job의 addr를 침범\r\n하나의 메모리공간에 여러 job이 올라감. job의 주소 공간 예측 불가능 - 로지컬 주소와 피지컬 주소의 구분이 생김\r\n-> MMU(Memory-Management-Unit)\r\n\r\n\\* Higher utilization\r\n\r\n\\* Concurrent programming\r\n하나의 자원을 공유하면서 생기는 문제\r\n\r\n## 2. (Mid 1960s - Mid 1990s)\r\n\r\n하드웨어가 저렴해짐, 인력이 비싸짐\r\ngoal: 인력을... 효율적으로 ...\r\n\r\n### Interactive time-sharing OS\r\n\r\n하나의 cpu를 분할해서 여러 사람들이 사용\r\n\r\n- 터미널이 저렴 : 메인컴퓨터 하나에 여러 터미널 존재\r\n- 파일 시스템 등장\r\n- Response time과 protection이 더욱 중요해짐\r\n\r\n### PC OS - personal computer\r\n\r\n각자 컴퓨터가 생김\r\nOS가 subroutine libaray로 나눠짐(OS를 큰 기능별로 나눠서 사용)\r\n\r\n## 3.(Mid 1990s - )\r\n\r\n- 인터넷\r\n  Network I/O가 생김\r\n- 동영상등 멀티미디어 서포트\r\n  QoS(Quality of Service)\r\n  -> OS scheduling 발전\r\n  예전 : priority - 우선순위 기반\r\n  멀티미디어 서포트 이후 : badwidth 기반 - 각각의 프로세스에게 조금씩 할당\r\n- connected multimedia services\r\n  스트리밍\r\n- 모바일\r\n  적은 리소스, 배터리를 효율적으로 관리\r\n- 클라우드 컴퓨팅\r\n  virtualzation\r\n\r\n## OS의 특징\r\n\r\n- Large\r\n  수천만 라인\r\n- Complex\r\n  비동기적인 behaviors의 집합체\r\n  하드웨어 특성의 이해 필요\r\n- Poorly understood\r\n  오랜시간동안 기능이 추가되며 만들어짐\r\n  코드에 대한 이해도가 떨어져감\r\n"},{"excerpt":"1. OS의 구조  GUI : 그래픽 UI ex. 마우스 커서 command line : 커맨드입력창 시스템콜 : os 내부 기능 활용 커널(그림의 services) 2. 컴퓨터 하드웨어 CPU DISK disk controller memory 📌 bus\n등등... System bus Data bus\n서로 데이터를 주고받음 Command/Address b…","fields":{"slug":"/os-structure/"},"frontmatter":{"date":"March 29, 2022","title":"2-1 OS의 구조","tags":["OS"]},"rawMarkdownBody":"\r\n## 1. OS의 구조\r\n\r\n<br/>\r\n\r\n![](./osinstructure.png)\r\n\r\n- **GUI** : 그래픽 UI ex. 마우스 커서\r\n\r\n- **command line** : 커맨드입력창\r\n\r\n- **시스템콜** : os 내부 기능 활용\r\n\r\n- **커널**(그림의 services)\r\n\r\n## 2. 컴퓨터 하드웨어\r\n\r\n- CPU\r\n- DISK\r\n- disk controller\r\n- memory\r\n- 📌 bus\r\n  등등...\r\n  - System bus\r\n  \r\n    1. Data bus\r\n       서로 데이터를 주고받음\r\n    2. Command/Address bus\r\n       메모리 주소, 명령어(거의 read/write : 프린터에 뭘 쓰기위해 설정값을 바꾸려는 명령어도 write에 포함)\r\n  \r\n  - 버스 component classification\r\n    1. Bus arbiter(버스 관리자)\r\n       여러개의 버스 리퀘스트가 동시에 들어옴. 어떤애를 먼저 보낼지 충돌 관리\r\n    2. Bus master\r\n       신호를 보내는 쪽 : bus transactionn을 만듦.\r\n       ex) CPU, DMA controller, graphics adapter\r\n    3. Bus slave\r\n       신호를 받는 쪽\r\n       ex) Memory, Device controller\r\n\r\n## 3. I/O Operations\r\n\r\nI/O controller가 cpu commands에 따라 I/O operations 수행\r\nI/O controller register\r\n\r\n- Data register(input, output : 실질적으로 보내고 받는 데이터)\r\n- 📌 Control register(control, status) <- 컨트롤 레지스터의 값을 변경해줌으로써 i/o동작이 일어나도록 함\r\n\r\nex) 아웃풋 레지스터 수행할때\r\n\r\n1. cpu : read status register of I/O controller(레지스터가 사용 가능한 상태인지 확인)\r\n2. write cmd : data를 I/O controller한테 보냄\r\n3. 쓸 수 없는 상태라면 쓸 수 있는 상황이 될 때까지 1번을 반복\r\n\r\n### 📌 I/O operation이 끝났는지 확인할 수 있는 방법 :\r\n\r\n1. Polling I/O\r\n2. interrupt-driven I/O\r\n\r\n#### Polling I/O\r\ncpu가 주도\r\n주기적으로 I/O status reg를 체크\r\n\r\n#### Interrupt-driven I/O\r\nI/O controller가 주관\r\nI/O device controller가 cpu한테 알려줌\r\n\r\n### 📌 I/O register에 접근 방법\r\n\r\n1. Memory-mapped I/O : 메모리 addr주소에 접근\r\n2. Port-mapped I/O : 메모리 주소는 따로 있고 디바이스 별로 포트를 만들어서 접근. Port-mapped I/O가 대체로 쓰임\r\n"},{"excerpt":"장고 모델 <데이터베이스 테이블>과 <파이썬 클래스>를 1대1로 매핑 모델 클래스명은 단수형으로 지정\nex) Posts(x) Post(o) 첫 글자는 대문자 - PascalCase 네이밍 장고 모델을 통해 데이터베이스 형상을 관리할 경우 모델 클래스 작성 모델 클래스로부터 마이그레이션 파일 생성 : makemigrations 마이그레이션 파일을 데이터베이…","fields":{"slug":"/django-ORM/"},"frontmatter":{"date":"March 28, 2022","title":"django ORM","tags":["django"]},"rawMarkdownBody":"\r\n## 장고 모델\r\n\r\n<데이터베이스 테이블>과 <파이썬 클래스>를 1대1로 매핑\r\n\r\n- **모델 클래스명은 단수형으로 지정**\r\n  ex) Posts(x) Post(o)\r\n\r\n- **첫 글자는 대문자** - PascalCase 네이밍\r\n\r\n### 장고 모델을 통해 데이터베이스 형상을 관리할 경우\r\n\r\n1. 모델 클래스 작성\r\n2. 모델 클래스로부터 마이그레이션 파일 생성 : makemigrations\r\n3. 마이그레이션 파일을 데이터베이스에 적용 : migrate\r\n4. 모델 활용\r\n\r\n### 장고 외부에서 데이터 베이스 형상을 관리할 경우\r\n\r\n데이터베이스로부터 모델클래스 소스 생성 : inspectdb\r\n모델 활용\r\n\r\n## DB 테이블명\r\n\r\ndefault : \"앱이름\\_모델명\"  \r\nex) blog앱의 Post모델 -> \"blog_post\"\r\n커스텀을 위해선 모델 Meta 클래스의 db_table 속성 변경\r\n\r\n> migrate전에 변경해야함\r\n\r\n## migrate 쿼리 보기\r\n\r\npython manage.py sqlmigrate (앱이름) (마이그레이션파일이름)  \r\nex) python manage.py sqlmigrate blog 0001_initial\r\n\r\n## 테이블 목록 보기\r\n\r\npython manage.py dbshell (sqlite 설치 필요)  \r\n.tables\r\n\r\n## 스키마 보기\r\n\r\n.schema (db 테이블명: 앱이름\\_모델이름)  \r\nex) .schema blog_post\r\n"},{"excerpt":"에러내용 git push 전 pull 했는데 fatal: refusing to merge unrelated histories 오류가 날 때 깃허브 레파지토리를 먼저 만들고 로컬에서 프로젝트 생성 후 푸쉬하려고 할 때 두 프로젝트를 다른 것으로 인식해서 나는 에러 해결방법 --allow-unrelated-histories 독립적인 두 프로젝트를 병합하는 명…","fields":{"slug":"/git1/"},"frontmatter":{"date":"March 27, 2022","title":"git pull 오류 : fatal: refusing to merge unrelated histories","tags":["ERROR"]},"rawMarkdownBody":"\r\n### 에러내용\r\n\r\ngit push 전 pull 했는데 **fatal: refusing to merge unrelated histories** 오류가 날 때\r\n\r\n> 깃허브 레파지토리를 먼저 만들고 로컬에서 프로젝트 생성 후 푸쉬하려고 할 때 두 프로젝트를 다른 것으로 인식해서 나는 에러\r\n\r\n### 해결방법\r\n\r\n```\r\n    git pull origin [브런치] --allow-unrelated-histories\r\n```\r\n\r\n--allow-unrelated-histories\r\n\r\n독립적인 두 프로젝트를 병합하는 명령어\r\n"},{"excerpt":"1. 패키지 다운로드 CORS란?\n동일한 출처의 리소스에만 접근하도록 제한하는 것. 프로토콜, 호스트명, 포트번호가 모두 같아야함.\nDjango 서버는 127.0.0.1:8000에서 실행되고 React서버는 127.0.0.1:3000에서 실행된다.\n두 서버의 포트번호가 다르기때문에 CORS 에러가 발생! 2. Django project의 settings.…","fields":{"slug":"/initial-settings/"},"frontmatter":{"date":"March 26, 2022","title":"Django REST Framework와 React 연동 첫걸음! 초기세팅을 해보자!","tags":["DRF","React"]},"rawMarkdownBody":"\r\n### 1. 패키지 다운로드\r\n\r\n```\r\n    pip install django\r\n    pip install djangorestframework\r\n    pip install django-cors-headers\r\n```\r\n\r\n**CORS란?**\r\n동일한 출처의 리소스에만 접근하도록 제한하는 것. 프로토콜, 호스트명, 포트번호가 모두 같아야함.\r\nDjango 서버는 127.0.0.1:8000에서 실행되고 React서버는 127.0.0.1:3000에서 실행된다.\r\n두 서버의 포트번호가 다르기때문에 CORS 에러가 발생!\r\n\r\n### 2. Django project의 settings.py 에 추가\r\n\r\n```python\r\n\r\n  ALLOWED_HOSTS = ['*']\r\n\r\n  INSTALLED_APPS = [\r\n\r\n    #   DRF\r\n    'rest_framework',\r\n\r\n    #CORS\r\n    'corsheaders',\r\n\r\n]\r\n\r\n# 사이트 간 HTTP 요청을 할 수 있는 권한이 있는 출처 목록\r\nCORS_ALLOWED_ORIGINS = [\r\n    'http://127.0.0.1:8000',\r\n    'http://localhost:3000',\r\n]\r\n\r\n# True이면 사이트 간 HTTP 요청에 쿠키를 포함할 수 있다. default값은 false.\r\nCORS_ALLOW_CREDENTIALS = True\r\n\r\n\r\nMIDDLEWARE = [\r\n    'corsheaders.middleware.CorsMiddleware',\r\n]\r\n\r\nTEMPLATES = [\r\n    {\r\n        'DIRS': [\r\n            os.path.join(BASE_DIR, 'frontend', 'build'), #리액트 템플릿 연결\r\n        ],\r\n    },\r\n]\r\n\r\nSTATICFILES_DIR = [\r\n    os.path.join(BASE_DIR, 'frontend','build','static'),\r\n]\r\n```\r\n\r\n**CORS_ALLOWED_ORIGINS**\r\n접근 가능한 출처명을 적는 리스트 CORS_ALLOWED_ORIGIN_REGEXES 를 사용해서 정규식으로 표현할수도 있다.\r\n\r\n```python\r\nCORS_ALLOWED_ORIGIN_REGEXES  =  [\r\n    r \"^https://\\w+\\.example\\.com$\" ,\r\n]\r\n```\r\n\r\n### 3. manage.py 수정\r\n\r\n```python\r\n\r\ndef main():\r\n    \"\"\"Run administrative tasks.\"\"\"\r\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')\r\n    try:\r\n        from django.core.management import execute_from_command_line\r\n    except ImportError as exc:\r\n        raise ImportError(\r\n            \"Couldn't import Django. Are you sure it's installed and \"\r\n            \"available on your PYTHONPATH environment variable? Did you \"\r\n            \"forget to activate a virtual environment?\"\r\n        ) from exc\r\n\r\n    try: #try문 하나 더 추가\r\n        if sys.argv[2] == 'react': #python [0]:manage.py [1]:runserver [2]:react\r\n            project_root = os.getcwd()\r\n            os.chdir(os.path.join(project_root, \"frontend\"))\r\n            os.system(\"npm run build\")\r\n            os.chdir(project_root)\r\n            sys.argv.pop(2)\r\n    except IndexError:\r\n        execute_from_command_line(sys.argv)\r\n    else:\r\n        execute_from_command_line(sys.argv)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\n추가한 try문으로 python manage.py runserver react로 리액트 서버까지 연결된 상태로 실행이 가능해진다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}