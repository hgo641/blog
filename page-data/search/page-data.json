{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"멋쟁이 사자처럼 X 넥슨 MOD의 2주차 교육 내용을 정리하는 포스트입니다. 자주 쓰이는 Component TransformComponent entity들이 어디에 위치하는가 entity의 위치, 크기, 회전등을 결정할 수 있다 SpriteRendererComponent Sprite : 2D 이미지를 뜻함 entity가 어떻게 그려질지를 정함 entity…","fields":{"slug":"/component-basic/"},"frontmatter":{"date":"May 21, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 2주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n<br/>\r\n\r\n멋쟁이 사자처럼 X 넥슨 MOD의 2주차 교육 내용을 정리하는 포스트입니다.\r\n\r\n<br/>\r\n\r\n\r\n\r\n## 자주 쓰이는 Component\r\n\r\n### TransformComponent\r\n\r\n> entity들이 어디에 위치하는가\r\n>\r\n> entity의 위치, 크기, 회전등을 결정할 수 있다\r\n\r\n\r\n\r\n### SpriteRendererComponent\r\n\r\n> Sprite : 2D 이미지를 뜻함\r\n>\r\n> entity가 어떻게 그려질지를 정함\r\n>\r\n> entity의 색상, 레이어, 프레임등을 결정할 수 있다\r\n\r\n* 스프라이트마다 고유한 RUID 값을 가지고 있다\r\n* RUID 값을 이용해 빈 모델에 스프라이트를 넣거나 변경할 수 있다\r\n\r\n\r\n\r\n### TweenComponet\r\n\r\n> entity의 움직임을 결정한다\r\n>\r\n> * TweenLineComponent : 원점에서 목적지까지 선형운동\r\n> * TweenFloatingComponent : 원점을 기준으로 부유운동\r\n> * TweenCircularComponent : 원점을 중심으로 원운동\r\n\r\n\r\n\r\n## 맵 레이어\r\n\r\n* 하나의 맵에 최대 10개의 레이어 사용 가능\r\n* 레이어 창 가장 아래에 깔린 레이어가 맵 화면에서 가장 뒤에 위치하게 되고, 맨 위에 있는 레이어가 가장 앞에 배치된다\r\n* 레이어에 배치된 엔티티들은 레이어 순서에 일괄적으로 영향을 받습니다. 가장 아래 있던 레이어를 위로 올리는 순간, 엔티티의 순서가 함께 변경된다\r\n\r\n\r\n\r\n### 레이어 우선순위 \r\n\r\n1. Map Layer (SpriteRendererComponent의 SortingLayer)\r\n2. SpriteRenderer Component의 OrderInLayer 프로퍼티\r\n3. Transform Component의 Position Z값\r\n\r\n\r\n\r\n### 모델의 레이어 순서\r\n\r\n> 모델은 배치 편의를 위해 유형별로 OrderInLayer 기본값이 존재한다\r\n\r\n![](./orderinlayer.png)\r\n\r\n\r\n\r\n| OrderInLayer 값 | 모델 유형                                           |\r\n| --------------- | --------------------------------------------------- |\r\n| 0               | 오브젝트                                            |\r\n| 1               | 타일                                                |\r\n| 2               | 몬스터, NPC, 발판, 사다리, 로프, 포탈, 트랩, 아이템 |\r\n| 3               | 타 이용자의 아바타                                  |\r\n| 4               | 나의 아바타                                         |\r\n\r\n\r\n\r\n\r\n\r\n## 발판 만들기\r\n\r\n#### 발판\r\n\r\n* 캐릭터가 오를 수 있는, 밟을 수 있는 타일을 표시\r\n\r\n* 세팅 -> 만들기 -> 발판\r\n\r\n* Foothold가 있는 모델들은 `우클릭` -> `edit foothold` 를 사용해 풋홀드 위치를 변경할 수 있음\r\n* `CustomFootholdComponent`를 사용해 Foothold가 없는 모델에도 발판을 생성할 수 있다\r\n\r\n* 마찰력 속도등 풋홀드 속성이 존재한다\r\n\r\n\r\n\r\n## 충돌 감지\r\n\r\n* HitComponent : 피격의 범위를 설정\r\n* TriggerComponent : 충돌이 일어나는 범위를 설정\r\n\r\n\r\n\r\n### 충돌 이벤트 생성 방법\r\n\r\n* TriggerComponent를 사용해 충돌의 범위를 설정한다\r\n* 핸들러를 만들어서 충돌시 액션을 정의한다\r\n* 액션을 수행할 핸들러를 Entity에 등록한다\r\n\r\n> 위 절차를 통해 TriggerComponent를 통해 이벤트가 발생하면 핸들러로 등록한 함수가 호출되 충돌시 액션을 수행한다!\r\n\r\n![](./triggersystem.png)\r\n\r\n\r\n\r\n### 핸들러 생성\r\n\r\n* 핸들러는 리액터가 되는 스크립트 컴포넌트의 Entity Event Handler를 통해 추가할 수 있다\r\n\r\n* 액션을 수행할 스크립트 컴포넌트를 열고, Entity Event Handler의 우측 버튼을 눌러 핸들러 추가 메뉴를 오픈한다\r\n\r\n​\t<br/>![](./add_handler.png)\r\n\r\n<br/>\r\n\r\n* 충돌 이벤트에 대한 핸들러를 생성하기위해 Trigger관련 Event를 추가한다\r\n* 검색창을 이용해 편리하게 이벤트를 찾을 수 있다\r\n\r\n<br/>\r\n\r\n![](./search_event.png)\r\n\r\n| Event             | 발생 시점               |\r\n| ----------------- | ----------------------- |\r\n| TriggerEnterEvent | 충돌이 처음 발생했을 때 |\r\n| TriggerStayEvent  | 충돌이 일어나는 중일 때 |\r\n| TriggerLeaveEvent | 충돌이 끝났을 때        |\r\n\r\n\r\n\r\n*다음은 충돌시 hp가 하락하는 이벤트이다*\r\n\r\n![](./hp_event.png)\r\n\r\n상단의 `self`는 sender를 등록할 entity를 설정할 수 있다\r\n\r\n리액터 컴포넌트가 추가된 entity의 충돌 이벤트를 받는다면 self를,\r\n\r\n다른 외부 entity의 충돌 이벤트를 받는다면 `self`를 눌러`Entity`를 선택한 후 해당 entity로 바꿔주면된다\r\n"},{"excerpt":"멋쟁이 사자처럼 X 넥슨 MOD의 1주차 교육 내용을 정리하는 포스트입니다. Entity  맵을 구성하고있는 요소들 ex) npc, monster, tree object 등 아래 빨간 네모 박스안에 있는 것들이 전부 Entity  entity는 여러 개의 component로 구성되어있다 Scene Maker에서 관리 가능 Component 기능의 단위들 …","fields":{"slug":"/mod-concept/"},"frontmatter":{"date":"May 20, 2022","title":"멋쟁이사자처럼 X 넥슨 MOD Suppoters Hackathon 1주차 회고","tags":["mod"]},"rawMarkdownBody":"\r\n<br/>\r\n\r\n멋쟁이 사자처럼 X 넥슨 MOD의 1주차 교육 내용을 정리하는 포스트입니다.\r\n\r\n<br/>\r\n\r\n## Entity\r\n\r\n>  맵을 구성하고있는 요소들\r\n>\r\n> ex) npc, monster, tree object 등\r\n\r\n<br/>\r\n\r\n*아래 빨간 네모 박스안에 있는 것들이 전부 Entity*\r\n\r\n![](./entity.png)\r\n\r\n* entity는 여러 개의 component로 구성되어있다\r\n\r\n- Scene Maker에서 관리 가능\r\n\r\n\r\n\r\n## Component\r\n\r\n**기능의 단위들**\r\n\r\n* Entity는 Component들로 구성되어 있다 \r\n* Component들의 집합체를 Entity라고 볼 수 있다\r\n* Component는 각각의 요소를 담당하고 있으며 각각의 기능을 담당한다\r\n\r\nex)\r\n\r\n>* TransformComponent : entity의 위치, 회전 각도등을 결정함\r\n>* SpriteRendererComponent : entity를 어떻게 보여줄 것인지를 결정함\r\n>  * entity의 색상\r\n>  * entity가 속한 Layer\r\n>  * 움직이는 애니메이션 객체일 경우 Frame 수, 재생 속도등을 결정\r\n\r\n\r\n\r\n## Property\r\n\r\n> 컴포넌트 내에 있는 세부적인 정보, 고유 특성을 정의한다\r\n\r\n*아래는 ChatBalloonComponent의 Property들이다*\r\n\r\n![](./property.png)\r\n\r\n* 말풍선의 기능을 가진 `ChatBalloonComponent`의 Property `FontSize`를 조정해 말풍선안의 폰트 크기를 높인다\r\n\r\n\r\n\r\n## Model\r\n\r\n<p>\r\n    <img src =\"./model_list.png\" style= \"float:left; margin-right: 50px; margin-top : 10px\"/>\r\n</p>\r\n\r\nentity를 생성할 수 있는 원본\r\n\r\nMOD 메이커를 실행한 뒤 좌측 Model List 패널에서 확인할 수 있다.\r\n\r\nModel List에 있는 model object 가져와 entity로 만들어 맵을 꾸밀 수 있다\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Work Space\r\n\r\n파일탐색기와 비슷한 기능\r\n\r\n모델, 스크립트 파일, 컴포넌트등을 관리\r\n\r\nScene에서 사용된 컴포넌트들의 원본이 저장됨\r\n\r\n\r\n\r\n## Scene Maker\r\n\r\n- 씬 메이커는 계층구조로 되어있다\r\n\r\n- 부모 오브젝트를 움직이면 자식 오브젝트도 같이 움직인다\r\n\r\n- 씬 메이커에서 자식은 부모의 특성을 물려받는다\r\n\r\n- 자식의 특성보다 부모의 특성이 우선시 된다\r\n\r\n  - ex) 자식은 visible이지만 부모가 invisible이라면 자식또한 invisible한 상태가 된다\r\n\r\n- 현재 Scene에서 사용한 모든 오브젝트들을 볼 수 있음\r\n\r\n  `Make Original Model` 기능을 통해 원본 오브젝트에서 크기등이 변경된 오브젝트를 변경된 형태로 Workspace에 저장할 수 있음\r\n\r\n  -> 만들어진 엔티티를 모델로 생성\r\n\r\nModserivice : 재가공 불가능 Core한 서비스\r\n\r\nModlogic : 재가공 가능. 유저가 생성 가능\r\n\r\n\r\n\r\n## 기본 조작\r\n\r\n- 프로젝트 출시\r\n\r\n  `File` -> `Publish`\r\n\r\n- 프로젝트 버전 기록 및 관리\r\n\r\n `File` -> `Revisions`\r\n\r\n- 패널 세팅 초기화\r\n\r\n `Panel` -> `Reset Panels`\r\n\r\n- Map 리스트 보기 및 관리\r\n\r\n  `Window` -> `Map list`\r\n\r\n- 메이플스토리 맵 불러오기\r\n\r\n  `Window` -> `MapleStory Map`\r\n\r\n- 스크립트 샘플 다운로드\r\n\r\n  `Window` -> `Script Manager`\r\n\r\n수직으로 생성된 타일은 캐릭터가 올라갈 수 없다\r\n\r\n하나의 레이어에서는 하나의 타일만 사용가능하다\r\n\r\n여러 개의 타일을 사용하고싶다면 Map Layer를 추가해야함\r\n\r\nMap Layer란의 상위 레이어가 Scene의 가장 앞에 배치된다\r\n\r\n배치 순서는 Property -> SpriteRendererComponent -> OrderLayer에서 설정가능\r\n\r\n- 사용자 정의 오브젝트 그룹 생성\r\n\r\n `Object` -> `새 그룹 추가`\r\n\r\n\r\n\r\n"},{"excerpt":"docker란  어떤 서비스를 개발할 때 필요한 패키지, 라이브러리들을 다른 서버에서 재설치를 하지않고 충돌없이 사용할 수 있게 해주는 서비스 docker image 리눅스 환경에서 사용가능한 패키지, 라이브러리들을 컴퓨터로 다운받을 수 있게 저장해둔 것 docker component docker image를 가지고 컴퓨터에 생성한 독립적인 작업 공간 를…","fields":{"slug":"/docker-concept/"},"frontmatter":{"date":"May 17, 2022","title":"docker 개념","tags":["docker"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n## docker란\r\n\r\n>  어떤 서비스를 개발할 때 필요한 패키지, 라이브러리들을 다른 서버에서 재설치를 하지않고 충돌없이 사용할 수 있게 해주는 서비스\r\n\r\n\r\n\r\n### docker image\r\n\r\n> 리눅스 환경에서 사용가능한 패키지, 라이브러리들을 컴퓨터로 다운받을 수 있게 저장해둔 것\r\n\r\n\r\n\r\n### docker component\r\n\r\n> docker image를 가지고 컴퓨터에 생성한 독립적인 작업 공간\r\n\r\n`docker image`를 가지고 여러 개의 `component`를 생성할 수 있다\r\n\r\n\r\n\r\n### docker volume\r\n\r\n> 컨테이너와 내 컴퓨터의 특정 폴더를 공유하는걸 의미\r\n\r\n\r\n\r\n### docker compose\r\n\r\n> 각각의 component들을 하나로 묶음\r\n\r\n\r\n\r\n### 간단한 docker 실습\r\n\r\n#### docker 기본 명령어\r\n\r\n* 도커 버전 확인\r\n\r\n```bash\r\ndocker -v\r\n```\r\n\r\n\r\n\r\n* 도커 이미지 다운만 받기\r\n\r\n```bash\r\ndocker pull {img_name}:{tag}\r\n# 태그는 필수 요소가 아님\r\n```\r\n\r\n\r\n\r\n* 컴퓨터 내 도커 이미지들 보기\r\n\r\n```bash\r\ndocker images\r\n```\r\n\r\n\r\n\r\n* 이미지로 컨테이너 생성하기\r\n\r\n```bash\r\ndocker create {option} {img_name}:{tag}\r\n# ex) docker crate -it python\r\n```\r\n\r\n\r\n\r\n* 만들어진 컨테이너 시작하기 (이미지에 CMD로 지정해놓은 작업 시키기)\r\n\r\n```bash\r\ndocker start {container_id or name}\r\n```\r\n\r\n\r\n\r\n* 컨테이너로 들어가기 (컨테이너 내 CLI 이용하기)\r\n\r\n```bash\r\ndocker attach {container_id or name}\r\n```\r\n\r\n\r\n\r\n* (해당 이미지가 없다면) 이미지를 다운받아 바로 컨테이너 실행하여 진입하기\r\n\r\n```bash\r\ndocker run {img_name}:{tag}\r\n# ex) docker -it run python:3\r\n# pull, create, start, attach를 한 번에 실행하는 것과 같다\r\n```\r\n\r\n\r\n\r\n| 옵션                                  | 설명                                                         |\r\n| :------------------------------------ | ------------------------------------------------------------ |\r\n| -d                                    | 데몬으로 실행(백그라운드에서 알아서 돌라고 하기)             |\r\n| -it                                   | 컨테이너로 들어갔을 때 bash로 CLI 입출력을 사용할 수 있도록 해줌 |\r\n| --name {container_name}               | 컨테이너 이름 지정                                           |\r\n| -p {port of host}:{port of container} | 호스트와 컨테이너의 포트를 연결                              |\r\n| --rm                                  | 컨테이너가 종료되면 컨테이너 제거                            |\r\n| -v {dir of host}:{dir of container}   | 호스트와 컨테이너의 디렉토리를 연결                          |\r\n\r\n\r\n\r\n* 동작중인 컨테이너 재시작\r\n\r\n```bash\r\ndocker restart {container_id or name}\r\n```\r\n\r\n\r\n\r\n* 도커 컨테이너 내부 쉘에서 빠져나오기 (컨테이너를 종료)\r\n\r\n```bash\r\nexit\r\n# 또는  ctrl + d\r\n```\r\n\r\n\r\n\r\n* 도커 컨테이너 내부 쉘에서 빠져나오기 (컨테이너를 종료하지 않음)\r\n\r\n  * ctrl + P + Q\r\n\r\n    \r\n\r\n* 동작중인 컨테이너 목록보기\r\n\r\n```bash\r\ndocker ps\r\n# 동작하지않는 컨테이너까지 모두 보려면 docker ps -a\r\n```\r\n\r\n\r\n\r\n* 컨테이너 삭제\r\n\r\n```bash\r\ndocker rm {container_id or name}\r\n\r\n# 모든 컨테이너 삭제\r\n# docker rm `docker ps -a -q`\r\n```\r\n\r\n\r\n\r\n* 이미지 삭제\r\n\r\n```bash\r\ndocker rm {option} {img_id}\r\n# 컨테이너가 있을시 강제 삭제 : 옵션 -f 사용\r\n```\r\n\r\n\r\n\r\n* 모든 컨테이너와 이미지 등 도커 요소 중지 및 삭제\r\n\r\n```bash\r\n# 모든 컨테이너 중지\r\ndocker stop $(docker ps -aq)\r\n\r\n# 사용되지 않는 모든 도커 요소(컨테이너, 이미지, 네트워크, 볼륨 등) 삭제\r\ndocker system prune -a\r\n```\r\n\r\n\r\n\r\n* 도커 파일로 이미지 생성\r\n\r\n```bash\r\n# Dockerfile 파일이 있는 디렉토리 기준.  마지막의 . 이 상대주소\r\ndocker build -t {이미지명} .\r\n```\r\n\r\n\r\n\r\n* 도커 컴포즈 실행\r\n\r\n```bash\r\n# docker-compose 파일이 있는 디렉토리 기준\r\ndocker-compose up\r\n# 백그라운드에서 데몬으로 돌게 하려면 옵션 -d를 붙임\r\n```\r\n\r\n\r\n\r\n#### Dockerfile\r\n\r\n\r\n\r\n\r\n\r\n"},{"excerpt":"PM2란? 무중단 서버 실행 멀티스레딩 Daemon Process Manager 보통 Node.js 와 같이 사용되며 Node.js 어플리케이션을 쉽게 관리할 수 있게 해주는 Process Manager이다 Node.js 어플리케이션은 단일 CPU 코어에서 실행되기 때문에 CPU의 멀티코어 시스템은 사용할 수 없다 때문에 Node.js는 클러스터 모듈을 …","fields":{"slug":"/pm2/"},"frontmatter":{"date":"May 16, 2022","title":"django에서 pm2 사용하기","tags":["deploy"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n## PM2란?\r\n\r\n* 무중단 서버 실행\r\n* 멀티스레딩\r\n\r\n**Daemon Process Manager**\r\n\r\n> 보통 Node.js 와 같이 사용되며 Node.js 어플리케이션을 쉽게 관리할 수 있게 해주는 Process Manager이다\r\n>\r\n> Node.js 어플리케이션은 단일 CPU 코어에서 실행되기 때문에 CPU의 멀티코어 시스템은 사용할 수 없다\r\n>\r\n> 때문에 Node.js는 클러스터 모듈을 통해 단일 프로세스를 멀티 프로세스로 늘릴 수 있는 방법을 제공한다\r\n>\r\n> 유저는 클러스터 모듈을 사용해 마스터 프로세스에서 워커 프로세스를 생성할 수 있다\r\n>\r\n> 이를 도와주는 것이 PM2이며 PM2를 사용해 하이퍼 스레딩 및 무중단 서비스 제공이 가능해진다 \r\n\r\nPM2를 Django 프로젝트에서 사용해보자!\r\n\r\n\r\n\r\n#### 🔨 node 설치\r\n\r\n```idl\r\n$ sudo apt install nodejs\r\n```\r\n\r\n\r\n\r\n#### 🔨 npm 설치\r\n\r\n```idl\r\n$ sudo apt install npm\r\n# $ sudo npm install npm@latest -g\r\n```\r\n\r\n\r\n\r\n#### 🔨 pm2 설치\r\n\r\n```idl\r\n$ sudo npm install pm2 -g\r\n```\r\n\r\n\r\n\r\n#### 🔨 프로젝트 하위에 json 파일 생성 및 작성\r\n\r\n```idl\r\n$ vim pm2-appname.json\r\n```\r\n\r\n\r\n\r\n\\# project/pm2-appname.json\r\n\r\n```json\r\n{ \"apps\": \r\n \t[\r\n        { \"name\": \"djnago_with_pm2\", \r\n         \"script\": \"manage.py\", \r\n         \"args\": [\"runserver\", \"0.0.0.0:8000\"],\r\n         \"exec_mode\": \"fork\", \r\n         \"exec_interpreter\" : \"python\" }\r\n    ] \r\n}\r\n```\r\n\r\n* args 에는 django 프로젝트를 배포할 때 쓰는 명령어 args를 넣는다\r\n\r\n\r\n\r\n#### 🔨 pm2 start\r\n\r\n```idl\r\n$ pm2 start pm2-appname.json\r\n```\r\n\r\n* 작성한 json파일을 실행\r\n\r\n![](./pc2list.png)\r\n\r\n> * pm2 stop all : 모든 서버 중지\r\n> * pm2 stop {pid} : 해당 pid 서버 중지\r\n\r\n"},{"excerpt":"Python 라이브러리 requests method 4가지에 따라 api 제공 GET : requests.get() POST : requests.post() PUT : requests.put() DELETE : requests.delete() status_code content text json() headers params get 방식으로 HTTP 요청…","fields":{"slug":"/requests/"},"frontmatter":{"date":"May 16, 2022","title":"python 라이브러리 requests","tags":["python"]},"rawMarkdownBody":"\r\n\r\n\r\n## Python 라이브러리 requests\r\n\r\nmethod 4가지에 따라 api 제공\r\n\r\n* GET : requests.get()\r\n* POST : requests.post()\r\n* PUT : requests.put()\r\n* DELETE : requests.delete()\r\n\r\n\r\n\r\n### status_code\r\n\r\n```python\r\nresponse = requests.get(\"http://localhost:8000\")\r\nresponse.status_code # 200, 404 ...\r\n```\r\n\r\n\r\n\r\n### content\r\n\r\n```python\r\nresponse.content\r\n# 바이너리 원문을 가져옴\r\n```\r\n\r\n\r\n\r\n### text\r\n\r\n```py\r\nresponse.text\r\n# UTF-8로 인코딩된 문자열\r\n```\r\n\r\n\r\n\r\n### json()\r\n\r\n```py\r\nresponse.json()\r\n# 응답 데이터가 JSON포맷이라면 딕셔너리 객체 반환\r\n```\r\n\r\n\r\n\r\n### headers\r\n\r\n```python\r\nresponse.headers\r\n# {'Date': 'Sat, 16 May 2022 21:10:49 GMT', 'Content-Type': 'application/json; charset=utf-8', ...}\r\n# 헤더 정보를 딕셔너리 객체로 반환\r\n```\r\n\r\n\r\n\r\n### params\r\n\r\n* get 방식으로 HTTP 요청을 할 때는 쿼리 스트링을 통해 응답받을 데이터를 필터링하는 경우가 많다\r\n* params 옵션을 사용하면 쿼리 스트링을 사전의 형태로 넘길 수 있다\r\n\r\n\\# youtube data api 예제\r\n\r\n```python\r\nparams = {\r\n    \"key\": \"my_secret_key\",\r\n    'chart': 'mostPopular',\r\n    \"part\": [\"snippet\", \"statistics\"],\r\n    \"regionCode\" : \"KR\",\r\n    \"maxResults\": 10,\r\n}\r\n\r\nresponse = requests.get(url, params=params)\r\n```\r\n\r\n\r\n\r\n### url\r\n\r\n```py\r\nparams = {\r\n    \"key\": \"my_secret_key\",\r\n    'chart': 'mostPopular',\r\n    \"part\": [\"snippet\", \"statistics\"],\r\n    \"regionCode\" : \"KR\",\r\n    \"maxResults\": 10,\r\n}\r\n\r\nresponse = requests.get(url, params=params)\r\nresponse.url\r\n# https://www.googleapis.com/youtube/v3/videos?key={my_secret_key}&chart=mostPopular&part=snippet&part=statistics&regionCode=KR&maxResults=10\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### data\r\n\r\n* post나 put방식으로 HTTP 요청을 할 때는 request body에 데이터를 담아서 보낸다\r\n* data 옵션을 사용하면 `HTML 양식(form)` 포맷의 데이터를 전송할 수 있으며 이 때 `Content-Type` 요청 헤더는 `application/x-www-form-urlencoded`로 자동 설정된다\r\n\r\n```py\r\nrequests.post(\"https://localhost:8000/post\", data={'title': 'title1', 'text':'hi~'})\r\n```\r\n\r\n\r\n\r\n### json\r\n\r\n* json 옵션을 사용하면 REST API로 `JSON` 포맷의 데이터를 전송할 수 있으며 이때 `Content-Type` 요청 헤더는 `application/json`으로 자동 설정된다\r\n\r\n```py\r\nrequests.post(\"https://localhost:8000/post\", json={'title': 'title1', 'text':'hi~'})\r\n```\r\n\r\n\r\n\r\n### headers\r\n\r\n* headers옵션을 사용해서 요청 헤더도 설정할 수 있다\r\n* 인증 토큰을 보낼 때 유용하게 사용된다\r\n"},{"excerpt":"termius에서 git clone {repo_name} 중 git access tokens 문제 발생 원래 id와 pw를 치고 인증하는데 pw가 아니라 access token을 입력하는 방법으로 바뀜 Access token 발급 방법 github > settings  메뉴의 가장 아래에 있는  클릭 메뉴의 Personal access tokens 클릭해…","fields":{"slug":"/access-token/"},"frontmatter":{"date":"May 16, 2022","title":"git access token ¹ß±Þ","tags":["git"]},"rawMarkdownBody":"\r\n\r\n\r\n\r\n\r\n* termius에서 git clone {repo_name} 중 git access tokens 문제 발생\r\n* 원래 id와 pw를 치고 인증하는데 pw가 아니라 access token을 입력하는 방법으로 바뀜\r\n\r\n\r\n\r\n## Access token 발급 방법\r\n\r\n\r\n\r\n1. github > settings \r\n\r\n2. 메뉴의 가장 아래에 있는 `Developer settings` 클릭\r\n\r\n3. 메뉴의 Personal access tokens 클릭해서 token 생성\r\n\r\n4. 생성한 후 보여주는 token값을 저장해서 github인증시 pw대신 token을 입력하면 성공!\r\n\r\n   > token값은 처음 생성할 때 한 번만 보여주므로 주의\r\n   >\r\n   > 물론 까먹어도 다시 발급하면됨\r\n\r\n"},{"excerpt":"Viewset url등록 메소드별로 수동으로 지정 router 사용 메소드별로 수동 지정 as_view에 인자를 넣어 설정한다 urls.py 이처럼 메소드별로 수동으로 지정할 수 있다 viewset에서 제공하는 기능 create retrieve update partial_update destroy list router 사용 의  url은 으로 연결된다 의…","fields":{"slug":"/viewset-url/"},"frontmatter":{"date":"May 16, 2022","title":"viewset url 등록","tags":["django","DRF"]},"rawMarkdownBody":"\r\n\r\n\r\n## Viewset url등록\r\n\r\n* 메소드별로 수동으로 지정\r\n* router 사용\r\n\r\n\r\n\r\n#### 메소드별로 수동 지정\r\n\r\n* as_view에 인자를 넣어 설정한다\r\n\r\n#urls.py\r\n\r\n```python\r\nfrom . import views\r\n\r\ntutor_list = views.TutorVideoViewSet.as_view({'get' : 'list'})\r\n# get 요청이 오면 viewset의 list함수 실행\r\n\r\ntutor_detail = views.TutorVideoViewSet.as_view({'get':'retrieve'})\r\n# get 요청이 오면 view set의 retrieve 함수 실행\r\n\r\nurlpatterns = [\r\n    path('tutor/', tutor_list, name = 'tutor_list'),\r\n    path('tutor/<int:pk>/', tutor_detail, name = 'tutor_detail')\r\n]\r\n```\r\n\r\n이처럼 메소드별로 수동으로 지정할 수 있다\r\n\r\n> viewset에서 제공하는 기능\r\n>\r\n> * create\r\n> * retrieve\r\n> * update\r\n> * partial_update\r\n> * destroy\r\n> * list\r\n\r\n\r\n\r\n#### router 사용\r\n\r\n```python\r\nfrom rest_framework import routers\r\n\r\nrouter = routers.DefaultRouter()\r\nrouter.register('dancing',views.TutorVideoViewSet)\r\nrouter.register('practice',views.TuteeVideoViewSet)\r\n\r\nurlpatterns = [\r\n    path('',include(router.urls)),\r\n]\r\n```\r\n\r\n* `TutorVideoViewSet`의  url은 `~/dancing`으로 연결된다\r\n* `TuteeVideoViewSet`의 url은 `~/practice`로 연결된다\r\n\r\n"},{"excerpt":"zip iterable 자료형의 요소를 순서대로 묶어서 새로운 iterable 자료형을 생성한다. iterable : 문자열, 리스트, 튜플과 같이 반복 가능한 자료형 조건 : 요소 개수가 같아야 함 class 'zip'을 바로 print할 수 없고 dict이나 list등으로 형변환을 시켜서 출력한다 # zip으로 list생성 # zip으로 dict생성","fields":{"slug":"/zip/"},"frontmatter":{"date":"May 12, 2022","title":"zip","tags":["python"]},"rawMarkdownBody":"\r\n## zip\r\n\r\n- iterable 자료형의 요소를 순서대로 묶어서 새로운 iterable 자료형을 생성한다.\r\n\r\n  > iterable : 문자열, 리스트, 튜플과 같이 반복 가능한 자료형\r\n\r\n- 조건 : 요소 개수가 같아야 함\r\n\r\n- class 'zip'을 바로 print할 수 없고 dict이나 list등으로 형변환을 시켜서 출력한다\r\n\r\n\\# zip으로 list생성\r\n\r\n```python\r\norder =\"123\"\r\nanimals = ['lion','cat','dog']\r\nfruit = ['mandarin','strawberry','apple']\r\nzip_list = zip(order, animals, fruits)\r\nprint(list(zip_list))\r\n```\r\n\r\n\\# zip으로 dict생성\r\n\r\n```python\r\norder = \"123\"\r\nanimals = ['lion', 'cat', 'dog']\r\nzip_dict = zip(order, animals)\r\nprint(dict(zip_dict))\r\n```\r\n"},{"excerpt":"중첩 사용 list comprehension vs zip","fields":{"slug":"/list-comprehension/"},"frontmatter":{"date":"May 12, 2022","title":"list comprehension","tags":["python"]},"rawMarkdownBody":"\r\n## 중첩 사용\r\n\r\n```python\r\ntemp = [i*j for i in range(1,4) for j in range(1,5)]\r\n\r\ntemp = []\r\nfor i in range(1,4):\r\n    for j in range(1,5):\r\n        temp.append(i*j)\r\n```\r\n\r\n## list comprehension vs zip\r\n\r\n```python\r\ntarget = [0.6, 0.8, 0.5]\r\nactual = [0.726, 0.708, 0.778]\r\n\r\nprint([target[i]-actual[i] for i in range (len(target))])\r\nprint([x-y for x,y in zip(target, actual)])\r\n```\r\n"},{"excerpt":"mutual exclusion을 방지하려면? 현실적이지않음 mutual exclusion이 필요해서 하는건데... no preemption 이것도 현실적으로 쉽지않음 no hold and wait 원래는 다른애가 가지고 있으면 무한정 기다려야하는데 한꺼번에 획득하면 기다릴일이 없음 아예 가져가거나 못가져가거나 atomic한듯 no circular wait…","fields":{"slug":"/11-2/"},"frontmatter":{"date":"May 11, 2022","title":"os 11-2","tags":["OS"]},"rawMarkdownBody":"\r\n#### mutual exclusion을 방지하려면?\r\n\r\n현실적이지않음\r\n\r\nmutual exclusion이 필요해서 하는건데...\r\n\r\n#### no preemption\r\n\r\n이것도 현실적으로 쉽지않음\r\n\r\n#### no hold and wait\r\n\r\n원래는 다른애가 가지고 있으면 무한정 기다려야하는데\r\n\r\n한꺼번에 획득하면 기다릴일이 없음\r\n\r\n아예 가져가거나 못가져가거나\r\n\r\natomic한듯\r\n\r\n#### no circular wait\r\n\r\ncircular wait를 만들지않으려면 모든 리소스에 번호를 부여\r\n\r\n리소스를 할당받을 때 낮은 번호의 리소스부터 할당받게한다\r\n\r\n누군가가 높은 번호를 가진 상태에서 낮은 번호를 요구할 일이 없음. 모든 리소스 할당이 낮은 순서부터되기때문에 아예 할당을 못받거나 순차적으로 할당을 받거나\r\n\r\n자연스럽게 circular wait이 해결된다\r\n\r\n모든 프로세스들은 순서에 맞춰서 리소스를 할당받는다 근데 사실상 이것도 어려움\r\n\r\n1. 몇 개의 리소스가 있는지도 모름\r\n\r\n2. 시스템마다 리소스 수가 다를 것\r\n\r\n3. os가 일정한 order를 가지고 순서를 부여학 쉽지않음\r\n\r\n4. 새로운 리소스가 추가되면 어떻게 할 것인지\r\n\r\n   단순하게 i+1?\r\n\r\n   근데 얘가 굉장히 중요한 리소스라면?\r\n\r\n이론적으로는 괜찮으나 실질적으로 어렵다\r\n\r\n## Deadlock Avoidance -\r\n\r\n시스템이 추가적인 정보 요구 : a prior information\r\n\r\n사전 정보 필요\r\n\r\n- maximun number of resource : 그들이 동시에? 사용하고자하는 최대 리소스의 개수를 미리 개재\r\n\r\n-살짝놓침-\r\n\r\n### Banker's Algorithm\r\n\r\n시스템은 state를 safe state와 unsage state로 나눔\r\n\r\n- Safe state : 어떤한 형태에도 데드락이 발생안함\r\n\r\n- Unsafe state : 데드락이 발생할수도있음\r\n\r\nP : 프로세스 n개의 set\r\n\r\nR : 리소스 m개의 set\r\n\r\nsafe state인지를 어떻게 볼까\r\n\r\n#### 전제조건\r\n\r\n- 각각의 프로세스는 사전에 maximum use를 고지해야함\r\n\r\n- 프로세스는 기다릴 수 있어야함\r\n\r\n- 프로세스가 한 번 리소스를 가져가면 주어진 시간안에 반환을 해야함\r\n\r\n#### Notation\r\n\r\n- n : 프로세스의 개수\r\n- m : 리소스의 개수\r\n- Available[1:m] 리소스마다 몇 개가 사용 가능한지\r\n- Max[1:n, 1:m] : n x m 행렬, 각 프로세스가 최대로 필요로 하는 리소스 개수\r\n- Allocation[1:n, 1:m] : 현재 각 프로세스들에게 할당된 리소스\r\n- Need[1:n, 1:m] : 각 프로세스들에게 필요한 리소스들 (Max - Allocation)\r\n\r\n알고리즘 두 가지\r\n\r\n- safety algorithm : 현재 safe인지 unsafe인지 판별\r\n- Resource-Request Algorithm : 새로운 리퀘스트가 왔을 때, 이 리퀘스트를 들어주면 safe인지 unsafe인지 판별 (safety algorithm 사용)\r\n\r\n### Safety Algorithm\r\n\r\nAvailabe보다 Need가 더 작은애들은 언제든지 일을 할 수 있음\r\n\r\nP1을 먼저 선택\r\n\r\n이전 : 2 0 0\r\n\r\n추가 : 1 2 2\r\n\r\nAvaiable + 이전꺼 반납 (2개 반납)\r\n\r\nFinish : 해당 프로세스가 끝났는지\r\n\r\nAvailable == Work\r\n\r\n캬아악! 헷갈려\r\n\r\n### Resource Request Algorithm\r\n\r\n리퀘스트를 받았다고 가정하고 safety algorithm을 돌려봄\r\n\r\n### 한계\r\n\r\n1. Rj가 얼마나 될지 정확하게 알기 힘듦\r\n2. Process 수가 가변적임\r\n3. 미리 maximum use를 고지하기 힘듦\r\n\r\n그래서 사용되진않음 ㅎ\r\n\r\n사실 데드락을 크게 고려안함... 왜?!\r\n\r\n데드락이 발생하면 pc사용자가 바로 인지할 수 있음\r\n\r\n무한뤂프 돌면서 뻗을때... 걍 작업관리자 켜서 종료함\r\n\r\n오잉~ 나 스스로 데드락 종료 ?!\r\n\r\n그래서 엄청나게 중요한 문제는 아님\r\n\r\n유저가 개입할 수 없는 서버시스템, misstion critical system(자율자동차)...에서는 중요한 문제\r\n\r\nprevention detection 차이\r\n\r\nprevention : 비쌈, 비효율적. 데드락 가능성을 보고 아예 방지\r\n\r\ndetection : 데드락을 허용하되 리커버리 제공\r\n\r\n근데 사실 디텍션도 그렇게 값싼건아님\r\n\r\n복구가 항상 가능한 것은 아님\r\n\r\nmission critical system에서 사용이 어렵?\r\n\r\n(그럼 뭔 쓸모냐?)\r\n\r\n## Deadlock Detection\r\n\r\n- single instance\r\n- multi\r\n"},{"excerpt":".env vsc의 프로젝트 하위에 .env 파일을 만든다 .env 파일안에 SECRET KEY를 적어둔다   export는 전역변수 선언 dotenv pip install dotenv os.environ'ACCESS_KEY' : .env에 ACCESS_KEY가 없으면 KEY ERROR 그냥 python 딕셔너리라고 생각하면 됨 os.environ.get(…","fields":{"slug":"/env/"},"frontmatter":{"date":"May 09, 2022","title":"SECRET KEY 환경변수에 숨기기","tags":["env"]},"rawMarkdownBody":"\r\n\r\n\r\n## .env\r\n\r\n* vsc의 프로젝트 하위에 .env 파일을 만든다\r\n* .env 파일안에 SECRET KEY를 적어둔다\r\n\r\n![](./env_capture.png)\r\n\r\n>  export는 전역변수 선언\r\n\r\n\r\n\r\n## dotenv\r\n\r\n* pip install dotenv\r\n\r\n```python\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\nAWS_ACCESS_KEY_ID = os.getenv('ACCESS_KEY')\r\n```\r\n\r\n> * os.environ['ACCESS_KEY'] : .env에 ACCESS_KEY가 없으면 KEY ERROR 그냥 python 딕셔너리라고 생각하면 됨\r\n>\r\n> * os.environ.get('ACCESS_KEY') : getenv가 그냥 os.envrion.get의 래퍼인듯... 똑같이 작용\r\n>\r\n>   \r\n"},{"excerpt":"Dining-Philosophers Problem 각 철학자들은 밥을 먹어야할 때 소통 두 명이 젓가락 한 짝씩 공유 옆에 있는 젓가락만 사용가능 ( i번째 사람은 i또는 i+1만) semaphore chapstic5; # binary semaphore(=mutex lock) signal() # release 밥을 다 먹음 Deadlock 내가 원하는 자…","fields":{"slug":"/11-1/"},"frontmatter":{"date":"May 09, 2022","title":"os 11-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Dining-Philosophers Problem\r\n\r\n각 철학자들은 밥을 먹어야할 때 소통\r\n\r\n두 명이 젓가락 한 짝씩 공유\r\n\r\n옆에 있는 젓가락만 사용가능 ( i번째 사람은 i또는 i+1만)\r\n\r\n- semaphore chapstic[5]; # binary semaphore(=mutex lock)\r\n\r\n- signal() # release 밥을 다 먹음\r\n\r\n### Deadlock\r\n\r\n내가 원하는 자원을 상대방이 점유하고있어서 다음으로 넘어갈 수 없음\r\n\r\nex. 모든 사람들이 다 자신의 왼쪽에 있는 젓가락 한 짝을 소유중\r\n\r\n모두가 계속 기다림\r\n\r\n#### 해결방안 1\r\n\r\n다섯명의 철학자가 있지만 책상에 앉을 수 있는 사람을 4명으로 제한\r\n\r\n- 적어도 한 명은 젓가락 한 쌍을 얻을 수 있다\r\n\r\n#### 해결방안 2\r\n\r\n젓가락 두 개가 동시에 사용 가능할때만 젓가락을 집게한다\r\n\r\n- 두 줄의 코드가 atomic하게\r\n- 크리티컬 섹션으로. 내가 젓가락을 집을 때 다른 사람이 집을 수 없음\r\n\r\n-> 모니터를 사용해서 구현\r\n\r\nstate hungry 추가\r\n\r\nthinking\r\n\r\nhungry\r\n\r\neating : 두 이웃이 젓가락을 안쓰고있을때\r\n\r\ncondition : semaphore + waiting queue + wait signal 함수\r\n\r\n#### 해결방안 3\r\n\r\nasymmetric한 구조를 만든다\r\n\r\nwait(i+1)\r\n\r\nwait(i)\r\n\r\n순으로 하게 변경\r\n\r\n모두가 동시에 왼쪽 젓가락을 집지않는다\r\n\r\n데드락의 조건\r\n\r\n- Mutual exclusion\r\n  - 한 명이 리소스를 차지하고있으면 다른 사람이 리소스를 차지할 수 없다\r\n- No premmption\r\n  - 한 번 자원을 얻으면 할 일이 끝날 때까지 자원을 양보하지않는다\r\n- Hold and wait\r\n- Circular wait\r\n  - 원을 그리면서 서로가 서로의 것을 원하는... 상태\r\n\r\n위 조건 중 하나라도 만족하지않으면 문제가 생기지않음\r\n"},{"excerpt":"EC2 인스턴스 할당하기 Security Group > Add Rule HTTP HTTPS Custom -> TCP -> 8000 -> 0.0.0.0/0, ::/0 Review and Launch > Launch Create a new key pair 원하는 이름 설정 Download Key Pair Launch Instance Elastic IP 받기 …","fields":{"slug":"/deploy-ec2/"},"frontmatter":{"date":"May 08, 2022","title":"django 프로젝트 ec2로 배포하기","tags":["DRF","AWS","EC2"]},"rawMarkdownBody":"\r\n\r\n\r\n## EC2 인스턴스 할당하기\r\n\r\n#### Security Group > Add Rule\r\n\r\n1. HTTP\r\n2. HTTPS\r\n3. Custom -> TCP -> 8000 -> 0.0.0.0/0, ::/0\r\n\r\n\r\n\r\n#### Review and Launch > Launch\r\n\r\n1. Create a new key pair\r\n2. 원하는 이름 설정\r\n3. Download Key Pair\r\n4. Launch Instance\r\n\r\n\r\n\r\n#### Elastic IP 받기\r\n\r\nNetwork & Security > Elastic IPs\r\n\r\nAllocate Elastic IP address\r\n\r\nAllocate\r\n\r\nAssociate Elastic IP address\r\n\r\nInstance > 아까 생성된 인스턴스 선택\r\n\r\nAssociate\r\n\r\n\r\n\r\n#### SSH 연결하기\r\n\r\nssh ubuntu@아까_받은_Elastic_IP -i 다운받은_PEM_FILE\r\n\r\n\r\n\r\n## Django 프로젝트의 settings.py 수정\r\n\r\n1. DEBUG = (os.environ.get('DEBUG', 'True') != 'False')\r\n2. ALLOWED_HOSTS = ['*']\r\n3. pip freeze > requirements.txt\r\n4. git add -A, commit 해서 git repo에 push\r\n\r\n\r\n\r\n## Termius\r\n\r\n1. python3 -m venv venv #가상 환경 생성\r\n2. git clone {내_GitHub_레포지토리} {django-app}\r\n3. cd {django-app}\r\n4. source ../venv/**bin**/activate\r\n5. pip install -r requirements.txt\r\n6. python manage.py runserver 0.0.0.0:8000\r\n\r\n하면 http:// {나의 Elastic_IP:8000} 으로 접속 가능\r\n"},{"excerpt":"S3 버킷 생성 Django setting 설정 패키지 & 라이브러리 설치 settings.py - INSTALLED_APP","fields":{"slug":"/media-S3/"},"frontmatter":{"date":"May 08, 2022","title":"django media파일 S3서버랑 연동하기","tags":["DRF","AWS","S3"]},"rawMarkdownBody":"\r\n\r\n\r\n## S3 버킷 생성\r\n\r\n\r\n\r\n\r\n\r\n## Django setting 설정\r\n\r\n#### 패키지 & 라이브러리 설치\r\n\r\n```python\r\npip install boto3 # python에서 AWS에 접근가능한 패키지\r\npip install django-storages # 커스텀 스토리지 \r\n```\r\n\r\n\r\n\r\n#### settings.py - INSTALLED_APP\r\n\r\n\r\n\r\n```python\r\n# media url 설정\r\nMEDIA_URL = \"/media/\"\r\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\r\n\r\n# for AWS S3\r\nDEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'\r\nAWS_S3_SECURE_URLS = False # use http instead of https\r\nAWS_QUERYSTRING_AUTH = False # don't add complex authentication-related query parameters for requests\r\n\r\nload_dotenv()\r\n\r\n# AWS IAM 유저 key설정\r\nAWS_S3_ACCESS_KEY_ID = os.getenv('ACCESS_KEY')\r\nAWS_S3_SECRET_ACCESS_KEY =os.getenv('SECRET_ACCESS_KEY')\r\n\r\n# S3 버킷 이름\r\nAWS_STORAGE_BUCKET_NAME = 'danmer-videos'\r\n```\r\n\r\n\r\n\r\n"},{"excerpt":"Modular Exponentiation e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다 n의 bit수와 d의 bit수는 거의 같다 d = p x q (p, q는 각각 2048 bit) 곱하면 4096bit n은 3072 or 4096bit 0 < d < 파이(n) d의 자릿수 숫자는 불규칙? Binary L to R =(Squa…","fields":{"slug":"/rsa-mod/"},"frontmatter":{"date":"May 02, 2022","title":"10-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n## Modular Exponentiation\r\n\r\n\r\n\r\n* e는 고정된 작은 값을 쓸 수 있지만 d는 매우 큰 숫자를 사용하게 된다\r\n* n의 bit수와 d의 bit수는 거의 같다\r\n* d = p x q (p, q는 각각 2048 bit) 곱하면 4096bit\r\n* n은 3072 or 4096bit\r\n* 0 < d < 파이(n)\r\n* d의 자릿수 숫자는 불규칙?\r\n\r\n\r\n\r\n### Binary L to R\r\n\r\n=(Square and multiply)\r\n\r\n* 이진수로 분해\r\n* 제곱 (f x f)\r\n* 비트 곱하기? (f x a)\r\n\r\n제곱과 선택적인 비트 곱하기\r\n\r\n"},{"excerpt":"Mutex Lock race condition - 문제 상황 critical section - 문제 정의 mutex, semaphore, monitor - 해결방법 (high-level) API : OS가 제공해줘야함 Mutex (Mutual Exclusion) : 공유 변수 + 공유 자원(HW자원, I/O device ) ex) 프린터룸 : critic…","fields":{"slug":"/10-1/"},"frontmatter":{"date":"May 02, 2022","title":"os 10-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Mutex Lock\r\n\r\n> * race condition - 문제 상황\r\n> * critical section - 문제 정의\r\n> * mutex, semaphore, monitor - 해결방법 (high-level) API : OS가 제공해줘야함\r\n\r\nMutex (Mutual Exclusion) : 공유 변수 + 공유 자원(HW자원, I/O device )\r\n\r\nex)\r\n\r\n> * 프린터룸 : critical section\r\n>\r\n> * 프린터기 : 공유 자원\r\n>\r\n> * admin : os - key를 관리한다\r\n> * 각각의 사람들 : process or thread\r\n> * key : mutex\r\n>\r\n> \r\n>\r\n> os는 mutex권한을 acquire하거나 realease함\r\n>\r\n> * Critical section을 보호하는 기법\r\n> * acquire()과 release()를 사용해서 섹션에 진입하는 것을 제어한다. 인터페이스 제공\r\n> * Boolean variable == mutex\r\n> * key를 acquire하거나 release한다\r\n\r\n\r\n\r\n#### acquire() - key를 전달\r\n\r\n* admin이 수행\r\n\r\n- key가 없으면 대기\r\n- key가 생기면 acquire()이후의 코드를 실행 (크리티컬 섹션으로 진입)\r\n\r\n\r\n\r\n#### release() - key를 반납\r\n\r\n- 할 일이 끝났으니 available을 true로 만듦\r\n\r\n\r\n\r\n#### Busy waiting\r\n\r\n>  key를 얻기전에 while문을 계속 도는 것\r\n\r\n- available이 참인지 거짓인지 계속 판단\r\n- while을 깨줄 수 있는건 외부의 다른 프로세스\r\n- P0 : time slice를 소진할 때 까지 busy waiting\r\n- availble을 참으로 바꿔주는 건 다른 프로세스 : 다른 프로세스가 cpu에 올라가서 참으로 만들어줘야하나 이미 P0이 cpu 선점\r\n- P0은 계속 while문을 돌리면서 cpu에 있어야함\r\n- 성능 손해\r\n- spinlock == lock을 위해서 계속 spin중이다\r\n\r\n\r\n\r\n## Semaphore\r\n\r\nmutex와 비슷하나 좀 더 진화된 형태\r\n\r\nkey가 여러개\r\n\r\n- P() : wait, (=acquire)\r\n- V() : signal, (= release)\r\n- S : 몇 개의 key인지 - 0보다 큰 int (mutex에서는 0과 1뿐)\r\n- Binary semaphore : S가 0또는 1 (mutex와 같은 기능)\r\n  - for 전통적인 공유 변수 제어\r\n- Counting Semaphore : S가 2보다 크거나 같음\r\n  - 공동의 리소스 자원 관리/제어\r\n- 놓침 ><\r\n\r\n- block == sleep\r\n"},{"excerpt":"Symmetric Encryption의 문제 어떻게 secure채널을 통해서 안전한 키를 전달하지? 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : …","fields":{"slug":"/public-key/"},"frontmatter":{"date":"May 01, 2022","title":"9-2","tags":["computer protection"]},"rawMarkdownBody":"\r\n\r\n\r\n#### Symmetric Encryption의 문제\r\n\r\n* 어떻게 secure채널을 통해서 안전한 키를 전달하지?\r\n\r\n* 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation\r\n\r\n* CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다\r\n\r\n  > 만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : \r\n  >\r\n  > B가 CBC-MAC을 통해 받은 Ciphertext를 key로 복호화해서 A로부터받았음을 확인\r\n  >\r\n  > B가 법정에서 증거를 제출하려면 받은 Plaintext와 key와 MAC(Message Authentication)을 제공\r\n  >\r\n  > key는 secure하게 보관되어야하므로 A와 B만 가지고있다\r\n  >\r\n  > 그러나 이 Plaintext가 정말 A가 보낸건지 B가 key를 사용해서 임의로 만든건지 구분할 수 없다\r\n  >\r\n  > 즉, key가 최소 두 명이상한테 공유되었기때문에 누가 쓴건지 구별이 불가능하다.\r\n  >\r\n  > key는 single claimed sender를 가져야한다. 보낸이한테만 유일한 키\r\n\r\n\r\n\r\n## Public-Key Cryptosystems\r\n\r\n`Plaintext` -> `Public key` -> `Encryption algorithm`\r\n\r\n`Ciphertext` -> `Private key` -> `Decryption algorithm`\r\n\r\n\r\n\r\n#### Encryption with public key : 메세지를 숨기고 싶을 때\r\n\r\n* 누구의 퍼블릭 키, 누구의 프라이빗 키인지가 중요하다\r\n* Bob이 Alice에게 암호문을 보낼 때, Alice의 퍼블릭키를 사용해서 암호화\r\n* Alice는 받은 암호문을 Alice의 프라이빗키를 사용해 복호화한다 \r\n\r\n> 키 분배 문제 해결 \r\n>\r\n> * 키 분배 문제 : 어떻게 key를 안전하게 교환할 것인가\r\n> * Public-Key는 A가 Key pair를 생성하면 공개키를 모두에게 공개\r\n> * 굳이 안전하게 전달할 필요가 없음\r\n\r\n\r\n\r\n#### Encryption with private key : 전자서명\r\n\r\n* Private key를 가지고 Encryption : 전자서명에 해당\r\n* Encryption algorithm == Signature Generation\r\n* Decryption algorithm == Signature Verification\r\n\r\n* Bob이 Alice에게 암호문을 보낼 때, Bob의 Private key를 사용해서 암호화\r\n* Alice는 받은 암호문을 Bob의 Public key를 사용해서 복호화\r\n* 서명을 해서 보냄. 받아서 복호화한 Plaintext와 서명이 잘 맞아 떨어진다면 중간에 오류나 변조없이 도착한 것임 : Integrity 보장\r\n* Bob의 Privae key를 통해서 온 것이므로 nonrepudiation 해결\r\n\r\n\r\n\r\n### Conventional and Public-Key Encryption\r\n\r\n* conventional : 전통적인 (= Symmetric)\r\n\r\n|                   Conventional Encryption                    |                    Publick-Key Encryption                    |\r\n| :----------------------------------------------------------: | :----------------------------------------------------------: |\r\n| 같은 알고리즘이 **같은 키**와 사용된다 (AES같은 경우엔 완전히 같진않고 역연산) | 두 개의 키가 존재한다 하나는 Encryption에 다른 하나는 Decryption에 사용 |\r\n|      보내는 사람과 받는 사람이 알고리즘과 키를 공유한다      | 알고리즘은 서로 공유하나 보내는 사람과 받는 사람이 같은 키가 아닌 키 pair를 사용한다 |\r\n|         대칭 암호에서는 키가 안전하게 유지되어야한다         |            공개키는 안전하게 전달 될 필요가 없다             |\r\n| 키가 안전하게 유지되고 있다면 메세지를 키 없이 복호화하는게 어렵다 | 키 중에 하나가 Private Key)가 안전하게 유지되고 있다면 메세지를 복호화하는게 어렵다 |\r\n| 알고리즘을 알고 Cipher text를 몇개를 알아도(암호문쌍) 어떤 키가 사용됐는지 알아내는게 어렵다 | 알고리즘을 알고 공개키하나도 알고 Ciphertext(암호문쌍)을 알아도 private key를 알아내긴 어렵다 |\r\n\r\n\r\n\r\n### Public-Key Cryptosystem \r\n\r\n* Authentication and Confidentiality\r\n* Source A, Destination B 일 때\r\n* 1. A가 자신의 Private key를 가지고 서명\r\n  2. A가 B의 Public key를 가지고 암호화\r\n* 1. B가 자신의 Private key를 가지고 복호화\r\n  2. B가 A의 Public key를 가지고 A가 맞는지 확인\r\n\r\n\r\n\r\n#### Public-key cryptosystems can be classified into three catagories:\r\n\r\n* Encryption/Decryption\r\n* Digital Signature\r\n* Key exchange\r\n  * 공개키 쓴다고 symmetric 암호 안쓰는 건 아님\r\n\r\n\r\n\r\n#### Public-Key Requirements\r\n\r\n* 수신자가 키 페어를 만들기 쉬워야함\r\n* 퍼블릭 키와 메세지를 사용해서 ciphertext를 만드는 일이 쉬워야함\r\n* 프라이빗 키와 cipher text를 사용해서 plaintext를 만드는 일도 쉬워야함\r\n* 퍼블릭 키를 알고있어도 프라이빗 키를 추측하는건 어려워야함\r\n* 퍼블릭 키와 ciphertext를 알아도 private key없이 plain text를 추측하는건 어려워야함\r\n\r\n\r\n\r\n## RSA(Rivest-Shamir-Adleman) Algorithm\r\n\r\n* PU = {e, n}\r\n* PR = {d, n}\r\n* 암호화는 e를 사용해서, 복호화는 d를 사용해서 함\r\n* 두 개다 mod n을 사용해야함. n은 권장사항이 2048 bit이상이며 보통 3072, 4096사용\r\n\r\n\r\n\r\n ex ) Bob -> Alice에게 암호문을 보낼 때\r\n\r\n* Key Generation by Alice\r\n\r\n  > Select p, q : p and q both primte p!=q\r\n  >\r\n  > Calculate n = p x q\r\n  >\r\n  > Select integer e (e는 오일러(n)과 서로소여야함)\r\n  >\r\n  > 이후 구할 d때문. e x d = 1 mod 오일러(n)\r\n\r\n* Encryption by Bob with Alice's Public Key\r\n\r\n  > Plain text = m, m은 n보다 작은 숫자의 범위\r\n  >\r\n  > C = M^e mod n\r\n\r\n* Decryption by Alice with Alice's Private Key\r\n\r\n  ![](./enc_dec.png)\r\n  \r\n  > C^d mod n == (M^e mod n)^d mod n\r\n  >\r\n  > -> M^ed mod n\r\n  >\r\n  > (ed = k x 파이(n) + 1 mod n) : d는 e의 곱셈의 역원\r\n  >\r\n  > ((M^파이(n))^k x M )mod n\r\n  >\r\n  > 오일러 이론에 의해 (M^파이(n))^k 는 1이 된다\r\n  >\r\n  > M mod n = M S: M이 n보다 작으므로 \r\n\r\n\r\n\r\n#### Example of RSA Algorithm\r\n\r\n> p = 11, q = 17\r\n>\r\n> n = p x q = 187\r\n>\r\n> ∮(n) = (p-1)(q-1) = 160\r\n>\r\n> e = 7 (160과 서로소인 수)\r\n>\r\n> d = 23 ( e*d를 mod 160했을 때 1이 나옴. d는 e의 곱셈의 역원)\r\n>\r\n> * plaintext는 n(187)보다 작은 숫자\r\n\r\n\r\n\r\n### RSA Signature\r\n\r\n> Decryption : Signature generation\r\n>\r\n> Encryption : Signature Verification\r\n\r\n* Alice 가 Bob에게 보낼 때 Alice가 자신의 private key로 Signature generation을 한다. (M, S)를 전달\r\n  * M은 메시지\r\n  * S는 서명한 M (M^d mod n)\r\n* Bob 은 받은 S를 Alice의 public key(e)를 사용해서 Signature Verification을 한다\r\n  * S ^ e mod n = M\r\n\r\n\r\n\r\n### Left to Right binary\r\n\r\n**Square and Multiply라고도 불림**\r\n\r\na^b mod n\r\n\r\n* for k부터 0까지 루프를 돈다\r\n  * k는 b의 비트수 (bk ~ b0)\r\n  * 예제의 경우 bit수가 10개이므로 k는 9~0\r\n* c는 현재 a의 몇 제곱인지를 알려줌(10진수). \r\n  * b의 bit를 10001까지 수행했을 경우 10001은 10진수로 17 = c \r\n  * 결과값에는 영향을 주지 않음. (지워도 상관없음. 이해를 돕기위한 값)\r\n* f의 initial은 1\r\n* f는 (a의 bi제곱 mod n)을 의미\r\n* f는 일단 제곱을 무조건 시킴  + (c = cx2)\r\n* 해당 bit인 bi가 1일 경우\r\n  * c = c+1\r\n  * f 에 a를 곱함\r\n\r\n> 운이 좋을 경우 (1000000)\r\n>\r\n> : 제곱만 수행 (곱셉 연산 한 번)\r\n>\r\n> 운이 나쁠 경우 (1111111)\r\n>\r\n> : 제곱과 곱하기를 수행 (곱셈 연산 두 번)\r\n>\r\n> 지수 e가 2048일 경우\r\n>\r\n> 즉, 총 log2 n ~ 2logn 의 연산을 수행\r\n>\r\n> (2048 ~ 4096)\r\n>\r\n> 평균적으로 3/2 log2n (3072)\r\n>\r\n> 만약 이렇게 로그에 기반해서 연산안하고 바로 a x a x a x ...a 했다면 2^2048번의 연산을 수행해야한다고함\r\n\r\n\r\n\r\n### Efficient Operation Using the Public Key\r\n\r\n근데 저렇게 해도 숫자가 너무 커서 오래걸림\r\n\r\n그래서 e를 2^16 +1로 고정\r\n\r\n어차피 공개키라 고정해도 상관없음\r\n\r\n2^16 +1하면  제곱 16번 + bit 1인게 두개라서 2번 곱셈\r\n\r\n가끔 3이나 17같은 엄청 작은 숫자를 쓰기도 하나 공격에 취약할수도있음\r\n\r\nd는 프라이빗이라 고정해놓으면 안됨\r\n\r\n\r\n\r\n### RSA의 안전성\r\n\r\n* Brute force\r\n  * d에 모든 값 대입 \r\n  * 2048가지의 경우 존재 너무 오래걸림\r\n* Mathematical attacks\r\n  * 소인수 p와 q의 쌍을 구하려함\r\n\r\n* Chosen ciphertext attack\r\n  * RSA의 구조적인 특성을 이용한 공격\r\n\r\n\r\n\r\n### Factoring Problem\r\n\r\n* n으로 p, q두 쌍을 구할 수 있으면 RSA는 깨짐\r\n\r\n\r\n\r\n## Chosen Ciphertext Attack (CCA)\r\n\r\n* 공격자가 Plain text와 Cipher text의 쌍을 알 때 private key없이 어떤 Cipher text의 Plain text를 추측할 수 있는 것\r\n\r\n* 공격자가 어떤 C에 대한 P를 물어봐서 P를 얻어냄\r\n\r\n* 이를 바탕으로 또 다른 C를 물어보지않고도 P를 추측\r\n\r\n* ex\r\n\r\n  > C의 P를 구하고자 할 때\r\n  >\r\n  > C' = C x 2^e mod n\r\n  >\r\n  > C'의 P를 요청함\r\n  >\r\n  > P' = C'^d mod n =  (C x 2^e)^d mod n = C^d x 2 mod n\r\n  >\r\n  > 즉 C의 P는 P'에 2의 역원을 곱하면 된다\r\n\r\n이런 공격을 방지하기 위해 RSA에 특별한 구조를 넣게 되어있음 RSA Security- OAEP\r\n\r\n안전성때문에 RSA-OAEP 사용\r\n\r\n\r\n\r\n### OAEP\r\n\r\n뭐라는겨 \r\n\r\nMGF != MGF\r\n\r\n\r\n\r\n## Side Channel Attack\r\n\r\nimplementation attack\r\n\r\n알고리즘을 실행시키고있는 기계 자체를 공격\r\n\r\n알고리즘을 실행하면 기계에서 부수적인 정보가 나옴\r\n\r\n* Timing attack : 누군가 private key를 가지고 연산을 하고있을 때 private key에 따라 연산 시간이 달라질수도있다\r\n* Power analysis : 전력 소모의 패턴을 분석. 제곱연산할때의 전력소모와 곱셈 연산을 할 때 전력소모를 구해서 분석. (전자기파 분석, 클라우드 분석)\r\n  * 1이면 S M , 0이면 S\r\n\r\n어떻게 막나?\r\n\r\n* Constant-time algorithm\r\n  * 알고리즘을 비트가 0이냐 1이냐에 따라서 바뀌지않게 만든다\r\n  * M을 항상 하게 바꿈\r\n  * 1이냐 0이냐에 따라 X[0] or X[1] 반환\r\n  * 시간이 더 오래 걸리긴 함(필요없는 M도 하게 되어서)\r\n  * 시간분석 대응가능. 일정한 시간 소요\r\n\r\n\r\n\r\n### Fault-Based Attack\r\n\r\n좀 더 공격적\r\n\r\n아까는 공격자가 그냥 관찰만\r\n\r\n연산이 수행되는 와중에 강력한 전압을 걸어주는등의 공격을 해서 오류가 생기게\r\n\r\n\r\n\r\n### Misconceptions Concerning Public-Key Encryption\r\n\r\n* 공개키 알고리즘은 암호 공격에 대해서 시메트릭 암호보다 안전하다\r\n\r\n맞을수도있고 틀릴수도있음\r\n\r\nAES 128비트 버전과 RSA 2048 어떤게 더 안전할까?\r\n\r\nRSA가 시도할 경우의 수가 더 많음\r\n\r\n그러나 이렇게 무작위로 하지않음\r\n\r\n팩토링을 사용하면 효율적으로 가능. AES보다 더 빠르게\r\n\r\n공격할 방식 자체가 다르기 때문에 맞을수도있고 틀릴수도있음\r\n\r\n\r\n\r\n* 공개키 알고리즘이 대칭 알고리즘을 완벽하게 대체할 수 있는 알고리즘이다\r\n\r\n  x : 성능 측면에서 대칭 알고리즘이 훨씬 유리\r\n\r\n  키 공유 문제에선 공개키 알고리즘이 유리\r\n\r\n  하이브리드 알고리즘이 다수\r\n\r\n* 대칭 암호의 키공유문제를 해결하기 위해 나온게 공개키 알고리즘 : 공개키 암호를 쓰면 키 분배를 하는데 전혀 문제가 없을까?\r\n\r\n  x : 상대적으로 대칭 암호에 비해 키 공유가 나은 것이지 근본적으로 해결되는 것은 아니다\r\n\r\n  시메트릭 : 키를 안전하게 전달하는 것이 목표\r\n\r\n  퍼블릭키 : 키를 숨기면서 전달할 필요가 없음. \r\n\r\n  대칭 암호에서의 키 분배는 confidentialiry\r\n\r\n  퍼블릭키는 authentication과 Integrity 보장해야함\r\n\r\n  공격자가 다른 사람의 공개키인척 공유하면 안됨\r\n\r\n  이런 문제때문에 공개키 인증서가 나옴\r\n\r\n  정부에서 공인된 절차로 만든게 공인인증서\r\n\r\n  \r\n\r\n\r\n\r\nRSA에서 Factoring과 Discrete Logarithm(이산대수)이 중요하다...\r\n"},{"excerpt":"Django 로그인 처리 Django자체에 디폴트로 로 처리되어있다 장고의  를 활용해서 설정","fields":{"slug":"/LoginView/"},"frontmatter":{"date":"May 01, 2022","title":"Django LoginView 사용","tags":["django","python"]},"rawMarkdownBody":"\r\n## Django 로그인 처리\r\n\r\nDjango자체에 디폴트로\r\n\r\n```\r\nLOGIN_URL = '/accounts/login/'\r\n\r\nLOGIN_REDIRECT_URL = 'accounts/profile/'\r\n```\r\n\r\n로 처리되어있다\r\n\r\n장고의 `LoginView` 를 활용해서 설정\r\n\r\n```python\r\nform django.contrib.views import LoginView\r\n\r\nurlpatterns=[\r\n    path('login/', LoginView.as_view(template_name='accounts/login.html'), name = 'login'),\r\n]\r\n# LoginView의 template경로는 'registation/login.html'로 설정되어있다.\r\n# template_name = 'registation/login.html'\r\n# as_view 함수의 인자로 필드값을 넣어 인스턴스의 template_name을 변경시킬수있다.\r\n```\r\n"},{"excerpt":"패킷(Packet) 네트워크 계층 (Layer 3)에서 정의되는 데이터 단위 그 외에도 OSI의 각 계층에서 주고 받는 정보의 단위를 모두 패킷이라고 총칭하기도함 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함 헤더와 데이터로 구성됨 헤더 : 운송장, 데이터 : 물품 Packet Sniffing 네트워크 트래픽을 도청하고 민감한 정보를 수…","fields":{"slug":"/arp-attack/"},"frontmatter":{"date":"April 30, 2022","title":"9-1","tags":["computer protection"]},"rawMarkdownBody":"\r\n## 패킷(Packet)\r\n\r\n- 네트워크 계층 (Layer 3)에서 정의되는 데이터 단위\r\n- 그 외에도 OSI의 각 계층에서 주고 받는 정보의 단위를 모두 패킷이라고 총칭하기도함\r\n- 인터넷(Internet)에서는 IP 데이타그램을 패킷이라고 말함\r\n- 헤더와 데이터로 구성됨\r\n- 헤더 : 운송장, 데이터 : 물품\r\n\r\n## Packet Sniffing\r\n\r\n- 네트워크 트래픽을 도청하고 민감한 정보를 수집하는 행위\r\n\r\n- passive attack\r\n\r\n- 노출된 ID, password, cookie등을 엿볼 수 있는 위험\r\n\r\n  > HTTP Cookie\r\n  >\r\n  > - 웹 사이트에 접속할 때 웹 사이트 서버가 내 컴퓨터에 보내는 임시 파일이다\r\n  > - 크기는 4KB 이하로 매우 작다\r\n\r\n- 다운로드 불가능한 파일을 덤프하거나 엿볼 수 있는 위험\r\n\r\n- 스위치/라우터로 분리된 네트워크들 간에는 sniffing 불가\r\n\r\n  - A공유기 구역에서 B공유기 구역으로 sniffing 불가능\r\n  - 허브는 가능. broad cast 가능\r\n\r\n## Wireshark\r\n\r\n패킷 분석 프로그램\r\n\r\n### Promiscuous mode란?\r\n\r\n> 정상적인 네트워크 카드는 네트워크 카드에 인식된 2계층(MAC)과 3계층(IP) 정보가 자신의 것과 일치하지 않는 패킷은 무시한다\r\n>\r\n> 정상적인 경우에는 이러한 패킷들을 처리할 이유가 없기 때문\r\n>\r\n> 모든 패킷을 일일이 CPU가 확인하여 처리하면 CPU에 부하가 많아짐\r\n\r\n- 위의 필터링을 끈다\r\n- 2계층과 3계층에서 필터링을 하지 않는다\r\n\r\n### Capture filter\r\n\r\n- 그렇다고 다 필터안하면 너무 많음. 적당히 필터해야함\r\n- 캡처를 시작하기 전에 필터를 적용하는 방식\r\n- 필요성1 : 필터없이 캡처를 시작할 경우 많은 양의 패킷으로 인해 원하는 패킷을 찾기 힘들다\r\n- 필요성2 : 캡처를 시작한 이후 Display Filter를 적용할 수 있으나 Display Filter는 모든 패킷을 캡처한 후 필터링을 진행하는 것이기 때문에 불필요한 패킷이 캡처되어서 파일의 크기가 커진다.\r\n- 이때 Capture Filter를 적용하면 불필요한 패킷은 사전에 필터링되어서 Wireshark 프로그램에 걸리는 부하를 효과적으로 줄일 수 있다\r\n\r\n### Display Filter\r\n\r\n- 캡처를 한 뒤 원하는 패킷만 화면에 출력한다\r\n- Capture filter와 문법이 다르다\r\n- 원하는 패킷을 캡처한 뒤 세부 분석을 하기 위해 쓰인다\r\n\r\n#### 캡처 방법\r\n\r\n- 특정 호스트의 패킷 캡처\r\n  - ip.addr == 10.10.50.15\r\n- 특정 두 호스트의 통신 패킷 캡처\r\n  - host 10.10.50.170 and host 10.10.50.15\r\n- 특정 포트 패킷 캡처\r\n  - tcp.port == 80\r\n- 특정 두 포트 전부 패킷 캡처\r\n  - tcp.port ==80 or tcp.port ==1770\r\n- 특정 호스트의 특정 포트 패킷 캡처\r\n  - ip.addr == 10.10.50.170 and tcp.port == 80\r\n- 특정 패킷만 캡쳐 안함\r\n  - not arp\r\n- 출발지나 목적지 IP 주소로 검색\r\n  - ip.addr == 192.168.0.1\r\n- 출발지 IP 주소로 검색\r\n  - ip.src == 192.168.0.1\r\n- 도착지 IP 주소로 검색\r\n  - ip.dst == 192.168.0.1\r\n- 포트로 검색\r\n  - tcp.port == 443\r\n- 출발지 포트로 검색\r\n  - tcp.srcport == 443\r\n- 도착지 포트로 검색\r\n  - tcp.dstport == 443\r\n\r\n### Practice 2 : FTP Packets\r\n\r\n- FTP\r\n\r\n  > - 파일 전송 프로토콜\r\n  > - TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 하기 위한 프로토콜\r\n  > - FTP는 통신을 위해 2개의 port를 사용함 (command, data transfer)\r\n  > - 보통 FTP 프로토콜은 20번 포트 (for command)\r\n  > - FTP-DATA 프로토콜은 21번 포트 (for data transfer)\r\n\r\n- FTP를 사용하지 말아야 하는 이유 ?\r\n  - **평문** 파일 전송 프로토콜이기때문\r\n\r\n## MAC Address / IP Address\r\n\r\n- MAC Address : Datalink 계층의 주소\r\n- IP Address : Network 계층의 주소\r\n- 도메인 이름은 정류장 이름\r\n- IP는 정류장 번호\r\n- MAC은 정류장 주소\r\n\r\n### MAC(Media Access Control) 주소\r\n\r\n- NIC(네트워크 인터페이스 카드)에 할당된 고유한 식별자\r\n- 로컬 네트워크 통신에 사용\r\n- 48bit의 주소길이\r\n- 관리자 계정은 PC의 MAC주소를 직접 변경할수도 있음\r\n  - window는 ipconfig/all\r\n  - mac은 ifconfig\r\n\r\n#### MAC Address 를 사용하는 이유\r\n\r\n- 서버의 NIC와 내 컴퓨터의 NIC끼리 통신\r\n- Datalink layer 통신을 위해서는 MAC 주소 알아야함\r\n\r\n### ARP의 메커니즘\r\n\r\nIP주소에 해당하는 MAC주소를 알고싶음\r\n\r\n- IP를 가지고 broad cast request로 IP에 해당하는 컴퓨터를 찾는다\r\n\r\n- 해당 IP를 가지는 컴퓨터가 Unicast Reply로 자신의 MAC주소를 알려준다\r\n\r\n  > ARP 취약점\r\n  >\r\n  > System B(컴퓨터)가 정상적인 노드인지 보장 못함(인증없음)\r\n  >\r\n  > B가 정말로 해당 IP를 가진 컴퓨터인지, 악의적인 목적을 지닌 공격자인지 판별할 수 없다\r\n\r\nex)\r\n\r\n#### ARP Request : 1292.168.0.16?\r\n\r\n- 192.168.0.50(00:E0:91:DB:3C)이 192.168.0.16의 MAC주소를 알기 위해 ARP Request 메시지를 브로드 캐스팅\r\n\r\n#### MAC 주소를 알고있음에도 ARP 요청이 발생하는 경우\r\n\r\nex. 컴퓨터가 바뀐 경우? IP주소는 그대로 지만 MAC 주소 변경됨\r\n\r\n이런 경우 주기적으로(30초마다) ARP요청. (유니캐스트)\r\n\r\nreply가 오면 살아있고 응답이 없으면 문제가 생긴것. 알고있는 MAC주소가 유효하지않으므로 다시 브로드캐스트\r\n\r\n### ARP cache\r\n\r\n#### ARP cache table\r\n\r\n- MAC주소와 IP주소를 매핑하고 있는 테이블\r\n\r\n  1. static ARP cache entry\r\n\r\n     - 수동으로 추가 가능. (컴퓨터 재시작시 삭제)\r\n\r\n  2. dynamic ARP cache entry\r\n     - ARP reply packet을 받으면 OS에 의해 자동으로 저장\r\n     - 30초간 지속\r\n\r\n## ARP Spoofing(위장)\r\n\r\n- 근거리 통신망(LAN)하에서 ARP 메시지를 이용하여 상대방의 데이터 패킷을 중간에 가로채는 중간자 공격(Man-in-the-middle-Attack)기법이다.\r\n- 가로챈 패킷을 변조하는 Active attack까지 수행 가능\r\n- 이 공격은 데이터 링크(Layer 2)상의 프로토콜인 APR 프로토콜을 이용하기 때문에 근거리 상의 통신에서만 사용할 수 있는 공격이다\r\n\r\n#### 스위치를 통하는 패킷의 흐름\r\n\r\n- 유니캐스트 패킷\r\n- 스위치가 MAC 주소 테이블을 유지/관리\r\n\r\n- 스위치로 묶였다면 하드웨어적으로 연결을 해줘서 Promiscuous mode 효과 없음\r\n\r\n- 허브로 묶였다면 모든 시스템을 다 봐서 Promiscuous mode 효과 있음\r\n- 스니핑(도청) != 스푸핑\r\n\r\n#### 스위치로 묶인 네트워크일 경우 어떻게 스니핑할까?\r\n\r\n공격 시나리오\r\n\r\n- 공격 대상(1번)에게 조작된 정보를 보내 수신지를 변경 (ARP 패킷 관련)\r\n- 공격자의 NIC는 promiscuous 모드\r\n- 수신된 패킷은 relay함 (Packet forwarding) : 정상인척 패킷을 받아서 보내줌\r\n- 패킷 모니터링 룰 실행\r\n\r\n## Detect ARP Spoofing\r\n\r\n결국은 스위치가 잘해줘야함. (ex. 방화벽)\r\n\r\n- ARP 탐지 솔루션 또는 네트워크 방화벽\r\n  - arpwatch(\\*nix 계열)\r\n  - xarp(NT/\\*nix)\r\n  - ai 기반 탐지?\r\n- Promiscuous 모드로 동작하는 Host 탐지\r\n  - ARP Spoofing 공격 시도 가능성이 높기 때문\r\n- ARP Cache 테이블을 정적으로 유지\r\n\r\n## DNS(Domain Name System) Spoofing\r\n"},{"excerpt":"django.contrib.auth.models django.contrib.auth.models를 사용해 이미 만들어진 User모델을 가져와 사용할 수 있다 django.contrib.auth.models에서 직접 User model을 참조해오거나 getusermodel () 을 사용해서 유저 모델을 가져오거나 settings.py에 을 지정해서 유저 모…","fields":{"slug":"/auth-user/"},"frontmatter":{"date":"April 28, 2022","title":"AUTH_USER_MODEL 사용","tags":["django"]},"rawMarkdownBody":"\r\n## django.contrib.auth.models\r\n\r\n- django.contrib.auth.models를 사용해 이미 만들어진 User모델을 가져와 사용할 수 있다\r\n- django.contrib.auth.models에서 직접 User model을 참조해오거나\r\n- get_user_model () 을 사용해서 유저 모델을 가져오거나\r\n- settings.py에 `AUTH_USER_MODEL`을 지정해서 유저 모델을 가져올 수 있다\r\n\r\n> from django.contrib.auth.models import User\r\n>\r\n> 를 사용해 직접 User를 참조하는 방법은 이후 모델이 바뀌거나 코드를 수정해야할 일이 생길 때 유연성이 떨어진다\r\n\r\n> get_user_model()은 객체 인스턴스를 리턴해서 Django 앱이 로드되는 그 순간에 실행되기 때문에 반드시 유효한 사용자 모델 객체를 리턴한다는 보장이 없다.\r\n> 문자열이 아닌 유저 클래스 자체를 써야할 때 사용하도록한다.\r\n>\r\n> AUTH_USER_MODEL은 외래키 모델을 전달할 때 문자열로 전달한다. 외래키가 임포트될 때 모델 클래스 탐색에 실패하면 모든 앱이 로드될 때까지 실제 모델 클래스의 탐색을 미루기때문에 항상 올바른 사용자 모델을 얻을 수 있다\r\n\r\n## AUTH_USER_MODEL 등록해보기\r\n\r\nDjango자체에 디폴트로\r\n\r\n```\r\nLOGIN_URL = '/accounts/login/'\r\n\r\nLOGIN_REDIRECT_URL = 'accounts/profile/'\r\n```\r\n\r\n로 처리되어있다\r\n\r\ndjango 공식 깃허브에 accounts앱이 있으므로\r\n\r\n- accounts라는 이름을 가진 앱을 만든다\r\n- accounts의 models.py에 `django.contrib.auth.models`의 AbstractUser를 상속한 User클래스를 만들어준다\r\n- accounts라는 앱에서 User모델을 따로 만들었으므로 커스텀이 가능하다\r\n\r\n\\# accounts/models.py\r\n\r\n```python\r\nfrom django.db import models\r\nfrom django.contrib.auth.models import AbstractUser\r\n\r\nclass User(AbstractUser):\r\n    pass\r\n```\r\n\r\n- config의 settings.py 에 AUTH_USER_MODEL을 등록한다\r\n\r\n\\# config/settings.py\r\n\r\n```python\r\nAUTH_USER_MODEL = 'accounts.User'\r\n```\r\n"},{"excerpt":"Combined Threads many to many 커널레벨모드도 유저레벨모드도 존재 유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다 커널은 사실상 스레드의 존재를 크게 의식하지않음 커널은 단지 유저에게 virtual processor같은. cpu코어같음 커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 …","fields":{"slug":"/7-2/"},"frontmatter":{"date":"April 22, 2022","title":"os 7-2","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n### Combined Threads\r\n\r\n* many to many\r\n\r\n* 커널레벨모드도 유저레벨모드도 존재\r\n\r\n* 유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다\r\n\r\n* 커널은 사실상 스레드의 존재를 크게 의식하지않음\r\n\r\n* 커널은 단지 유저에게 virtual processor같은. cpu코어같음\r\n\r\n* 커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 스케줄링하고 관리해줌\r\n\r\n* 유저레벨 스레드는 커널레벨 스레드가 가상의 프로세서라고 생각하고 활용\r\n\r\n* 어떤 스레드를 어떤 프로세서에 넣을지 관리를 해줌\r\n\r\n* 사용자 : 자기 자신이 스레드를 만들고 관리\r\n* 시스템 : 시스템도 똑같이 만들고 관리\r\n* 시스템(커널) 스레드 수의 한계가 존재(1대1로 매핑하면 오버헤드가 커짐)\r\n* 유저 레벨 스레드 > 커널 레벨 스레드\r\n* 유저 레벨 스레드 라이브러리\r\n  * 유저레벨스레드를 만들고 없앰\r\n  * 스케줄링 ( 어떤 스레드를 선택할지, 어떤 유저레벨스레드를 커널레벨스레드에 올릴지 )\r\n  * 컨텍스트를 saving, restore\r\n  * 스레드간 데이터, 메시지 통신\r\n\r\n* System call API and kernel functions for thread facility\r\n  * 커널레벨 스레드 중에 어떤걸 cpu에 올릴지라는것만 빼고 다 동일\r\n\r\n\r\n\r\n* 유저가 스레드를 만듦\r\n* 커널에서는 유저 스레드의 양을 보고 적절한 양의 커널 스레드를 만들어서 매핑\r\n* 유저레벨 스레드간의 소통, 싱크로나이즈는 유저레벨에서 이루어짐\r\n* 사실 요즘 하드웨어는 cpu코어가 적당히 많아서 원투원 사용\r\n\r\n\r\n\r\n## Thread Libraries\r\n\r\n* Pthread & OpenMP\r\n* Pthread(Unix 계열의 표준 API)\r\n* OpenMP (c++, c)\r\n\r\n### Pthreads\r\n\r\n* Pthread : POSIX standard for threads\r\n* api만 정의되어있음\r\n* 구현은 실제 라이브러리를 만드는 사람마다 다르게 사용할 수 있음\r\n\r\n\r\n\r\n* pthread_create()는 fork()와 비슷한\r\n* pthread_exit = exit()\r\n* pthread_join() = wait\r\n* pthread_yield() : cpu를 양보하겠다는 말. 다른 스레드가 써라!\r\n\r\n\r\n\r\npthread_create(&tid, NULL, runner(수행할 일), argv\\[1](runner함수의 인자) )\r\n\r\n스레드 attribute\r\n\r\n​\tex. 스케줄러, 폴리시, 프라이어티, stack주소등\r\n\r\n\r\n\r\n## Implicit Threading\r\n\r\n* explicit threads (명시적으로 스레드 생성, 일 분담) - 어렵다 적당히 시스템이 해줬음좋겠다라는 마음에서 나온게 implicit threading\r\n* 스레드 생성, 관리를 컴파일러나 런타임라이브러리가 해줌\r\n* 프로그래머는 단지 병렬적으로 일할 수 있는 부분만 알려줌\r\n* 사용자수준에서는 훨씬 사용하기쉽다\r\n\r\n### OpenMP\r\n\r\n컴파일러한테 여기 parallel하게 해줘~하면 알아서 병렬처리 해주는 api와 compiler directives\r\n\r\n* #pragma omp parallel\r\n* 앞에 이 문장만 넣어주면 병렬로 해줌 밑에 나오는 줄을 코어 수만큼 수행. 병렬로 할 수 있는만큼 중복수행해줌\r\n* #pragma omp parallel for (num_thread(4))\r\n* for문의 크기를 적당히 쪼개서 병렬로 처리해줌\r\n* num_thread를 통해 thread를 몇 개 쓸건지 정할수도있음\r\n\r\n\r\n\r\n## Synchronization Tools\r\n\r\n프로세스들간의 소통이 필요\r\n\r\ndata inconsistency를 야기할수도\r\n\r\na라는 애가 읽으려는 데이터를 b가 읽기전에 바꿔버리면 예측하려는 결과가 안나옴\r\n\r\ncounter로 버퍼사이즈를 카운트\r\n\r\natomic하지않음 - Race Condition - 자원을 공유해서 잘못된 결과를 낳음\r\n\r\n그래서 동기화가 필요!\r\n\r\n프로듀서가 쓸거라고하면 컨슈머가 건들지못하고 컨슈머가 쓸려고하면 프로듀서가 쓰지못하는\r\n\r\n\r\n\r\n"},{"excerpt":"Critical Section Problem 동기화! 각 프로세스의 코드에는 크리티컬 섹션이 존재한다 critical section : 공유 데이터가 업데이트 일어나는 부분 entry section : 크리티컬 섹션에 들어가기위한 코드의 부분 exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분 remainder section : 크리…","fields":{"slug":"/8-1/"},"frontmatter":{"date":"April 22, 2022","title":"os 8-1","tags":["OS"]},"rawMarkdownBody":"\r\n\r\n\r\n## Critical Section Problem\r\n\r\n> 동기화!\r\n>\r\n> 각 프로세스의 코드에는 크리티컬 섹션이 존재한다\r\n>\r\n> * critical section : **공유 데이터**가 업데이트 일어나는 부분\r\n> * entry section : 크리티컬 섹션에 들어가기위한 코드의 부분\r\n> * exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분\r\n> * remainder section : 크리티컬섹션이 아닌 나머지부분\r\n>\r\n> 위 섹션들은 모두 코드임\r\n\r\n\r\n\r\n* n개의 프로세스가 있다고 가정\r\n\r\n* 각각의 프로세스는 코드를 가지는데 그 코드에 크리티컬 섹션이 존재\r\n\r\n* 크리티컬 섹션안에서는 정보의 업데이트가 가능하다\r\n\r\n* 공유되는 변수나 테이블등을 바꿀 수 있음\r\n\r\n* 어떤 프로세스가 크리티컬 섹션을 가지고있으면 다른 프로세스가 그 크리티컬 섹션에 진입할 수 없다\r\n\r\n  \r\n\r\n#### Solution to Critical Section Problem\r\n\r\n* Mutual Exclusion (상호배제)\r\n  * 한 번에 한 프로세스만 크리티컬 섹션에 들어갈 수 있다\r\n  * 한 프로세스가 어떤 크리티컬 섹션에 들어가 있으면 다른 프로세스가 동일한 크리티컬 섹션안에 들어가지못한다\r\n\r\n* Progress\r\n  * 만약에 크리티컬 섹션에 아무도 없는데 들어가고싶어하는 사람이 있으면 그 결정은 바로 나야한다\r\n  * 즉 최대한 빨리 결정이 나야한다는 것! 무기한 연장되지않는다\r\n  * 그 결정은 remainder 섹션에 있지 않은 애들이어야한다 \r\n* Bounded Waiting (유한한 대기. 언젠간 들어갈 수 있게)\r\n  * 어떤 프로세스가 크리티컬 섹션에 들어가고 싶어서 request를 날렸을 때 바운디드 웨이팅에 한계가 있다. 즉 무기한 기다리지않는다\r\n\r\n\r\n\r\n#### Critical Section Handling in OS\r\n\r\n> **예시** : 크리티컬 섹션 핸들링이 되지않는다면?\r\n>\r\n> fork()를 하면 next_available_pid를 제공\r\n>\r\n> 만약 두 프로세스가 동시에 fork()를 한다면?\r\n>\r\n> 동시에 next_available_pid에 접근해서 \r\n>\r\n> 방금 생성한 프로세스 p2, p3가 서로 다른 프로세스임에도 같은 프로세스 아이디를 가져갈 수도 있다\r\n\r\n\r\n\r\n* preemptive(cpu를 뺏어갈수있는 스케줄링)\r\n  * 어떤 프로세스가 커널모드에서 run하고 있을 때 cpu를 뺏는게 가능\r\n  \r\n* non-preemptive (능동적)\r\n  * cpu 뺏는게 안됨\r\n  * 특정 프로세스가 커널모드를 끝날 때까지 or 양보할 때까지 동작하는게 보장이 됨\r\n  * 커널 안에서의 작업이 **완전히 끝나는 것을 보장**\r\n  * 애초에 critical problem, race conditions가 발생하지않음\r\n  * 일을 하는중에 누군가 뺏어가지않음\r\n  * **문제가 생기는건 preemptive한 커널 구조**\r\n  \r\n  \r\n\r\n어떤식으로 해결해야할까?\r\n\r\n### Peterson's Solution\r\n\r\n* 고전적인 소프트웨어 기반 해결책. 현대에는 적용할 수 없음\r\n* 두 개의 프로세스가 동시에 크리티컬 섹션에 들어갈때(두 개의 프로세스일때만 가능. 여러개는 못함)\r\n* 로드, 스토어 명령어는 atomic하다고 가정. = 명령어 중간에 껴들어갈수없다\r\n* 싱글 cpu가정\r\n* 두가지변수사용\r\n  * int turn : 누구 순서인지\r\n  * bool flag[2] : \r\n    * flag[i] == True이면 Pi가 크리티컬 섹션에 들어갈 준비가 되었다는 뜻\r\n  * turn = j; #양보함 -> turn이 j로 바뀌어서 while문을 빠져나옴?\r\n  * pj가 다 끝나면 flag i를 다시 false로 바꿔줌??\r\n  * (while flag[j] && turn == j ) : 기다림\r\n  * i가 크리티컬 섹션에 들어갈 수 있을 때는\r\n  * 1. 상대방이 준비가 안됐을때\r\n    2. 나의 턴일 때\r\n\r\n> while문과 critical section이 별개인듯\r\n>\r\n> 먼저 순서를 양보해서 j가 준비되었고 턴이 j면 i는 while문을 계속 돎\r\n>\r\n> j의 크리티컬 섹션이 끝나서 flag[j] = false가 되면 i가 while문을 빠져나오고 크리티컬 섹션에 진입\r\n\r\n\r\n\r\n그러나 현대 컴퓨터에서 쓰일 수 없음...\r\n\r\n가장 큰 이유는 reorder때문\r\n\r\n아무리 순차적으로 코드를 짰어도 그거에 디펜던시가 없으면 컴퓨터가 효율성을 위해서 리오더링할 수 있음\r\n\r\ncpu가 알아서 turn을 먼저하고 flag를 나중에 해버림\r\n\r\n\r\n\r\n#### Critical Section with Disable/Enable Interrupt\r\n\r\n어떻게 막을 수 있을까?\r\n\r\n누군가 크리티컬 섹션에 진입했을때 인터럽트를 막아버림\r\n\r\n인터럽트 : 컨텍스트 스위칭을 유발할 때 생김\r\n\r\n컨텍스트 스위칭을 하기위해 인터럽트를 보냄\r\n\r\n인터럽트를 막았기 때문에 컨텍스트 스위칭이 되지않음(p1에서  p2로 넘어가지않음)\r\n\r\n* 그러나 인터럽트를 disable/enable 하는 것은 너무 강력한 메소드!\r\n\r\n* 이거 하려고... 인터럽트... 다 막으려고...~?\r\n* 벼룩잡으려다 초가삼간 태우는 꼴!\r\n\r\n> 소프트웨어만으로는 해결하기 힘든 문제\r\n>\r\n> 하드웨어의 도움이 필요하다!\r\n\r\n## Synchronization Hardware\r\n\r\n### Hardware Instruction : test_and_set\r\n\r\n* atomic = non-interruptible한 instruction\r\n\r\n* 어떤 메모리에서 테스트 값을 가져와서 그 값을 바꾸는 일도 함\r\n\r\n\r\n\r\nboolean test_and_set (boolean \\*target)\r\n\r\n> target을 받아서 값을 가져옴\r\n>\r\n> 타겟을 true로 만듦\r\n>\r\n> 받은 target값을 그대로 return\r\n>\r\n> \\# test : 얘가 원래 true였는지 false였는지 테스트\r\n>\r\n> \\# set : target을 true로 셋~ \r\n\r\n\r\n\r\n> 예시\r\n>\r\n> lock = target, lock은 공유변수\r\n>\r\n> 초기 lock값은 false\r\n>\r\n> tas()의 리턴값이 false라서 while문을 빠져나오지만\r\n>\r\n> lock이 true 로 set되어서 다른애들은 크리티컬 섹션 들어가지못함\r\n\r\n\r\n\r\nos 개념, 컨셉 이론. 전체적인 개념을 묻는 문제가 많이 나올것\r\n\r\n"},{"excerpt":"7-1 스레드! 멀티스레드! 스레드를 어떻게 구현하는지! 스레드라는게 왜 나왔나요? cpu 하나의 성능 개선 : 한계에 다다름 cpu를 여러개? 멀티 코어 = 멀티 프로그래밍 여러개의 프로그램을 돌릴 수 있게 됨 A와 B가 각기 다른 일을 수행(멀티 프로그래밍) 여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드) 여러개의 코어에서 한 프로그램…","fields":{"slug":"/7-1/"},"frontmatter":{"date":"April 22, 2022","title":"os 7-1","tags":["OS"]},"rawMarkdownBody":"\r\n7-1\r\n\r\n스레드! 멀티스레드! 스레드를 어떻게 구현하는지!\r\n\r\n#### 스레드라는게 왜 나왔나요?\r\n\r\ncpu 하나의 성능 개선 : 한계에 다다름\r\n\r\ncpu를 여러개? 멀티 코어 = 멀티 프로그래밍\r\n\r\n여러개의 프로그램을 돌릴 수 있게 됨\r\n\r\n1. A와 B가 각기 다른 일을 수행(멀티 프로그래밍)\r\n2. 여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드)\r\n\r\n여러개의 코어에서 한 프로그램이 하는 일을 분배해서 수행\r\n\r\n#### 스레드가 생기고 나온 문제\r\n\r\n- Dividing activites (일을 어떻게 나눌지)\r\n- Balance (혼자 팀플 ...)\r\n- Data splitting (데이터를 어떻게 나눠줄지)\r\n- Data dependency (한 명이 수정했는데 다른 사람들이 그 수정한 파일에 기반을 두고 있을 경우 어떻게 할 것 인지)\r\n- Testing and debugging\r\n\r\nParallelism : 여러 코어에서 동시에 수행 (멀티 코어)\r\n\r\nConcurrency : 하나의 코어에서 수행\r\n\r\n#### 기존 프로세스의 특성\r\n\r\n**하나의 프로세스는 두 가지 특성으로 나눌 수 있다**\r\n\r\n_an execution stream in the context of a particular process state(resource)_\r\n\r\n- unit of resource ownership\r\n\r\n> resource ownership을 가진 애를 process라고 부르자!\r\n\r\n- unit of execution stream\r\n\r\n> execution stream은 나눌 수 있지않을까?\r\n>\r\n> 외부에서 돌아가는 excuted stream을 thread라고 부르자!\r\n>\r\n> 하나의 프로그램 안에서 execution stream을 여러 개로 나눔\r\n\r\n- execution stream이 여러 개라면 각각의 stack과 register가 필요하다! stack, reg 스레드마다 분리 (code, data, files는 공유함)\r\n\r\n#### 스레드의 특징\r\n\r\n- 스레드는 state 3개 (running, ready, stopped(brocked = wait))\r\n\r\n  - 그럼 생성 종료는 어떻게?\r\n\r\n    실제로 os상에서 구현할 때는 라이브러리 같은걸 제공하게되는데 거기서는 생성, 종료 state를 추가적으로 만들긴함. 기본적인 state임 신경안써도 ㄱㅊ\r\n\r\n- 프로세스 state는 5개 (new, run, wait, ready, terminate)\r\n\r\n- 프로세스가 termination되면 당연히 그 안의 스레드도 termination\r\n\r\n- 스레드마다 context(reg, stack에 대한 정보들)를 따로 관리해야한다\r\n\r\n- stack이 따로 있고 static memory(for local vairables)도 존재할수도 있음\r\n\r\n- 그러나 사실상 접근하는 메모리 공간은 process의 메모리 공간에 공유함\r\n\r\n  ![](./thread.png)\r\n\r\n  - 프로세스의 모든 스레드들은 이걸 공유함 (그림의 share부분 참고)\r\n\r\n- 여러 os에서 다양한 형태의 스레드를 사용한다\r\n- MS-DOS : 싱글유저 - 싱글스레드\r\n- 초창기 유닉스 : 여러 개의 프로세스 but 프로세스당 스레드 하나\r\n- 현대 유닉스 : multiple threads\r\n\r\n멀티스레드 어디서 사용? 보통서버 아키텍처에서 많이사용\r\n\r\nex. 이메일 서비스\r\n\r\n![](./email.png)\r\n\r\n멀티스레드.......... vs 멀티프로세스\r\n\r\n뭔 차이냐....... 이 말이여\r\n\r\n프로세스 생성에 대한 오버헤드가 큼! 프로세스에 필요한 공간 할당. 메모리에 올려야 함\r\n\r\n멀티 스레드는 a,b,c도 같은 프로세스안에서 돌게하므로 성능상의 이득을 취하면서도 프로세스 생성에 대한 오버헤드도 줄일 수 있다!\r\n\r\n#### 멀티 스레드의 이점\r\n\r\n- Responsiveness(응답성)\r\n\r\n  - 위 예시에서 싱글스레드는 a를 처리해야 b처리 가능\r\n\r\n- Resource sharing\r\n  - 멀티 프로세스의 경우 각기 독립적인 메모리 공간을 사용\r\n\r\n> 멀티 프로세스는 각각 abc리퀘스트를 처리하기 위해서 프로세스를 따로 만들어줌. 각기 독립적인 메모리 공간. 따라서 프로세스들간 소통을 하기위해선 커널을 거쳐서 shared memory 나 message passing을 통해서 소통해야함\r\n>\r\n> 그러나 멀티 스레드는 같은 프로세스안 Resourcce sharing에 유리.\r\n\r\n- economy\r\n\r\n  - takes less time\r\n\r\n     뉴 스레드를 만드는게 프로세스를 만드는 것보다 빠름\r\n\r\n     프로세스는 모든 컨텍스트를 새로 만들고 초기화\r\n\r\n     스레드는 스레드 컨텍스트(stack)만 서로 만듦\r\n\r\n     마찬가지로 종료도 스레드가 유리\r\n\r\n     한 프로세스내에서 두 개의 컨텍스트를 스위치하는 시간도 빠름\r\n\r\n    코어가 늘어나는것에대해서 성능도 증가\r\n\r\n  - Uses very little resources\r\n\r\n    스레드가 필요한건스택과 per-thread staticy memory 뿐\r\n\r\n스레드가 많아지면 멀티프로세서같이 코어가 많은 아키텍처에서는 프로세스가 advantage를 얻을 수 있다\r\n\r\n## Threads Implementation\r\n\r\n1. user-level : 사용자가 코드에 작성하는 것(사용자가 나눈 일의 단위)\r\n2. kernel-level : 커널이 관리하는 스레드(cpu 자원 할당 단위)\r\n\r\n두 개를 나눠서 구현하게 됨\r\n\r\n### User-Level Threads : Multi thread using only user-level thread\r\n\r\n- 100% 유저 레벨\r\n\r\n- 커널은 얘의 존재를 모름. 커널이 보기에는 프로세스 하나\r\n\r\n- 유저레벨에서 코드를 나눠서 작성함\r\n\r\n- 이걸 위해 user-level library 존재\r\n\r\n**user-level library**\r\n\r\n    - 스레드 만들고 소멸\r\n    - 스레드간의 스케줄링\r\n    -\r\n    - 스레드 컨텍스트 스위칭될 때 컨텍스트를 saving and restore\r\n    - 스레드 간의 데이터 소통\r\n\r\n실질적으로 cpu할당은 프로세스단위로 이루어짐\r\n\r\n- 어플리케이션은 유저레벨 스레드를 사용해서 모든 스레드를 관리한다\r\n- 스케줄링도 어플리케이션안에서 다 함 ( 어플리케이션 맞춤)\r\n- 커널은 유저레벨스레드의 존재를 모르고 프로세스 하나가 동작하는줄 앎\r\n- 어떤 스레드가 blocking system call을 할 때 커널은 그 프로세스를 통째로 block, waiting시킨다\r\n- 장점\r\n  - 스레드간 스위칭을 할 때 커널이 관여를 안함 (오버헤드 없음 mode switching없음 usermode <-> kernel mode)\r\n  - 스케줄링이 베스트 알고리즘을 선택할 수 있다\r\n  - os에서 스레드모드를 지원하지않아도 라이브러리만 있으면 구현을 할 수 있다\r\n- 단점\r\n  - 어떤 스레드가 시스템콜을 날리면 모든 스레드가 block\r\n  - 코어가 여러개여도 활용을 모함 (한 책상을 여러명이 돌려씀)\r\n- 사실상 초기 스레드 모형이며 지금은 사용하지않음. 너무 구림\r\n\r\n### Kernel-Level Threads\r\n\r\n- one to one mapping between user-level and kernel-level\r\n- 유저레벨 스레드와 커널레벨 스레드가 둘 다 존재\r\n- 유저레벨 스레드와 커널레벨 스레드가 1대1 매핑\r\n- 유저 레벨 스레드 라이브러리를 쓰지않고 커널의 기능을 호출(api - kernel function)\r\n  - 커널이 프로세스뿐만아니라 스레드에 대한 컨텍스트 정보도 유치\r\n  - 스레드간 스위칭 지원\r\n  - 스레드 스케줄링\r\n  - synchronization\r\n- 사용자가 어플리케이션 내부적으로 따로 스레드를 생성하고 관리하는건 없고 사용자가 스레드를 만들고싶을 때는 시스템한테 요청을 함. 시스템이 스레드를 관리를 온전히 다 한다. 유저레벨에선 관리할 필요가 없음.\r\n- cpu 자원할당이 스레드 위주로 돌아감\r\n- 모든 스레드를 커널이 관리\r\n- 코드에서 유저레벨 스레드를 생성하면 실제 커널 레벨 스레드가 생성된다는 말\r\n- 장점:\r\n  - 여러개의 스레드를 여러개의 cpu코어에서 동시에 돌릴 수 있다\r\n  - 어떤 스레드 하나가 block되어도 다른 스레드가 돌아간다\r\n  - 커널에 대한 여러가지 루틴들도 멀티스레드처럼 만들 수 있다(뭔 소리?)\r\n- 단점:\r\n  - 스레드 스위칭자체가 컨텍스트 스위칭과 같은 오버헤드를 야기한다\r\n- modern linux, windows가 원투원 매핑 사용\r\n\r\n### Combined Threads\r\n\r\n`Many-to-Many`\r\n\r\n커널레벨모드도 유저레벨모드도 존재\r\n\r\n유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다\r\n\r\n커널은 사실상 스레드의 존재를 크게 의식하지않음\r\n\r\n커널은 단지 유저에게 virtual processor같은\r\n\r\n커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 스케줄링하고 관리해줌\r\n\r\n유저레벨 스레드는 커널레벨 스레드가 가상의 프로세서라고 생각하고 활용\r\n\r\n어떤 스레드를 어떤 프로세서에 넣을지 관리를 해줌\r\n"},{"excerpt":"Dispatcher os의 프로세스를 구동하는 부분의 가장 안쪽이다 디스패처의 역할! 어떤 프로세스를 돌리고 스탑, 상태 세이브 다른 프로세스의 스테이트를 로드해옴 switching context switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유…","fields":{"slug":"/4-2/"},"frontmatter":{"date":"April 21, 2022","title":"4-2","tags":["OS"]},"rawMarkdownBody":"\r\n## Dispatcher\r\n\r\nos의 프로세스를 구동하는 부분의 가장 안쪽이다\r\n\r\n> 디스패처의 역할!\r\n>\r\n> 어떤 프로세스를 돌리고\r\n>\r\n> 스탑, 상태 세이브\r\n>\r\n> 다른 프로세스의 스테이트를 로드해옴\r\n\r\n\r\n\r\n* switching context\r\n\r\n* switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유저모드)\r\n\r\n* 적절한 위치로 점프 (새로운 프로세스의 실행해야할 위치, load state로 점프)\r\n\r\n\r\n\r\n디스패치는 사실 수동적\r\n\r\n\r\n\r\n### 디스패처는 어떻게 컨트롤을 유지할 수 있을까?\r\n\r\n>  cpu는 한 번에 하나의 일만 할 수 있다\r\n>\r\n> 유저 프로세스가 실행되고 있다는 말은 디스패처가 실행되고있지않다는 말\r\n>\r\n> 그럼 어떻게 디스패처를 컨트롤할까?\r\n\r\n* 📌 non-preemptive way : 프로세스가 디스패처를 깨워줄거라고 믿음\r\n* 📌 preemptive way : 디스패처가 일정시간마다 깨어나서 프로세스를 쫓아냄\r\n* interrupt, traps and faults에 의해 호출됨\r\n* ex. interrupt (하드웨어)\r\n  * 터미널에서 문자입력\r\n  * 디스크에서 읽어오는거 끝남 (I/O)\r\n  * 타이머\r\n* Traps and Faults(소프트웨어) - 프로세스가 os한테 요청\r\n  * 시스템 콜 : process가 os한테 어떤일을 해달라고 요청\r\n  * floating  : 계산불가능. os가 처리\r\n  * page fault\r\n\r\n\r\n\r\nnonpremmtive는 완벽하지않음. 프로세스가 자리 안내줄수도있음. \r\n\r\n그래서 preemptive가 필요\r\n\r\n \r\n\r\n## Scheduling Policy\r\n\r\n1. 프로세스 테이블을 스캔해서 돌 수 있는애를 앉힌다 \r\n   * 시간이 오래 걸림\r\n2. 레디큐의 제일 첫번째에 있는 프로세스를 실행\r\n3. 레디큐에서 우선순위가 높은 것을 실행\r\n\r\n* 우선순위를 결정하는게 policy\r\n* 왜 디스패처가 하지않을까?\r\n  * policy와 mechanism을 분리하기위해\r\n\r\n \r\n\r\n## Context Switching\r\n\r\n* 디스패처가 기존의 state를 save하고 restore하는 것을 context switch mechanism을 통해 구현한다\r\n* 다음 프로세스가 건들여서 손상을 일으킬 것 같은 모든 것을 저장한다.... 걍 웬만하면 다 저장?\r\n  * Program counter\r\n  * Processor status word(condtion codes 등)\r\n    * 프로세스가 사용하던 cpu상태 정보\r\n  * 레지스터들\r\n  * 메모리는 정리하지않아도 될까? (책장)\r\n  * 메모리는 저장하기에 너무 크고 비용이 큼\r\n  *  memory management part가 별도로 담당하기때문에 context switching에서는 고려하지않는다\r\n\r\n\r\n\r\n## Context Switching Implementation\r\n\r\nmachine... 에 따라 다른 컨텍스트 스위칭 수행존재...\r\n\r\nos마다 구현하는 방법에 따라 다름\r\n\r\n\r\n\r\nstatus를 메모리에 옮김\r\n\r\n메모리의 어디에? 스택 or PCB\r\n\r\n* 스택 : 프로세스가 사용하는 메모리 공간\r\n* PCB : os가 사용하는 메모리 공간\r\n\r\n\r\n\r\n뒤에 예시 그림은 stack\r\n\r\n* before interrupt\r\n\r\n* interrupt call\r\n\r\n  수행중이던 프로세스 멈추고 prcoess status word를 넣고 그 다음 return addr(=pc)를 넣음\r\n\r\n* PUSHA instruction\r\n\r\n  책상에 있는걸 다 책장에 정리해야함\r\n\r\n​\t\t레지스터 정보를 모두 스택에 저장\r\n\r\n​\t\t단 %rsp는 원래  return addr를 가리키던 n이었으나 레지스터 정보를 넣고 n-a로 업데이트된다(실제로는 n-a까지 들어갔지만 스택에는 n이 들어가버림) \r\n\r\n* Saving stack pointer\r\n\r\n​\t\t**그래서 %rsp는 os-PCB의 StkPtr에 저장**\r\n\r\n* Selecting Next Process\r\n\r\n  scheduling policy는 OSPCBCur가 새 프로세스 OS-PCB의 StkPtr을 가리키게함\r\n\r\n  OS-PCB의 StkPtr값을 CPU's StkPtr에 넣음\r\n\r\n* POPA instruction\r\n\r\n  새 프로세스의 스택에 있는 레지스터들을 전부 가져옴\r\n\r\n  그 다음 return addr과 PSW도 가져온다\r\n\r\n\r\n\r\nSelecting Next Process과정에서 만약 새 프로세스가 처음 생성된 애, empty 스택이라면?\r\n\r\n스택이 비었다면 디스패처 오류\r\n\r\n시스템은 처음 생성된 프로세스에게 임시로 stack에 할당해줌 디폴트값\r\n\r\n\r\n\r\n## CPU Scheduling\r\n\r\n## Scheduling Policy\r\n\r\n우선순위 기준점\r\n\r\n* cpu utilization : 책상 사용량을 증대!\r\n* throughput : 주어진 시간동안 몇 개의 프로세스가 일을 했냐\r\n* turn around time : 특정프로세스가 일을 하고 싶은데 얼마나 자주? 보통 낮으면 좋지만 무조건적인건아님\r\n* waiting time : 기다리는 시간\r\n* response time : 프로세스한테 job을 요청했는데 job이 끝날때까지의 시간. 프로그램 종료를 뜻하는건 아님. 특정 동작\r\n\r\n\r\n\r\n### First-Come, First-Served(FCFS)\r\n\r\nfifo라고도 불림 first in first out\r\n\r\n먼저 왔으면 먼저 내보냄\r\n\r\n문제 : 앞에 애가 엄청 오래걸리는 애인데 뒤에 애들은 몇 초만에 끝날 때-monopolize, Convoy effect\r\n\r\n해결방안 : 먼저 온 애를 먼저 앉히되, 특정 시간동안만 일하게하고 다음에 부름 - maximum time을 **timeslice**라고 함\r\n\r\ntime slice외에 I/O요청등에 의해 내려오는 경우도 있음. 이걸 blocked됐다고 말함\r\n\r\n\r\n\r\n### Shortest Job First(SJF)\r\n\r\n그럼 짧은 애부터 실행하자!ㅎㅎ\r\n\r\n"},{"excerpt":"DoS attack : 서비스 거부 공격 취약점 공격형 Boink, Bonk, TearDrop Land 자원 고갈형 Ping of death SYN flooding HTTP flooding Smurf Mail bomb TearDrop TCP 오류 제어 로직의 불완전한 구현을 악용 클라이언트 측에서 의도적으로 패킷의 시퀀스 넘버와 길이를 조작 패킷들이 부분…","fields":{"slug":"/dos-attack/"},"frontmatter":{"date":"April 20, 2022","title":"7-1 DoS attack","tags":["computer protection"]},"rawMarkdownBody":"\r\n## DoS attack : 서비스 거부 공격\r\n\r\n- 취약점 공격형\r\n  - Boink, Bonk, TearDrop\r\n  - Land\r\n- 자원 고갈형\r\n  - Ping of death\r\n  - SYN flooding\r\n  - HTTP flooding\r\n  - Smurf\r\n  - Mail bomb\r\n\r\n### TearDrop\r\n\r\n- TCP 오류 제어 로직의 불완전한 구현을 악용\r\n- 클라이언트 측에서 의도적으로 패킷의 시퀀스 넘버와 길이를 조작\r\n- 패킷들이 부분적으로 겹치거나 빠진 패킷이 있어 reassemble 불가\r\n\r\n> 대응\r\n>\r\n> - 수신되는 패킷의 frame alignment를 확인하여 filtering\r\n\r\n### LAND (local area network denial) Attack\r\n\r\n- 일종의 packet spoofing 공격\r\n- source 와 destination IP address 를 모두 target host 의 IP address로 설정하고 TCP SYN 패킷을 전송\r\n- target host는 자신에게 지속적으로 응답을 하게됨( 보내는 사람도 나... 받는 사람도 나...?)\r\n\r\n> 대응\r\n>\r\n> - source와 destination IP address 유효성 검증\r\n\r\n---\r\n\r\n### Ping of Death\r\n\r\n- ping 명령어에 최대한 긴 패킷을 실어서 공격 대상에게 전송\r\n- IPv4 패킷 크기는 65535 바이트까지 가능하나 경유 네트워크 특서엥 따라 전송중에 수백 - 수천개의 패킷으로 분할됨\r\n- 분할된 패킷이 다시 합쳐져서 전송되는 일은 거의 없으므로 공격 대상 시스템은 대량의 작은 패킷을 수신하게 됨\r\n\r\n> 대응\r\n>\r\n> - 주로 방화벽에서 ping이 사용하는 ICMP를 차단하여 해결\r\n\r\n### SYN flooding\r\n\r\n- 시스템에서 허용하는 동시 사용자 수 제한과 TCP 3-way handshake 특성을 악용\r\n- 공격자는 가상의 클라이언트로 위조한 SYN 패킷을 여러 개 만들어 서버에 보냄으로써 서버의 가용 동시 접속자 수를 모두 점유 ( 모두 SYN Received 상태로 만듦)\r\n\r\n> 대응\r\n>\r\n> - SYN Received 상태의 대기 시간을 줄이는 등 다양한 해법 존재\r\n\r\n### HTTP flooding\r\n\r\n웹 서버에 대한 도스/디도스 공격\r\n\r\n**기본적인 공격**\r\n\r\n- Get flood\r\n  - image와 같은 특정 static content를 지속적으로 요구\r\n- POST flood\r\n  - 서버 내의 database 검색 등 특정 동작을 지속적으로 요구\r\n\r\n> 대응\r\n>\r\n> - traffic profiling(특정적인 HTTP 요청 패턴을 검출하고 차단)\r\n\r\n**보다 진화된 공격**\r\n\r\n- slow HTTP POST (= RUDY (RU-Dead-Yet?))\r\n  - 서버가 POST 데이터를 모두 수신하지 않았다고 판단하면 전송이 다 이루어질때 까지 연결을 유지하는 특성을 활용, POST 메소드로 대량의 데이터를 장시간에 걸쳐 분할 전송하여 연결을 장시간 유지함으로써 서버의 자원 잠식\r\n  - 예를 들어 Content-Length를 100000byte로 하고 데이터는 일정한 간격으로 1byte씩 전송\r\n- slow HTTP header (slowloris attack)\r\n  - HTTP header 정보를 비정상적으로 조작하여 웹서버가 완전한 header 정보를 기다리도록 함\r\n  - 예를 들어, HTTP에서 header의 끝을 개행문자 /r/n (CR LF)로 구분하므로, header 시작 후 개 행 문자 없이 의미없는 문자열을 보내면 서버는 계속 연결을 유지\r\n\r\n> 대응\r\n>\r\n> - 세션 임계치 설정, 세션 타임아웃 시간 제한\r\n\r\n### Smurf attack\r\n\r\n- Direct broadcast\r\n  - 기본적인 broadcast는 destination IP address 255.255.255.255로 패킷을 전송하며, 이는 라우터 경계내에서만 동작함\r\n  - direct broadcast: 라우터를 넘어가서 broadcast를 해야 하는 경우 IP address 의 일부분만 broadcast 주소로 채움\r\n- Smurf attack\r\n  - Direct broadcast를 악용하여, source IP address를 특정 주소(피해자 의 IP address)로 조작한 ICMP request 를 broadcast\r\n  - 피해자는 수많은 ICMP reply를 받아 과부하 상태가 됨\r\n\r\n> 대응\r\n>\r\n> - 각 호스트와 라우터들로 하여금 broadcast address 일 경우 무시하도록 설정\r\n"},{"excerpt":"Compilation System Compilation System Pre-processing : c코드 형태, #include, define등 전처리 컴파일러 : 어셈블리어 형태로 어셈블러 : 기계어 형태로 링커 : 여러 코드파일들을 하나의 실행파일로 합쳐줌 ex. printf.o + hello.o excutable 파일 text segement: 기계…","fields":{"slug":"/3-1/"},"frontmatter":{"date":"April 20, 2022","title":"3-1","tags":["OS"]},"rawMarkdownBody":"\r\n## Compilation System\r\n\r\n## Compilation System\r\n\r\n- Pre-processing : c코드 형태, #include, define등 전처리\r\n- 컴파일러 : 어셈블리어 형태로\r\n- 어셈블러 : 기계어 형태로\r\n- 링커 : 여러 코드파일들을 하나의 실행파일로 합쳐줌 ex. printf.o + hello.o\r\n\r\n### excutable 파일\r\n\r\ntext segement: 기계어\r\n\r\ndata segment : global 변수들, read only data(string), system data\r\n\r\n%rbx : 레지스터\r\n\r\n(%rbx) : 메모리\r\n\r\n## Stack\r\n\r\n- 지역변수나 함수간에 주고받는 인자등을 저장해둠\r\n- 레지스터에 모든 데이터를 다 담아둘 순 없으니까\r\n- top 방향으로 쌓이고 없어질때도 top부터 없어짐\r\n- bottom이 address high임 띠용\r\n- top의 주소만 알면 push, pop가능\r\n\r\n- **%rsp가 stack의 top을 가리키고 있다**\r\n\r\n- push src\r\n\r\n  %rsp 8 감소\r\n\r\n- pop dst\r\n\r\n  %rsp 8증가\r\n"},{"excerpt":"Process 여기부터 중요하네 ... os는 프로세스를 중심으로 관리 Process Concept program은 passive process는 active 컴퓨터내에서 돌아가는 일의 단위 실행중인 프로그램 특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름 excution stream : 한줄한줄 실행하고있는 바로 그 상태! proces…","fields":{"slug":"/3-2/"},"frontmatter":{"date":"April 20, 2022","title":"3-2 프로세스 탐구","tags":["OS"]},"rawMarkdownBody":"\r\n## Process\r\n\r\n여기부터 중요하네 ...\r\n\r\nos는 프로세스를 중심으로 관리\r\n\r\n## Process Concept\r\n\r\n> program은 passive\r\n>\r\n> process는 active\r\n\r\n컴퓨터내에서 돌아가는 일의 단위\r\n\r\n실행중인 프로그램\r\n\r\n**특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름**\r\n\r\nexcution stream : 한줄한줄 실행하고있는 바로 그 상태!\r\n\r\nprocess state : 아래 참고\r\n\r\n프로그램 : 실행시키기전까지는 프로그램\r\n\r\n코드 시퀀스. 기계어의 나열\r\n\r\n프로그램을 실행시킨게 프로세스\r\n\r\n실행되서 메모리에올라가서 한줄한줄 실행중~><\r\n\r\n프로그램은 여러개의 프로세스가 될 수 있다. ex. 크롬 브라우저 여러개 생성\r\n\r\n### process state (= process context)\r\n\r\n- Memory context\r\n- Hardware context\r\n- System context\r\n\r\n0과 max는 메모리 상대주소를 가리킴\r\n\r\n#### Memory context\r\n\r\n- text : 컴파일 되어서 기계어로 된 code와 data\r\n- 파일안에 이미 존재하고 있는 data : 글로벌 변수\r\n\r\n- stack : 지역변수, 함수인자, 함수호출되고 리턴될 주소\r\n\r\n- heap : 동적으로 할당된 data (ex. new malloc)\r\n\r\n(도서관 관리)\r\n\r\n#### Hardware context\r\n\r\nCPU register, I/O registers\r\n\r\n(도서관 관리)\r\n\r\n#### System context\r\n\r\nProcess table, open file table, page table\r\n\r\n(책장 주변 환경 관리)\r\n\r\n### 📌 Multiprogramming vs Multiprocessing\r\n\r\n- 유니 프로그래밍 : 하나의 프로세스가 메모리에 올라간다\r\n\r\n- 멀티 프로그래밍 : 메모리 관점! 메모리에 여러개가 올라가는가\r\n\r\n  동시에 여러 개의 프로그램이 실행되어서 메모리안에 여러개의 컨텍스트를 올려놓은 상태\r\n\r\n ![](./uni-multi.png)\r\n\r\n- 멀티 프로세싱 : cpu 관점 - cpu가 여러 프로세스를 동시에 번갈아가며 처리하고있는가\r\n\r\n 여러 개의 프로세스가 cpu를 번갈아가며 사용하면서 실행중. cpu가 multiplexed됨\r\n\r\ncpu를 쓰려는 프로세스들을 관리할 방법이 필요하다!\r\n\r\n각각의 프로세스들을 관리하기위해 만든게 process control block\r\n\r\n### 📌 Process Control Block\r\n\r\n- process state\r\n\r\n- program counter : 몇 번째 라인을 수행중인지\r\n\r\n- 레지스터들\r\n\r\n- 스케줄링 information\r\n\r\n  등등...\r\n\r\n각각의 프로세스에게 할당되어있다!\r\n\r\nos는 이 프로세스 컨트롤 블록을 보고 프로세스를 관리\r\n\r\n### 📌 Process table\r\n\r\n각각의 프로세스들의 pcb를 모아둔것들\r\n\r\n초창기 유닉스는 pcb를 array로 구현\r\n\r\n길이가 고정되어있어서 일정 길이 이상으로 늘어나지못함\r\n\r\n지금은 linked list형태로 사용중\r\n\r\n### 📌 Process State (좀 더 자세하게...?)\r\n\r\n앞에 있는건 context라고 하기로 하자...\r\n\r\n얘는 진짜 딱 프로세스의 상태\r\n\r\n- new : 프로세스 생성\r\n- running : 레디들중에 선택\r\n- waiting : running중 cpu에서 나와야 할 때 (ex. I/O or event wait)\r\n- ready :\r\n  - new하고 성공적으로 만들어지면 옴\r\n  - 러닝중 인터럽트\r\n- terminated : 프로세스 종료\r\n\r\nprocess life cycle\r\n\r\n큐를 사용해서 구현\r\n\r\n### 📌 State Transition\r\n\r\n- Ready queue\r\n\r\n  말그대로 레디중인애들\r\n\r\n- Device quete (I/O waiting queue)\r\n\r\n  I/O이벤트등으로 디스크를 기다리고 있는 프로세스들... 각각의 이유별로 큐를 만들어서 따로 관리\r\n\r\n- job queue\r\n\r\n 시스템에 있는 모든 프로세스들을 따로 만들어놓은 큐\r\n\r\n- 이 linked list를 구현할때 그냥 pcb를 가져와서 구현함\r\n\r\n- cpu에서 일하고있는 큐는 위 셋 중 어떤 큐에도 들어가있지않다\r\n\r\n- 시간이 다 돼서 쫓겨난 애들은 레디큐로\r\n\r\n### 📌 Schedulers\r\n\r\n레디큐에서 cpu로 보낼애를 선택하는 법\r\n\r\n- 📌 Short-term scheduler (= CPU scheduler)\r\n  - 어떤애를 cpu로 보낼건지!\r\n  - 짧은 시간 간격으로 돌면서 다음애 돌 애를 지속적으로 바꿔줌\r\n  - 밀리세컨드 이하로 반복\r\n  - 여러개의 프로세스가 동시에 움직이는 것 같지만 사실은 밀리세커드 단위로 바뀌고 있는 것\r\n  - 자주 호출돼서 빨라야 함!\r\n- long-term scheduler (= job scheduler)\r\n  - 없는 os도 있음\r\n  - 레디큐에 넣을 프로세스들을 선별\r\n  - cpu scheduler가 본선느낌이라면 얘는 예선느낌\r\n  - 하나의 컴퓨터에서 너무 많은 프로세스를 만들어버리면 pcb도 많아짐... 책장 부족!\r\n  - degree of multiprogramming : 멀티프로그래밍의 정도를 나눔. 프로그램 몇 개가 메모리에 있을지 결정\r\n\r\n#### 📌 스케줄러를 위한 프로세스의 두 종류\r\n\r\n- I/O-bound process\r\n  - I/O 요청을 처리, 대기하는데 시간이 많이 걸림\r\n- CPU-bound process\r\n  - I/O는 모르겠고~ cpu를 오래써야 끝날 수 있는 프로세스\r\n\r\n job scheduler는 저 두 개를 적절히 섞어준다\r\n\r\n### CPU Switch From Process to Process\r\n\r\n#### 📌 Context switch\r\n\r\n1. 원래 돌고 있던 프로세스의 컨텍스트를 save\r\n\r\n2. 새로 올 프로세스의 컨텍스트를 가져옴\r\n\r\n- 오버헤드. 스위치하는동안에는 누구도 일을 하지 않음\r\n- 자주 일어나면 안좋음\r\n- 이걸 위해 레지스터를 여러개 구비해놓기도. (책을 치우고 갈 필요가 없음)\r\n\r\n## 📌 Process Creation & Termination\r\n\r\n> 두 가지 방법 존재\r\n>\r\n> 1. 새로운 프로세스 만들기\r\n> 2. 클론하기\r\n>\r\n> 보통 클론\r\n\r\n- 📌 process creation :\r\n\r\n  1. disk storage에서 프로그램의 code, data를 읽어 메모리에 넣는다\r\n  2. stack공간을 만든다(empty stack)\r\n  3. pcb 만들고 초기화\r\n  4. 레디큐에 프로세스를 넣는다\r\n\r\n- 리눅스는 컴퓨터 부팅될 때 첫 프로세스만 이렇게 만듦\r\n\r\n- 나머지 프로세스는 기존의 프로세스를 클론해서 만든다\r\n\r\n- 기존에 있던 메모리 공간을 그대로 복사해온다\r\n\r\n- 복사하고 exec()을 통해 새로운 프로그램을 메모리에 올려버린다(이걸 안하면 기존 것과 똑같은 프로그램)\r\n\r\n- 프로세스를 만드는 시간이 줄어든다! 개이득!\r\n"},{"excerpt":"fork() fork()라는 system call은 new process를 생성한다 (cloning) system call : 사용자가 os커널한테 요청하는 api fork() process 현재 프로세스 중지하고 state를 저장 현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (전부 똑같은건 아니…","fields":{"slug":"/4-1/"},"frontmatter":{"date":"April 20, 2022","title":"4-1","tags":["OS"]},"rawMarkdownBody":"\r\n## fork()\r\n\r\n- fork()라는 system call은 new process를 생성한다 (cloning)\r\n\r\nsystem call : 사용자가 os커널한테 요청하는 api\r\n\r\n#### fork() process\r\n\r\n1. 현재 프로세스 중지하고 state를 저장\r\n2. 현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (**전부 똑같은건 아니고 PID에 차이를 준다. os는 pid를 가지고 구분. fork()의 return value도 바꿔준다**)\r\n3. 새로운 프로세스를 레디큐에 삽입\r\n\r\n#### fork() return value\r\n\r\n1. r < 0 : 오류\r\n2. r > 0 : 부모 프로세스일 경우 chd의 pid를 반환\r\n3. r = 0 : 자식 프로세스일 경우\r\n\r\n## exec()\r\n\r\n새 프로세스의 메모리 공간을 바꿔치기\r\n\r\n(새로운 프로그램의 경로)\r\n\r\nex) execlp(\"/bin/ls\", \"ls\", NULL)\r\n\r\n- 오버헤드 단점 : 복사 비용이 너무 큼\r\n\r\n- COW ( copy on write)\r\n\r\n  전부 복사하지말자!\r\n\r\n 실제로는 pointer structure를 만들어서 부모의 code, data 영역을 가리키게 해줌\r\n\r\n (**stack은 복제해야함** : 두 프로세스를 다르게 관리해야하므로)\r\n\r\n 해당 데이터 영역을 수정해야할때 복제, 부모랑 데이터가 달라지는 순간 실제 복사가 일어남\r\n\r\n windows는 아예 새로 만듦...?\r\n\r\n## Process Termination\r\n\r\n![](./create-terminate.png)\r\n\r\n### exit()\r\n\r\n프로세스가 정상적으로 종료됐는지는 exit()안에 담아서 보낸다\r\n\r\n1. status data를 parent에게 전달\r\n\r\n   parent는 wait()로 받음\r\n\r\n2. 해당 프로세스는 자신의 리소스를 전부 deallocated\r\n\r\n#### exit return value\r\n\r\n- 0이면 정상종료\r\n\r\n- 0이 아니면 비정상 종료\r\n\r\n(사실 os가 진짜 비정상 종료라고 인식하진않고 관습적인... 표현임. 부모 프로세스한테 그냥 0이 아니라고 알려줄뿐)\r\n\r\n- wait() 호출하면 자식의 종료 상태가 wait(\\$status)로 전달\r\n\r\n정상적으로 종료되지않았을 때 exit()외에 abort()라는 시스템 콜을 호출할 수도 있다\r\n\r\n### abort()\r\n\r\n비정상 종료를 명시적으로 호출\r\n\r\n명시적 : 시스템 자체적으로 비정상 알림\r\n\r\nex. 메모리를 과도하게 요청함\r\n\r\n#### 좀비 프로세스\r\n\r\n부모가 wait을 안해줘서, 안거둬줘서 자식이 죽었는데 pcb에 계속 남아 있음\r\n\r\n다른 데이터는 모두 deallocate하고,\r\n\r\n나에게 남은건 부모에게 보낼 exit status뿐...⭐\r\n\r\n#### 고아 프로세스\r\n\r\n부모가 wait을 하기전 먼저 죽음\r\n\r\n1번 프로세스인 init이 좀비랑 고아를 거둬들어서 정상적인 종료를 돕는다\r\n\r\n- 웹 예시\r\n- 여러 개의 탭 : renderer\r\n- 왜 멀티 프로세싱?\r\n- 하나의 프로세스로 하면 특정 페이지의 로딩이 길어질 때 전체의 pending time에 영향을 줌\r\n- 프로세스간 통신 필요 :  📌 **Inter-process Communication (IPC)**\r\n  - 정보 공유 ex. shared memory, message passing\r\n  - 모듈화\r\n\r\n#### 📌 IPC\r\n\r\n**shared memory**\r\n\r\n진짜 같은 메모리의 주소를 공유\r\n\r\n**message passing**\r\n\r\nmessage queue에 메세지를 보냄... 우체통같은거임\r\n\r\n## 📌 CPU 스케줄러\r\n\r\n**하나의 프로세스의 전체 시간은 cpu burst와 I/O burst로 나뉜다**\r\n\r\n- cpu burst(cpu execution) : cpu를 연속적으로 계속 사용하는 상태\r\n\r\n  보통 5ms 이하\r\n\r\n- I/O burst (I/O wait) : I/O를 기다릴 때, I/O를 기다릴 때는 cpu를 사용하지않음\r\n\r\n### 📌 CPU 스케줄러는 언제 실행되나?\r\n\r\n1. I/O 요청을 하고 기다리게 되는 경우 : (running -> waiting) : **nonpreemptive**\r\n2. 계속 돌 수 있는데 쫓겨나는 경우 : (running -> ready) : **preemptive**\r\n3. I/O 요청이 다 끝난 경우 : ( waiting -> ready) : **preemptive**\r\n4. 돌던 프로세스가 종료 : (terminates) : **nonpreemptive**\r\n\r\n1,4번은 현재 cpu에서 돌고있는애가 자리를 내어줌(좀 더 능동적...?) : **nonpreemptive**\r\n\r\n1 : 나 아이오 기다려야돼~\r\n\r\n4 : 나 끝남~\r\n\r\n2,3번은 잘돌고있었는데 영문도 모르고 쫓겨남\r\n\r\n2 : ? 더 돌 수 있는데 시간 끝남\r\n\r\n3 : ? 전에 하던에 아이오끝나서 쫓겨남\r\n\r\ncpu 스케줄러는 policy(shedulling policy)랑 mechanism(dispatcher)을 잘 구별해서 만드는게 중요하다!\r\n\r\n1. 📌 scheduling policy : 선택(한 프로세스) : 여러개가 선택될수도?\r\n2. 📌 dispatcher : 바꿔주는 행동 그 자체\r\n\r\n바꿔주는 동작 그 자체는 계속 쓰면 되지만\r\n\r\npolicy는 시간이 지나면 바뀔수도있음\r\n\r\n하나의 시스템 안에서도 여러가지의 policy를 사용할수도있다\r\n"},{"excerpt":"Multiple Encryption 암호화를 두 번 적용하면 더 강력해지지않을까? 를 실현! 암호화를 두 번 적용 - 키가 두 개 존재 K1를 써서 나온 결과에 또 K2를 써서 암호화 두 번  C = E(K2, E(K1, P )) P = D(K1, D(K2,C)) 파훼법: Meet in the Middle Attack 중간 결과 X = E(K1, P ) …","fields":{"slug":"/multi-enc/"},"frontmatter":{"date":"April 18, 2022","title":"6-2 Modes of Operation","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Multiple Encryption\r\n\r\n암호화를 두 번 적용하면 더 강력해지지않을까? 를 실현!\r\n\r\n암호화를 두 번 적용 - 키가 두 개 존재\r\n\r\nK1를 써서 나온 결과에 또 K2를 써서 암호화 두 번\r\n\r\n![](./multiple.png)\r\n\r\nC = E(K2, E(K1, P ))\r\n\r\nP = D(K1, D(K2,C))\r\n\r\n파훼법: **Meet in the Middle Attack**\r\n\r\n중간 결과 X = E(K1, P ) = D(K2,C)\r\n\r\n중간 결과가 같은 쌍을 찾는다\r\n\r\n## Triple-DES with two keys\r\n\r\n세 번 돌리자!\r\n\r\n![](./triple.png)\r\n\r\n그러나 세 번 돌리니까 너무 오래 걸림 ...ㅠㅠ\r\n\r\n다른 방법!!! -> AES 표준\r\n\r\n## Modes of Operation\r\n\r\n모든 Block Cipher에게 적용됨 ex) DES AES\r\n\r\n### 1. ECB(Electronic CodeBook) Mode\r\n\r\n![](./ecb.png)\r\n\r\n> 암호화하려는 메시지를 여러 블록으로 나누어 각각 암호화함\r\n>\r\n> 어떤 입력이 들어오면 어떤 출력이 테이블처럼 나감\r\n>\r\n> same input -> same output\r\n\r\n- 만약 Plain text가 128bit보다 커진다면? 한 블록으로 안돼서 여러 블록으로 자를것\r\n\r\n- 각각의 블록들에 대해 같은 key를 적용한다(key는 여러개의 서브키로...)\r\n- Permutation cipher처럼 입력과 출력이 대응되어 있음 : 같은 key를 넣고 같은 plaintext를 넣으면 같은 ciphertext가 나옴\r\n\r\n- 병렬진행가능\r\n- 블록모드\r\n\r\n- 양이 많은 데이터를 암호화하는것은 추천하지않음. 짧은 데이터에서 사용됨\r\n- 모든 블록이 같은 암호화 키를 사용하기 때문에 보안에 취약함\r\n\r\n### 2. CBC (Cipher Block Chaining) Mode\r\n\r\n![](./cbc.png)\r\n\r\n> 각 블록은 암호화되기 전에 이전 블록의 암호화 결과와 XOR됨\r\n\r\n- block ciphering이 여러번 수행됨, xor사용\r\n\r\n- 문제 : 에러가 전파됨\r\n\r\n- CBC로 쉽게 MAC (=MIC)을 구현할 수 있다\r\n\r\n​ Message Actheticate Code\r\n\r\n​ Message Integrity Code\r\n\r\n- 블록 모드\r\n\r\n> **암호화가 목적이 아닌 Integrity, Athentication이 목표일 때:**\r\n>\r\n> 여러 C 1...n중 마지막 Cn만 취한다.\r\n>\r\n> key를 가지고 Encryption을 순방향으로 돌린다. 돌려서 얻은게 C'n\r\n>\r\n> Cn과 C'n이 같은지 확인한다\r\n>\r\n> 만약 P1...n중 뭐든 1bit라도 오류가 생겼다면 둘은 같지않다.\r\n>\r\n> 이걸로 올바른 key를 가진 사람에게서 데이터가 전송된 것이므로 Authentication 가능 & 데이터가 문제없이 전송됐는지 확인 가능 Integrity\r\n\r\n<br/>\r\n\r\n### 3. CFB (Cipher FeedBack) Mode\r\n\r\n![](./cfb.png)\r\n\r\n> 암호화된 결과를(그림의 C) 피드백\r\n>\r\n> CFB 모드에서는 암호 알고리즘이 생성하는 비트열을 키 스트림이라고 부름\r\n>\r\n> 키 스트림을 생성하기 위해 의사난수 생성기(암호 알고리즘)를 사용함\r\n>\r\n> 초기화 벡터(IV)가 의사난수 생성기의 seed에 해당\r\n\r\n- Block Cipher를 Stream Cipher처럼 사용 - 스트림 모드\r\n- 실제로 block이 적용되는건 xor할때뿐\r\n\r\n- CBC Mode와 비슷해 보이지만 Stream Mode이다\r\n\r\n- Plain text가 생성되기 전까지 그 다음 key stream을 만들 수 없다. (Stall)\r\n- 이를 개선한 것이 OFB. 피드백하는 부분이 바뀜\r\n- CBC처럼 에러가 전파됨 (MAC 구현 가능)\r\n- ECB, CBC 모드에서는 암호 알고리즘을 이용하여 평문 블록을 암호화했지만 CFB는 평문블록을 암호 알고리즘으로 직접 암호화하지않는다. (평문블록과 암호문블록 사이 암호화가 없음 )\r\n\r\n> 📌 **Tip!**\r\n>\r\n> Stream Mode인지 Block Mode인지 구별하려면?\r\n>\r\n> `Decryption`을 할 때 **Encrypt**를 똑같이 사용한다면 Stream Mode이다  \r\n> Block Mode는 블록 단위 별로 암호화하지만 Stream Mode는 블록으로 나누지않고 plain text자체를 한 번에 암호화 한다는 것을 기억!\r\n\r\n### 4. OFB (Output FeedBack) Mode\r\n\r\n![](./ofb.png)\r\n\r\n> 암호 알고리즘(그림의 Encrypt)의 출력을 암호 알고리즘의 입력으로 피드백\r\n>\r\n> CFB는 암호화된 결과를(그림의 C) 피드백\r\n\r\n- Block Cipher를 Stream Cipher처럼 사용\r\n- Stream Mode이다\r\n- Cipher에 피드백이 아니라 Output에 피드백\r\n\r\n- No Stalling (Preprocessing) : plaintext가 오기전에 쭉 해둘수있다\r\n- 병렬화가 안됨. 결국 앞 단계에서 결과가 나와야 뒷 단계가 진행됨 (No Parallelism) 자원이 많아도 성능을 향상시키는데 한계가 존재\r\n- 에러 전파가 안됨 (아웃풋을 피드백하는거라서)\r\n\r\n### 5. CTR (Counter) Mode\r\n\r\n![](./ctr.png)\r\n\r\n- Stream Mode\r\n\r\n- 병렬화하면서 동시에 같은 블럭이 다른 블럭으로 나올 수 있게 되어있음(Plaintext가 같더라도 Ciphertext가 다르게 나온다)\r\n- 카운터를 입력으로 줌. 카운터는 숫자 ex) 1\r\n- 피드백이 없지만 Counter들끼리 연관되어있다 1, 2, 3 ...\r\n- Counter가 달라서 Plaintext이 같아도 다른 Ciphertext이 나옴\r\n- Random access : 꼭 첫번째 Plaintext부터 Encryption 안해도 됨. 150번째 P부터 하고싶다면 Counter를 150으로 시작하면된다\r\n\r\n### 다섯가지 특징 비교\r\n\r\n![](./check.png)\r\n\r\n> 에러 전파 : cipher text의 오류가 계속 전파될 수 있는지. 즉, c가 다음 프로세스에 영향을 주는지를 체크  \r\n> 병렬 : p를 c로 도출하는 각 프로세스가 독립적일 수 있는지  \r\n> Pre-processing\r\n>\r\n> plaintext가 없어도 미리 복잡한 연산을 먼저 할 수 있는가\r\n>\r\n> ECB, CBC,CFB 는 plain text가 있어야 Encrypt할 수 있으므로 불가\r\n\r\n> CTR : Confidentiality\r\n>\r\n> CBC : MAC - Integrity, Authenticataion\r\n>\r\n> CCM (CTR with CBC-MAC)\r\n\r\nMode, Block Cipher의 실제 사례를 봐보자!\r\n\r\n### IEEE 802.11 (WPA2/3)\r\n\r\n> 무선 통신 표준\r\n>\r\n> AES-CCMP\r\n\r\n무선랜을 검색해보면 access point들 뜸.\r\n\r\nWPA2를 이용해서 보호됨 : 암호를 입력해야 access가능\r\n\r\n삼성 스마트폰, 애플 모두 무선랜에 접속가능. 표준이 있기 때문\r\n\r\n### TLS v1.3 (IETF RFC 8446)\r\n\r\n> Transport Layer Security\r\n>\r\n> Transport층에 보안을 제공한다\r\n\r\n- AES 128bit\r\n\r\n- 이전에는 SSL이라 불렸으나 버전이 올라가면서 TLS로 변경\r\n\r\n- `https` : http프로토콜을 TLS위에 올린 어플리케이션\r\n"},{"excerpt":"Malware (malicious software) 허가되지않은 일을 하기 위해 악의적으로 설계된 소프트웨어 (의도적이지 않은 결함은 bug라고 하며 멜웨어는 의도적인 소프트웨어) 트로이 목마 : 정상 프로그램으로 위장한 악성 프로그램 Root kit : 시스템의 root 권한을 획득하고 악성코드의 존재를 숨김 Backdoor : 정상 인증 절차를 우회하…","fields":{"slug":"/cp-danger/"},"frontmatter":{"date":"April 18, 2022","title":"4-1 다양한 보안 위협","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Malware (malicious software)\r\n\r\n허가되지않은 일을 하기 위해 악의적으로 설계된 소프트웨어\r\n\r\n(의도적이지 않은 결함은 bug라고 하며 멜웨어는 의도적인 소프트웨어)\r\n\r\n- 트로이 목마 : 정상 프로그램으로 위장한 악성 프로그램\r\n- Root kit : 시스템의 root 권한을 획득하고 악성코드의 존재를 숨김\r\n- Backdoor : 정상 인증 절차를 우회하여 시스템에 접속할 수 있게 하는 뒷문\r\n- 감염형 malware\r\n  - Virus : 정상처럼 보이는 프로그램 안에 숨음, 다른 프로그램들 감염\r\n  - Worm : 얘 자체가 프로그램, 능동적으로 전파, 스스로 복제\r\n- 랜섬웨어\r\n\r\n### Ransomware (ransom + ware)\r\n\r\n피해자의 기기 및 데이터를 장악(주로 암호화)해서 접근이 불가하게 만들고 민감한 데이터를 공개하는 것을 막거나 데이터를 복원하려면 비용을 지불하도록 유됴\r\n\r\n---\r\n\r\n## 블랙마켓\r\n\r\n암시장\r\n\r\n온라인으로도 유용됨\r\n\r\n제품 : 신용카드, 체크카드, 페이팔 계정, 개인정보, 악성프로그램등\r\n\r\n서비스 : 호스팅, DDoS 봇넷, 소프트웨어 불법 대여, ranswomware as a service (RaaS) 등\r\n\r\nex) 실크로드\r\n\r\n### 실크로드\r\n\r\n최초의 현대적인 darknet marker\r\n\r\n`다크웹`을 이용하기 때문에 일반 인터넷으로는 접근 불가능\r\n\r\n지금은 없음\r\n\r\n---\r\n\r\n## Darknet\r\n\r\n접근을 위해서는 특정 소프트웨어가 필요한 오버레이 네트워크\r\n\r\n주로 소규모 P2P 네트워크로 연결되거나 Tor, Freenet, ITP 등 별도적인 소프트웨어 상에서 동작\r\n\r\n### Tor (The onion router)\r\n\r\n대표적인 다크넷 제공 오픈 소스 소프트웨어 중 하나\r\n\r\n`onion routing`을 사용한 traffic anonymization technique 적용\r\n\r\n사용자의 네트워크 사용 패턴 및 위치를 숨김으로서, Network surveilance 나 traffic analysis 방지\r\n\r\n`onion routing` : 라우팅이 숨겨짐. 트래픽 익명화. 쓰는 사용자가 많아야 유리\r\n\r\n악용 사례만 있는 것은 아님. 기밀성 보장\r\n\r\n## Deep Web\r\n\r\n일반 검색 엔진으로는 드러나지 않는 웹 컨텐츠\r\n\r\n얘도 악용 사례만 있는 것은 아님. 일부가 다크웹으로 사용됨\r\n\r\n넓은 의미에서는 웹 메일(ex. gmail)의 inbox, OTT(ex. netflix)의 컨텐츠 등을 포함 : gmail 주소로 바로 gmail에 들어갈 수 없음\r\n\r\n대부분 합법적인 사이트\r\n\r\n---\r\n\r\n## 0-day\r\n\r\n0-day 공격은 컴퓨터 소프트웨어의 취약점을 공격하는 기술적 위협으로 해당 취약점에 대한 패치가 나오기 전에 이루어진다.\r\n\r\n공격의 수행 사용자와 프로그램 개발자가 잘 모르는 것이 보통\r\n\r\n공격에 사용되는 코드를 exploit이라고 함\r\n\r\n## APT (advanced persistent threat)\r\n\r\n0-day들을 조합해서 사용하는 고급 공격\r\n\r\n다양한 보안 위협들을 양산하여 특정 대상에게 지속적으로 가하는 일련의 행위\r\n\r\nex) shady rat, stuxnet(산업 시설 감시 및 파괴)\r\n\r\n## Steganography\r\n\r\n미디어 파일안에 데이터를 숨기는 기술\r\n"},{"excerpt":"난수 생성 난수는 왜 필요? 그냥 대부분의 암호에 필요하다... 보통 key에 사용됨 암호의 안전성은 key에 기반하기때문에 key생성이 중요함 난수의 조건 Randomness  : 나올 수 있는 수들의 분포가 균일해야한다  : 서로 독립적. 긴 시퀀스로 봤을 때 부분 부분간의 연관관계가 없어야함. 반복되는 구간이 존재하지않는다. Unpredictabil…","fields":{"slug":"/pseudo-random/"},"frontmatter":{"date":"April 18, 2022","title":"7-2 난수 생성","tags":["computer protection"]},"rawMarkdownBody":"\r\n## 난수 생성\r\n\r\n> **난수는 왜 필요?**\r\n>\r\n> 그냥 대부분의 암호에 필요하다... 보통 key에 사용됨\r\n>\r\n> 암호의 안전성은 key에 기반하기때문에 key생성이 중요함\r\n\r\n#### 난수의 조건\r\n\r\n- Randomness\r\n\r\n  `Uniform distribution` : 나올 수 있는 수들의 분포가 균일해야한다\r\n\r\n  `Independence` : 서로 독립적. 긴 시퀀스로 봤을 때 부분 부분간의 연관관계가 없어야함. 반복되는 구간이 존재하지않는다.\r\n\r\n- Unpredictability\r\n\r\n  예측이 불가능해야한다\r\n\r\n  어떤 구간을 보고 그 다음 구간을 예측할 수 없어야한다\r\n\r\n### Pseudorandom Numbers\r\n\r\n> 난수를 만드는 것은 자원이 많이 드는 일\r\n>\r\n> 진짜 랜덤은 아니지만 랜덤처럼 보이는 시퀀스를 만들어내는 알고리즘이 더 일반적\r\n>\r\n> Deterministic algorithm\r\n\r\n- TRNG = 진짜 난수 생성기\r\n- PRNG = 수도 난수 생성기 : 무한 stream 출력\r\n- PRF = 수도 난수 함수 : 길이가 정해져있는 value 출력\r\n\r\n### TRNG\r\n\r\n- entropy를 만들어내는 함수로 entropy source라고도 불린다\r\n- 물리적인 특성들을 가지고와서 사용하는 경우가 많다\r\n\r\n ex) keystroke timing, disk electrical activity, mouse movements\r\n\r\n- 보통 TRNG로 seed를 만들고 PRNG를 돌려서 더 긴 시퀀스를 만들어낸다\r\n\r\n- 아날로그 소스들을 받아서 바이너리 아웃풋으로 내보낸다\r\n\r\n- 경우에 따라서 bias가 있기도 한다 : 이럴경우 bias를 처리해줘야함\r\n\r\n### PRNG\r\n\r\n- deterministic algorithm\r\n- key stream을 만들어낸다\r\n- input이 정해지면 output도 정해진다\r\n- 그렇기에 seed값을 안전하게 잘 보호해야함\r\n\r\n### PRF\r\n\r\n- 길이가 고정된 아웃풋을 만들어낸다\r\n\r\n## PRNG와 PRF의 조건\r\n\r\n- Randomness\r\n- Unpredictability\r\n- Characteristics of the seed : seed를 안전하게 보관한다\r\n\r\n진짜 난수는 아니지만 난수성을 만족\r\n\r\nseed를 모르면 PRNG가 만들어낸 아웃풋이 랜덤처럼 보여야한다\r\n\r\n## Randomness 정량적 평가 방법\r\n\r\n- Frequency test: 0과 1이 몇 개씩 나오는지 확인\r\n\r\n- Runs test : 같은 비트가 반복되면 안됨\r\n\r\n- Maurer's universal statistical test : 시퀀스를 압축을 시켰을 때 잘 되는지\r\n\r\n등등 15가지가 존재\r\n\r\n## Seed Requirements\r\n\r\n- 시드는 secure하고 unpredictable해야한다\r\n\r\n- 수도랜덤넘버를 사용하기도하지만 시드는 보통 진짜 랜덤, TRNG로 만든다\r\n\r\n## Algorithm Design\r\n\r\n**PRNG 알고리즘 설계**\r\n\r\n- 이미 존재하는 암호 알고리즘을 기반으로 만들거나\r\n- 난수 생성 자체를 목적으로, 전용으로 만들어서 쓸 수도있음\r\n\r\n## Linear Congruential Generator : 안전 x\r\n\r\n- 많이 생성하는 난수 생성기이나 암호학적으로는 사용할 수 없음\r\n\r\n- X0은 seed\r\n\r\n- 1차식이기 때문에 위험\r\n\r\n## PRNG Using Block Cipher Modes of Operation\r\n\r\n- CTR mode\r\n- OFB mode\r\n\r\n### NIST CTR_DRBG\r\n\r\n- Counter mode\r\n- 굉장히 많이 쓰임. Intel cpu에서도 사용\r\n- entropy source가 있어야함. entropy소스로 부터 seed를 받아서 카운터 기반의 PRNG를 돌려서 긴 수도 랜덤 시퀀스를 만들어낸다\r\n- 3DES와 AES를 사용\r\n\r\n## Stream Cipher Desing Considerations\r\n\r\n수도 랜덤 생성 전용 스트림 함수\r\n\r\n- period가 길어야 함. seed값이 같으면 계속 넘버를 생성할 경우 일정 싸이클이 반복되게된다\r\n- true random number stream처럼 보여야한다. - 분포나 연관관계 없어보여야함\r\n- key length가 최소한 128bit - 키가 짧으면 공격자가 추측해보기 쉬움\r\n- 비슷한 key length를 가지는 블록싸이퍼와 비슷한 안전성을 갖길 기대\r\n\r\n### RC4\r\n\r\n키 사이즈 변경 가능\r\n\r\n바이트 단위로 연산가능\r\n\r\nSSL에 사용됐었음\r\n\r\n후속버전임 TLS에서도 쓰였음\r\n\r\n무선랜에서도 쓰였\r\n\r\n**그러나 broken됐음...**\r\n\r\n### ChaCha20\r\n\r\nSalsa20암호를 살짝 바꾼...\r\n\r\n## TRNG and Entropy Source\r\n\r\n- nondeterministic\r\n- Sound/Vide, Disk driver 등을 모아서 trun random number를 만들기위한entropy source로 사용한다\r\n\r\n## Conditioning\r\n\r\nentropy source가 있으면 다 해결?\r\n\r\nbias가 있을수도\r\n\r\n후처리필요\r\n\r\n후처리를 해서 bias를 없앴을때 동전던지기를 몇번 한 효과가 있을것이냐를 디지털화된 노이즈 소스가 제공하는 난수성이 어느정도냐 entropy ratio\r\n\r\nbias를 conditioning알고리즘으로 돌려서 랜덤 효과를 늘림\r\n\r\n## Intel Digital Random Number Generator\r\n\r\nbias가 있어도 AES를 돌리다보면 random한 것 처럼 변함\r\n\r\nRing Oscillator기반의 entropy source에다가 AES CBC MAC을 집어넣어서 컨디셔닝을 해서 TRNG를 만들고 AES couter mode를 돌려서 PRNG를 만든다\r\n\r\nintel에서 이걸 써먹을 수 있는 라이브러리를 줌\r\n\r\n"},{"excerpt":"MITRE 미국의 비영리 단체로 보안에 대한 자료들이 올라와있음 CVE, CWE, CAPEC CVE 많이 나오는 공격들. 알려져있는 취약점 CWE CVE에 기반해서 만든 분류 체계 CAPEC 공격들을 추상화해서 신경써서 분석해야할 것들을 분류 OWASP (Open Web Application Securty Project) 웹 응용 보안을 다루는 오픈 커뮤…","fields":{"slug":"/web-hack/"},"frontmatter":{"date":"April 18, 2022","title":"5-1 Web Hacking Overview","tags":["computer protection"]},"rawMarkdownBody":"\r\n## MITRE\r\n\r\n> 미국의 비영리 단체로 보안에 대한 자료들이 올라와있음  \r\n> CVE, CWE, CAPEC\r\n\r\n### CVE\r\n\r\n많이 나오는 공격들. 알려져있는 취약점\r\n\r\n### CWE\r\n\r\nCVE에 기반해서 만든 분류 체계\r\n\r\n### CAPEC\r\n\r\n공격들을 추상화해서 신경써서 분석해야할 것들을 분류\r\n\r\n## OWASP (Open Web Application Securty Project)\r\n\r\n웹 응용 보안을 다루는 오픈 커뮤니티\r\n\r\n📌 Broken Access Control :\r\n\r\n말그대로 access control에 문제가 생김\r\n\r\n📌 Crypographio Failures :\r\n\r\n암호화 하는 것에 문제\r\n\r\n📌 Injection :\r\n\r\nCross-site Scripting이나 sql injection등 정상적이지않은 명령을 주입\r\n\r\n📌 Insecure Design : 보통 구현이 잘못되는데 얘는 디자인 자체가 잘못된\r\n\r\n📌 Security Misconfiguration :\r\n\r\n보안 설정 잘못함\r\n\r\n📌 Vulnerable and Outdated Components :\r\n\r\n취약점에 대한 패치가 나왔으나 적용을 안해서 여전히 취약점이 남아있음\r\n\r\n📌 Identification, and Authentication Failures :\r\n\r\n사용자 식별, 인증 실패\r\n\r\n📌 Software and Data Integriry Failures\r\n\r\n인터그리티가 확인이 안됨. 전자서명이 안된 프로그램을 설치하거나\r\n\r\n📌 Security Logging and Monitoring Failures\r\n\r\n사고가 발생되면 수습을 해야함. 사고 발생자에게 경고를 주거나 사고에 대한 분석, 포렌식을 하는데 문제\r\n\r\n📌 Server-Side Request Forgery\r\n\r\n서버 취약점을 공격\r\n\r\n## Web 기본 지식\r\n\r\n- 사용자, 브라우저, 웹 서버, 백엔드\r\n\r\n보안 관점에서 브라우저는 프로그램이고 사용자는 프로그램이 아님\r\n\r\n브라우저 : 사용자 입력을 받아 소통\r\n\r\n사용자가 실제로 볼 수 있게 처리 : rendering\r\n\r\n### 브라우저와 웹 서버 간의 통식\r\n\r\n보통 http사용\r\n\r\n보안성을 추가한 https\r\n\r\n- HTTP : 브라우저와 웹 서버 사이의 통신을 정의하는데 사용 TCP 프로토콜 상에서 돌아감\r\n\r\n- HTTPS : 보안 계층에 SSL/TLS도 추가. 웹 서버가 브라우저에게 인증서를 제공함으로써 보안성 있는 통신을 할 수 있도록 함\r\n\r\n> https를 사용하면 웹 통신이 안전할까?\r\n\r\n> 어느부분은 맞고 어느 부분은 틀리다\r\n\r\n> 브라우저와 웹 서버간의 통신은 안전할지라도 사용자라는 취약점이 존재해서 무조건 안전한 것은 아님\r\n\r\n### 웹서버\r\n\r\n- 웹서버 : 브라우저 요청 사항을 처리하는 일에 중점을 둔다.\r\n\r\n* 웹 서버는 어떤 동작을 수행할지 결정하기 위해 HTTP헤더 뿐만 아니라 URL을 사용한다\r\n\r\n- get, post를 처리해줄 수 있는 최소한의 서버 ex. 아파치\r\n\r\n* 웹 서버는 서버 측 스크립트와 함께 동작한다\r\n\r\n* 서버 측 스크립트 (= Web Application Server, WAS) ex. python, java\r\n\r\n* 서버 측 스크립트는 코드를 실행시켜서 응답을 바로 생성하거나 데이터베이스와 같은 다른 백엔드 서버와 연결한 다음 해당 정보를 이용해서 적절한 응답을 생성한 후 보낸다 파일 db등과 연결하려며 WAS가 필요\r\n\r\n_보통 웹서버는 잘 나와있는 솔루션을 뜨고 웹 어플리케이션 서버는 개발자가 개발_\r\n\r\n> 백엔드 서비스 : 서버 측 스크립트와 연결된 부가적인 서비스를 백엔드라고함\r\n\r\n> 웹 서버의 백그라운드에서 실행되는 서비스\r\n\r\n> 정보를 저장하는데 쓰이는 데이터베이스등이 있다\r\n\r\n## Web Hacking Overview\r\n\r\n### 📌 Injecting Malicious Data\r\n\r\n- vaildatior를 만족하지 않는​ 부적절한데이터를 강제로 주입  \r\n  Browser WS WAS\r\n\r\n![](./injecting.png)\r\n\r\n​ 1. 웹서버에 들어오기 전에 이미 err발견하지만 강제로 침입\r\n브라우저 내에서 발생하거나, 브라우저에서 체크했으나 웹 통신중 이상함 발견\r\n\r\n- HTTP Header Manipulation : 헤더의 `REFERER`를 조작해서 프로모션 받기 가능\r\n- Cookie Poisoning :\r\n  쿠키: 세션 아이디 등 임시 정보가 담겨있음  \r\n   남의 쿠키를 저장해서 사용하면 타인 아이디로 로그인 가능\r\n\r\n### 📌 Exploiting Uhchecked Input\r\n\r\n- 웹 서버가 정상 입력으로 간주하게 되어서, 백엔드 서비스 등에 2차 피해를 일으키는 공격\r\n\r\n* 게시판과 같이 동적으로 생성되는 Page에 조작된 코드를 넣어서 다른 사용자에게 공격자가 원하는 코드를 실행하게 함\r\n\r\n​ 2. 여기까지오고 나중에 DB 가서 보니까 err\r\nWAS에서 ok해서 DB에 보냈지만 DB에서 에러 발생\r\n"},{"excerpt":"Symmetric Cipher Model 대칭 암호 모델 시메트릭 : 대칭 어시메트릭 : 비대칭 고전 암호는 무조건 시메트릭이다 고전 암호는 크게 과 으로 나뉜다  : 평문을 치환 - 아예 다른 글자로 대체  : 평문안의 각 글자들을 지들끼리 위치 이동시킨다 은 아예 다른 글자로 바뀌지만 은 원래 있던 글자들은 유지된다 특징 : encryption 알고리…","fields":{"slug":"/symmetric-cipher/"},"frontmatter":{"date":"April 18, 2022","title":"3-2 Symmetric Cipher Model (고전 암호)","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Symmetric Cipher Model\r\n\r\n> 대칭 암호 모델\r\n>\r\n> 시메트릭 : 대칭\r\n>\r\n> 어시메트릭 : 비대칭\r\n\r\n고전 암호는 무조건 시메트릭이다\r\n\r\n고전 암호는 크게 `Substitution`과 `Transposition`으로 나뉜다\r\n\r\n- `Substitution` : 평문을 치환 - 아예 다른 글자로 대체\r\n- `Transposition ` : 평문안의 각 글자들을 지들끼리 위치 이동시킨다\r\n\r\n`Substitution`은 아예 다른 글자로 바뀌지만 `Transposition`은 원래 있던 글자들은 유지된다\r\n\r\n> 특징 :\r\n>\r\n> encryption 알고리즘이 강해야한다.\r\n>\r\n> 수신자와 송신자는 secret key를 가지고 있어야한다\r\n\r\n### 공격자의 공격 분류\r\n\r\n---\r\n\r\n(위로 올라갈수록 어렵)\r\n\r\n## Substitution Technique\r\n\r\n---\r\n\r\n평문을 치환 - 대체\r\n\r\nex) Caesar Cipher\r\n\r\n- Monoalphbetic ciphers : 인풋이 같다면 미리 정해진 규칙에 의해 똑같이 변환된다.\r\n\r\n- Polyalphabetic ciphers : 인풋이 같더라도 아웃풋이 다를 수 있다.\r\n\r\n### 🔒 Caesar Cipher\r\n\r\n---\r\n\r\n알파벳을 3칸 옮김\r\n\r\nC = E(3,p) = (p+3) mod 26 : 알파벳이 26개\r\n\r\n> `일반화` C = E(k,p) = (p+k) mod 26\r\n>\r\n> `복원` P = D(k,C) = (C-k) mod 26\r\n\r\n`파훼법` Brute-Force : key의 모든 후보들을 다 돌려서 모든 경우를 구해봄\r\n\r\nkey의 수가 작아서 가능함\r\n\r\n그래서 발전한게 `Monoalphabetic Cipher` ex) Permutation\r\n\r\n### 🔐 Monoalphabetic Ciphers\r\n\r\n---\r\n\r\n인풋이 같다면 미리 정해진 규칙에 의해 똑같이 변환된다.\r\n\r\n#### 🔒 Permutation\r\n\r\n각 알파벳마다 임의의 글자 할당\r\n\r\n**그럼 안전할까?**\r\n\r\nNO!!!\r\n\r\n1. 암호화된 글자가 나오는 빈도수에 따라 추정\r\n2. 두글자, 세글자씩 짝 지어서 나오는 글자로도 추정 가능 ex) th, the\r\n\r\n**이런 약점을 없애려면?**\r\n\r\n1. 통계적인 정보를 없애거나\r\n\r\n   ▶ **글자를 묶어서 치환시킨다** ex) Playfair Cipher\r\n\r\n2. 완화시켜야한다\r\n\r\n   ▶ **날마다 다른 글자로 대응시킨다**\r\n\r\n### 🔒 Playfair Cipher\r\n\r\n---\r\n\r\n두글자를 두글자로 바꿔준다\r\n\r\n5x5 행렬 사용\r\n\r\n**규칙!**\r\n\r\n1. 두 글자씩 잘랐을 때, 똑같은 두 글자가 연속이면 잘 안나오는 다른 글자를 껴넣는다\r\n\r\n   > ba ll oo n -> ba lx lo on\r\n   >\r\n   > ll이 연속되었으므로 l과 l 사이 x를 넣어 연속되지않게한다\r\n\r\n2. 두 글자가 같은 열일 때\r\n\r\n   > 오른쪽으로 한 칸씩 옮긴다.\r\n   >\r\n   > ex) 'ar' 은 'RM' 으로 변환된다\r\n\r\n3. 두 글자가 같은 행일 때\r\n\r\n   > 2번과 같은 규칙. 아래로 한 칸씩 옮긴다.\r\n   >\r\n   > ex) 'mu' 는 'CM' 으로 변환된다\r\n\r\n4. 두 글자의 열과 행이 다를 때\r\n\r\n   > 두 글자를 포함시킨 사각형 구조를 만들어 대칭되는 꼭지점으로 변환한다.\r\n   >\r\n   > ex)\r\n   >\r\n   > 'hs' -> 'BP'\r\n   >\r\n   > 'ea' -> 'IM'\r\n\r\nI/J중 뭘로 하든 상관없음\r\n\r\n**두 개씩 짝지어서 변환했으므로 통계 추정하기가 더 힘들어짐**\r\n\r\n### 🔐 Polyalphabetic Ciphers\r\n\r\n---\r\n\r\n- 한글자씩 대응\r\n\r\n- `but` 대응 규칙이 여러개임\r\n\r\n- `monoalphabetic substitution` 규칙을 여러개 사용할 것\r\n\r\n- `key`에 따라 여러 개의 규칙 중 어떤 것을 선택할지 결정하게됨\r\n\r\nex) vigenere cipher\r\n\r\n### 🔒 Vigenere Cipher\r\n\r\n---\r\n\r\n- 시저 암호를 여러 개 사용함\r\n\r\n- message를 암호화하기 위해서 message와 길이가 똑같은 key가 필요\r\n\r\n- 현실적으로 그 만큼 긴 길이의 key를 만들긴 힘들어서 일정 길이의 key를 반복시킨다\r\n\r\n- **key의 번호에 맞게 각 글자를 암호화한다.** (a = 0, b = 1, ...)\r\n\r\n![](./vigenere.png)\r\n\r\n**파훼법**\r\n\r\n1. 사이클 길이를 가정한다 (key는 어떤 단어가 반복되므로 사이클이 존재)\r\n2. 사이클 길이에 맞는 통계분석을 실시\r\n\r\n그러나 `autokey`가 등장했다면?\r\n\r\nkey다음에 평문을 이어붙여 길게만든다\r\n\r\n: 사이클 추정이 불가능하다!!!\r\n\r\n**but ... 어쨌든 key에서 가장 많이 나오는 글자로 추정이 가능하다**\r\n\r\nkey도 plaintext도 영어이기때문에 가장 많이 나오는 글자가 존재\r\n\r\n어렵겠지만 추정이 가능한듯??\r\n\r\n### 🔒 Vernam Cipher\r\n\r\n---\r\n\r\n알파벳을 그대로 사용하지않고 알파벳을 어떤 코드 체계를 통해서 bit 시퀀스로 바꾼다. 그 bit 시퀀스를 keyword에 해당하는 다른 bit 시퀀스와 더한다.\r\n\r\n```\r\n(p + k) mod 2\r\n```\r\n\r\nmod 2의 재미난 성질 ~ 더하기와 빼기가 같답니다~\r\n\r\n```\r\n+` = `-` = `xor\r\n```\r\n\r\n**key bit stream을 사용해 최대한 key의 길이를 길게!**\r\n\r\n### 🔒 One-Time Pad\r\n\r\n---\r\n\r\nkey를 극단적으로 길게 만들어서 사이클이 없게\r\n\r\n```\r\nrandom key\r\n```\r\n\r\n`unbreakable` : 깨지지않음. 랜덤이라 파훼불가능. perfect secrecy!!!\r\n\r\n문제 : 현실적이지않음... 실용적x, 엄청 긴 램덤키가 필요하기때문\r\n\r\n데이터가 적고 안전성이 좋은 채널에서 사용\r\n\r\n## Transpostion Cipher\r\n\r\n---\r\n\r\n평문안의 각 글자들을 지들끼리 위치 이동시킨다\r\n\r\nex) Rail Fence Cipher\r\n\r\n### 🔒 Rail Fence Cipher\r\n\r\n---\r\n\r\nplaintext를 대각선 형태로 쓰고 행으로 읽음\r\n\r\ndepth(몇 개의 행)\r\n\r\n### 🔒 Row Transposition Cipher\r\n\r\n---\r\n\r\n레일 펜스보다 복잡함\r\n\r\nkey는 1~n까지의 수, key에 해당하는 열 순으로 읽음\r\n\r\n### 🔒 Steganography\r\n\r\n---\r\n\r\n평범한 메시지인척 비밀 메시지 숨겨놓기~\r\n\r\n- 캐릭터 마킹 : 타자가 된 글자에 연필로 일부 글자 덮어쓰기\r\n- Invisible ink : 열 가하면 보이는 잉크\r\n- Pin punctures : 잘안보이는 구멍\r\n- Typewriter correction ribbon : 타자된 글자기에 리본...을 흡수 ..뭐요? 어쨌뜬 타자기를 활용해서 글자를 보일락말락하게\r\n\r\n`단점` :\r\n\r\n오버헤드, 조그만 양을 숨기기위해 많은 데이터 필요\r\n\r\n숨겼다는 사실만 알면 들키기 쉬움\r\n\r\n`장점` :\r\n\r\n평범하게 보임. 암호문이라는 것을 눈치채기어려움\r\n"},{"excerpt":"AES 현대 Symmetic 암호는 Stream 암호와 Block암호로 구분된다 Block암호에는 대표적으로 AES가 있다 Advanced Encryption의 표준\nDES : 56bit크기의 key 키 크기가 작아서 취약\n키의 크기도 늘리고 성능 유지한게 AES AES structure  ➡  ➡  같은 input이라도 key값에 따라 output차이가…","fields":{"slug":"/aes-process/"},"frontmatter":{"date":"April 18, 2022","title":"5-2 AES Process","tags":["computer protection"]},"rawMarkdownBody":"\r\n## AES\r\n\r\n- 현대 Symmetic 암호는 Stream 암호와 Block암호로 구분된다\r\n\r\n- Block암호에는 대표적으로 AES가 있다\r\n\r\n- Advanced Encryption의 표준\r\n  DES : 56bit크기의 key 키 크기가 작아서 취약\r\n  키의 크기도 늘리고 성능 유지한게 AES\r\n\r\n## AES structure\r\n\r\n`128bit input` ➡ `Encryption` ➡ `128 output`\r\n\r\n같은 input이라도 key값에 따라 output차이가 발생한다\r\n\r\n### 궁극 목적\r\n\r\n#### **Bit randomizion effect**\r\n\r\nBlock Cipher : finite field 사용\r\n비트를 랜덤해보이도록 만들어서 최대한 인풋과 아웃풋의 연관관계가 없어보이게\r\n\r\n- Field multiplication과 Field inversion을 통해 랜덤하게 변형\r\n  -> 그래서 finite field를 사용한다!\r\n  _덧셈(뺄셈)은 반복하면 같아지는 효과가 있어서 제외_\r\n\r\n왜 덧셈은 반복하면 같아질까?\r\n\r\nfield : 사칙연산 덧셈 : randomize효과가 실질적으로 없음. 무작위로 바뀌지않고 계속 유지되는 성질 XOR 같은거 더하면 상쇄됨 연산을 반복한다고해서 복잡도가 올라가지않음\r\n\r\n### Rationale for Binary Field\r\n\r\nn비트의 int는 2^n 개 표현 가능\r\n그러나 모듈러 2^n은 field가 될 수 없음 ex) 2^3 = 8\r\n-> `GF(2^n)`사용 GF안의 모든 polynomial들이 n비트 넘버를 표현\r\n\r\nirreducible polynomial :\r\n(GF기준으로 x2 + 1도 인수분해 가능.)\r\n![](./ex.png)\r\n\r\n1. 모드2 이므로 2x 추가\r\n2. `+`와 `-`가 같으므로 `x^2 - 1`로 변환\r\n\r\n### State\r\n\r\n> AES에서 쓰는 기본 자료구조  \r\n> 128bit : byte를 16개(4x4)의 형태이다\r\n> plain text, cipher text모두 128bit 단위로 암호화된다.\r\n\r\nround key == subkey  \r\nround key의 비트는 똑같지만 개수가 많아짐 : expanded key\r\n\r\n![](./key.png)\r\n\r\n- key는 bit 수가 다른 여러가지 key가 있지만 plaintext는 항상 128bit로 고정이다\r\n\r\n> key size, 비트수가 커지면 round수도 커진다  \r\n> 각 round별로 키가 하나씩 사용된다  \r\n> round수가 늘어나면 각 라운드마다 쓰일 서브키(라운드키) 개수가 증가한다  \r\n> 각각의 서브키 하나의 크기는 128bit로 고정되어있다. 개수만 늘어나는거임!\r\n\r\n> 첫라운드전 한 번 + 각 라운드별로 서브키가 하나씩 사용됨  \r\n> 즉, 라운드키는 라운드 개수+1만큼 필요  \r\n> 서브키가 16byte 라운드가 10일경우 Expanded Key Size는  \r\n> 16\\*11 = 176\r\n\r\n### AES Encryption Process\r\n\r\n---\r\n\r\n![](aes-process.png)\r\nState (4x4)  \r\n: 평문을 4x4형태에 맞게 열(세로)로 나열함\r\n\r\n**initial transformation**  \r\n: 평문state와 key state를 xor\r\n\r\n**round** : 4가지 프로세스를 반 ~ 복  \r\n(마지막 라운드에선 Mix Columns 수행을 안하긴 함)\r\n\r\n**key expansion(key schedule)** = 서브키를 만들어내는 과정\r\n\r\n### Detailed Structure\r\n\r\n---\r\n\r\n- Feistel Cipher는 반으로 나눠서 반만 업데이트했지만 AES는 전체를 업데이트\r\n\r\n- 결과적으로 AES에서 내부적으로 하는일은 전체적인 데이터의 블록(4x4)들을 substitution과 permutation을 이용해서 업데이트함\r\n\r\n> key가 128bit = 4 word, round가 10일 때,  \r\n> 필요한 라운드키는 4\\*11 word 총 word 44개가 필요  \r\n> 하나의 열에 8bit짜리 4개가 존재(4byte 한 줄) 이 4개를 합쳐서 하나의 w로  \r\n> 이를 w[0] ~ w[43]으로 표현할 것임\r\n\r\n![](./aes-ed.png)\r\n구현상의 편의성때문에 마지막 프로세스에선 Mix columns없음\r\n\r\n## 4개의 프로세스\r\n\r\n> 3가지의 substitution과 1가지의 permutation으로 이루어진다\r\n\r\n1. Substitute bytes : (Substitution)\r\n2. Shift Rows : (Permutation)\r\n3. Mix Columns : 여러 라운드로 진행됨 (Substitution)\r\n4. Add Round Key (such as XOR) (Substitution)\r\n\r\n`Shift Row`는 byte들의 위치를 바꿔주고 나머지 연산들은 byte들을 다른 byte로 대체해주는 역할을 한다\r\n\r\n**각 stage들은 역연산이 가능하다.**  \r\n즉, 복호화할 때는 순방향이 아니라 역방향으로 진행한다\r\n얘는 암호화 과정과 복호화 과정이 똑같지않음\r\n\r\n입력의 일부분이 출력의 여러부분에 분산해서 영향을 미치도록 만들면서 입력과 출력간의 관계가 잘 드러나지않게 하는 것이 최종 목적\r\n\r\n---\r\n\r\n### 1. Substitute Bytes\r\n\r\n---\r\n\r\n![](./subbyte1.png)\r\nbyte단위로 업데이트, 치환을 해준다.\r\n\r\n4x4 byte(128bit)중 하나의 byte를 S-box라고 함\r\n\r\n![](./s-box.png)  \r\nS-box각 바이트들을 다른 바이트로 대체해주는 규칙  \r\n모든 S-box사용자들이 같은 규칙을 씀(key의 일부가 아니라 정해진 방법) :\r\n\r\n서로 다른 8bit가 다른 8bit와 1대1연결되어있다(역연산이 가능해야하므로)\r\n\r\n> ex)\r\n>\r\n> 8bit가 00000000일 경우, x : 0000 / y : 0000으로 보고 63을 매칭시켜준다.\r\n\r\n4x4의 state의 각 byte, 총 16개의 byte를 S-box에 보낸다\r\n\r\n16개의 byte를 독립적으로.\r\n\r\n#### 😨 S-box 연산과 역연산\r\n\r\n![](./s-box-inverse.png)\r\n\r\n1. 😨 Inverse in GF(2^8) :\r\n   각 byte에 대한 역원을 구한다.\r\n\r\n​ 00000000 : 다른 수들은 모두 곱셈의 역원이 있지만 0의 역원은 0이므로 0은 그대로 0\r\n\r\n2. 😨 Byte to bit column vector\r\n\r\n​ s-box안의 bit를 b7(최상위비트)~b0(최하위비트)에 차례대로 넣는다\r\n만약 00000001을 넣어야한다면  \r\n b7부터 차례대로 00000001이 들어간다 (b0 = 1)\r\n\r\n3. 😨 행렬곱한다!\r\n\r\n`00000000`이 들어갔다고 칠 때\r\n\r\n우선 `00000000` 과 옆의 행렬을 곱해서(bn \\* 각 행의 n번째원소) 차례대로 `(1)`b0~b7에 다시 넣는다 (지금은 0이 들어갔으므로 행렬곱해도 다 0으로 나옴)\r\n\r\n옆에 bit `(2)`**11000110** 를 GF에서 mod 2 하던것처럼 xor  \r\n`(1)`의 bit(이 예시에서는 00000000)와 `(2)`의 앞 bit부터 `xor`시킨다\r\n\r\n4. 😨 bit column vector to byte\r\n   결과값은 01100011으로(최상위 비트부터 읽는다) 0을 S-box에 통과시키면 63이 된다.\r\n   <br/><br/><br/>\r\n\r\n---\r\n\r\n---\r\n\r\n<br/><br/>\r\n\r\n**예시 하나 더!**\r\n\r\n- Inverse in GF(2^8)\r\n\r\n인풋이 x: 0000, y: 0001일때, 1의 역원은 1이므로 00000001이 들어간다\r\n\r\n00000001을 최상위 비트(b7)부터 담는다\r\n<br/><br/>\r\n\r\n- Byte to bit column vector\r\n\r\n| `b0` | `b1` | `b2` | `b3` | `b4` | `b5` | `b6` | `b7` |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\r\n| 1    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |\r\n\r\n<br/>\r\n\r\n- 행렬곱\r\n\r\n_b0~b7이_ `10000000`이고, 행렬의 첫 번째 행이 `10001111` 이라면\\_\r\n\r\nbn과 n번째 원소를 곱하고\r\n\r\n곱한 결과들을 모두 더해서 bn에 넣는다\r\n\r\n이걸 8번 수행(b0~b7에 모두 집어넣음)\r\n\r\n`10000000` \\* `10001111` = 1 + 0 + ...+0 = 1, b0에는 1이 들어간다\r\n\r\n- 옆에 bit `11000110`과 b0~b7을 `xor`연산한다\r\n\r\n`11000110` xor `11111000` = `00111110`\r\n<br/>\r\n\r\n- bit column vector to byte\r\n\r\n`00111110`을 최상위비트(b7)부터 읽는다 : `01111100`\r\n\r\n`01111100`을 16진수로 읽으면 `7C` 즉 output은 `7C`이다.\r\n<br/><br/>\r\n\r\n---\r\n\r\n---\r\n\r\n<br/><br/>\r\n입력이 `X`(00~256), `X`의 iverse를 `Z`, 행렬을 `A`라고 할 때,  \r\nZ를 bit 벡터로 표현한뒤 A를 곱하고 그 결과에 상수 C를 더한다.  \r\nZA + C = Y(00~FF)(결과)\r\n\r\n반대로 역연산할경우 6과 3을 사용해 00임을 알 수 있다\r\n\r\n#### 😨 **역연산**\r\n\r\n역연산을 하려면? Y가 들어갔을 때 Z가 나오게 하면 된다  \r\nY - C = ZA  \r\n-A (Y - C) = Z (사실 +나 -나 동일, -A는 A의 역행렬)\r\n\r\n인풋과 아웃풋의 상관관계를 예측하기 어려운 암호가 좋은 암호\r\n\r\n-> linear 함수를 사용 자제. linear할 경우 몇 개의 p-c 쌍으로 연립방정식을 사용해 암호를 풀 수도 있음.  \r\n그래서 nonlinearity인 곱셈이나 곱셈의 역원 사용\r\n\r\n### 2. Shift Rows\r\n\r\n---\r\n\r\n![](./sr.png)\r\n\r\nplaintext를 4byte씩 잘라서 column으로 나열함  \r\n나열한 column끼리만 연산하면 잘 안 섞임  \r\n그래서 SR 필요\r\n\r\nRow, 행만 움직임. 열은 움직이지않음\r\n\r\n- 첫 번째 행은 안움직임\r\n- 두 번째 행은 왼쪽으로 한 칸\r\n- 세 번째 행은 왼쪽으로 두 칸\r\n- 네 번째 행은 왼쪽으로 세 칸 (= 오른쪽으로 한 칸)\r\n\r\n동작 자체는 간단하나 column에 대한 연산만 반복하면 잘 안섞임\r\n\r\n![](./ex2.png)\r\n\r\n### 3. Mix Columns\r\n\r\n---\r\n\r\n![](./mc.png)\r\n한 컬럼의 일 부분이 다른 컬럼의 여러 부분에 영향을 미치게 한다\r\n\r\n마찬가지로 Columns만 움직임\r\n\r\ncell하나가 하나의 byte\r\n\r\n8bit를 다항식의 개수로 본다.(GF(2^8)의 폴리노미얼로 표현되는 원소가 된다)\r\n\r\n열에 있는 네 개의 cell과 주어진 행렬과 행렬곱 시킨다\r\n\r\n> 행렬의 수는 GF(2)로 표현된 다항식으로 만약 cell이 abcd고 곱할 행렬의 행이 2 3 1 1 이라면  \r\n> 행렬곱 결과는 xa + (x+1)b + c + d 가 된다\r\n\r\n일종의 substitution연산\r\n\r\n이에 대한 역연산은 결과값에 역행렬을 곱해주면 입력값이 나온다\r\n\r\n### 4. Add Round Key\r\n\r\n---\r\n\r\n단순히 `xor` : 128bit의 State를 128bit 라운드키와 `xor`\r\n\r\n그러나 Round key expansion은 복잡\r\n\r\n## 전체적인 프로세스\r\n\r\n---\r\n\r\n![](./aes-process2.png)\r\n\r\nAdd Round Key 전에는 input이 같으면 모두 똑같이 나오지만 Round key에 따라 같은 input이더라도 다른 output이 나온다.\r\n\r\n**AES의 안전성을 보장하는 가장 큰 요인은 key이다**\r\n\r\n![](./aes-process3.png)\r\n\r\n`ShiftRows`로 인해\r\n\r\n1. 첫 번째 행은 이동 안함.\r\n2. 두 번째 행은 오른쪽으로 세 칸(=왼쪽으로 한 칸) 이동\r\n3. 세 번째 행은 오른쪽으로 두 칸 이동\r\n4. 네 번째 행은 오른쪽으로 한 칸 이동\r\n\r\n바뀐 한 byte로 인해 `MixColumns`를 하면 더 다른 다항식이 만들어진다.\r\n\r\n## key expansion\r\n\r\n---\r\n\r\n![](./key-expansion.png)\r\n\r\nnonlinearity\r\n\r\nDiffusion: 어떤 한 비트의 변화가 여러 비트에 영향을 미치게 만드는 효과\r\n\r\nw0 ~ w3이 K0\r\nw4 ~ w7이 K1\r\n\r\n### 함수 g\r\n\r\n입력받은 word를 8bit씩 쪼개 4byte로 만든다  \r\n위치를 그림과 같이 이동시키고  \r\nS-box를 사용해 치환한다  \r\n치환한 값을 어떤 상수(4byte)와 xor한다\r\n\r\n## AES의 장점\r\n\r\n안전성도 안전성이지만 여러가지 프로세스적면에서 효율적\r\n\r\n1. 8bit의 기본 연산을 사용하는 cpu에서 잘동작한다.\r\n2. xor이나 shift 오퍼레이션등 간단한 연산 사용\r\n\r\n_우리가 사용하는건 32-bit processor인데 8bit연산이 효율적일까?_  \r\n32bit에서도 잘동작함.  \r\nBS, SR, MC의 세 오퍼레이션을 하나로 합칠수있음  \r\n4table lookups + 4XORs로 끝낼 수 있다\r\n"},{"excerpt":"APIView를 활용한 뷰 만들기 Serializer 정의 첫 번째 인자로 인스턴스를 받음 instance는 객체 post, put하는데 사용 두 번째 인자로 데이터를 받음 data는 form에서 requests.POST'name'가져오는것처럼 data를 받아오는 거인듯 Form 에서 첫 번째 인자는 data지만 시리얼라이저의 생성자의 첫 번째 인자는 i…","fields":{"slug":"/serializer/"},"frontmatter":{"date":"April 18, 2022","title":"REST","tags":["django","DRF"]},"rawMarkdownBody":"\r\n# APIView를 활용한 뷰 만들기\r\n\r\n## Serializer 정의\r\n\r\n```python\r\nclass PostSerializer(serializers.ModelSerializer):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n\r\nserializer = PostSerializer(data=request.POST)\r\n\r\nif serializer.is_valid():\r\n    return JsonResponse(serializer.data, status=201)\r\n#form의 __clean_data처럼 serializer.data를 통해 유효성 검사를 거친 데이터를 가져올 수 있다.\r\n#이건 장고 restframework의 기능을 안쓰고 form의 기능만 쓴 것\r\n#drf를 적용하려면 APIView 클래스 혹은 @api_view 장식자를 사용한다\r\nreturn JsonResponse(serializer.errors, status=400)\r\n```\r\n\r\n- 첫 번째 인자로 인스턴스를 받음\r\n\r\n  - instance는 객체 post, put하는데 사용\r\n\r\n- 두 번째 인자로 데이터를 받음\r\n\r\n  - data는 form에서 requests.POST['name']가져오는것처럼 data를 받아오는 거인듯\r\n\r\n    \r\n\r\n\r\n> Form 에서 첫 번째 인자는 data지만 시리얼라이저의 생성자의 첫 번째 인자는 instance이다\r\n\r\n```python\r\nPostSerializer(Post.objects.first()) # 인스턴스 객체를 넘겨준다\r\nPostSerializer(Post.objects.all(), many = True) # 다수도 가능\r\nPostSerializer(Post.objects.first()).data # 직렬화된 데이터가 나온다\r\n```\r\n\r\n\r\n\r\n## APIView\r\n"},{"excerpt":"Groups 두 가지에 대한 순서쌍 어떤 연산과 집합으로 합쳐서 정의  연산은 +도 될 수 있고 *도 될 수 있음. +일 경우엔 additive 그룹이라 부르고 * 경우엔 multiplicative 그룹이라고 부름 그룹을 만족시키는 필수 성질  : 닫혀있음 G안에 있는 a와 b가 있을 때 그 둘을 연산한 (a · b) 도 G안에 있어야한다  : 결합법칙 …","fields":{"slug":"/finite-field/"},"frontmatter":{"date":"April 18, 2022","title":"4-2 finite field (Galois Field)","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Groups\r\n\r\n두 가지에 대한 순서쌍\r\n\r\n어떤 연산과 집합으로 합쳐서 정의\r\n\r\n`·` 연산은 +도 될 수 있고 \\*도 될 수 있음.\r\n\r\n+일 경우엔 additive 그룹이라 부르고 \\* 경우엔 multiplicative 그룹이라고 부름\r\n\r\n### 그룹을 만족시키는 필수 성질\r\n\r\n1. `Closure` : 닫혀있음\r\n\r\nG안에 있는 a와 b가 있을 때 그 둘을 연산한 (a · b) 도 G안에 있어야한다\r\n\r\n2. `Associative` : 결합법칙\r\n\r\n   (a · b) · c = a · (b · c)\r\n\r\n3. `Identity element` : 항등원\r\n\r\n   a · e = a 를 만족시키는 항등원 e가 G에 존재한다\r\n\r\n   additive 그룹일경우 e = 0, multiplicative 그룹일경우 e = 1\r\n\r\n4. `Inverse element` : 역원\r\n\r\n   a · -a = e인 역원 a-1이 존재\r\n\r\n### Abelian group\r\n\r\n5. `Commutative` : 교환 법칙\r\n\r\n   G안의 모든 a와 b에 대해서 a · b = b · a 가 만족한다\r\n\r\n### Cyclic Group\r\n\r\nG안에 어떤 원소 a가 있는데 G의 모든 요소들을 aⁿ 형태로 나타낼 수 있을 때 `cyclic`하다고 한다\r\n\r\n이 때 a를 `generator`라고 부르고 그룹을 `generate`했다고함\r\n\r\n모든 `cyclic`그룹은 `abelian` 그룹이다.\r\n\r\nExponentiation : 그룹 연산을 반복해서 적용\r\n\r\nex) a³ = a · a · a\r\n\r\n## Fields\r\n\r\n어떤 집합과 연산 두 가지를 가지고 정의\r\n\r\n_(Group은 연산이 한 가지)_\r\n\r\n(GF로는 연산값을 mod했을 때 mod값이 전부 G에 포함인듯?\r\n\r\nGF(7) = [ {0, ... , 6}, + mod 7, \\* mod 7])\r\n\r\n- 그룹의 성질 1번 ~ 5번 모두 만족 (덧셈, 곱셈 모두에 대해서 abelian group 성립)\r\n\r\n- zero divisors 가 없음\r\n\r\n  만약 ab = 0이라면, a or b = 0이어야함\r\n\r\n- 덧셈과 곱셈에서 분배 법칙이 성립한다\r\n\r\n> 덧셈에서 그룹이라는 의미는 :\r\n>\r\n> 뺄셈 a - b는 a + (b의 역원)으로도 표현이 가능하다.\r\n>\r\n> 그룹의 모든 원소는 덧셈의 역원이 존재하므로 덧셈에서 그룹이라는건 뺄셈도 가능하다는 뜻\r\n>\r\n> 마찬가지로 곱셈에서 그룹이\r\n>\r\n> 라는 의미는:\r\n>\r\n> 그룹의 모든 원소는 곱셈의 역원이 존재하므로 나눗셈이 가능하다\r\n\r\n즉, 필드는 덧셈, 뺄셈, 곱셈, 나눗셈이 그 집합을 떠나지않고 잘 정의가 되는 구조\r\n\r\n유리수, 실수, 복소수는 모두 필드의 예시가 될 수 있으나\r\n\r\n정수는 필드가 될 수 없다\r\n\r\nwhy? **곱셈의 역원이 없는 수가 있기 때문**\r\n\r\nex) 3의 곱셈의 역원은 1/3 (not 정수!!)\r\n\r\n## Finite fields (=Galois Field)\r\n\r\n유한체 : 원소의 개수가 유한한 집합\r\n\r\nFinite fileds의 원소 개수는 반드시 pⁿ개 이다 (p는 소수)\r\n\r\nex) GF (15) - (x), GF(7) - (o)\r\n\r\n### 📌 GF(p) - Prime field\r\n\r\n원소의 개수가 pⁿ개인데 n이 1\r\n\r\n곱셈의 역원이 없는 정수들도 있지만\r\n\r\nmodulo와 서로소인수는 모두 곱셈의 역원이 있다\r\n\r\n**즉, modulo가 prime number라면 0을 제외한 모든 수(1~p-1)가 곱셈의 역원이 존재한다**\r\n\r\n\\# 덧셈의 역원 (mod 7)\r\n\r\n![](./addmod.png)\r\n\r\n\\# 곱셈의 역원 (mod 7)\r\n\r\n![](./mulmod.png)\r\n\r\n곱셈의 역원을 구하려면 `Extended euclid algorithm`을 써야함\r\n\r\n곱셈의 역원 테이블을 보면 대칭임 (= Abelian group, 교환법칙이 가능하다는 뜻 )\r\n\r\nGF(7) = [ {0, ... , 6}, + mod 7, \\* mod 7] <- 두 가지 연산을 모아서 필드가 정의됨\r\n\r\n지금까지 얘기한 것은 `Prime field`!\r\n\r\n> GF(pⁿ) 인데 n = 1\r\n\r\n이제 `Binary field`에 대해서 알아보자\r\n\r\n> GF(pⁿ) 인데 p = 2\r\n\r\n`Binary field`를 쓰는 이유는?\r\n\r\nDES같은 암호에서 입력이 64bit들어오면\r\n\r\nAES는 128bit 8bit로 나눠서 사용(256가지 조합. 2의 8승)\r\n\r\n256은 prime 아님 . 복잡해 ~~~\r\n\r\nbinary 쓰는게 맘 편함 ~ ㅎ 256가지 가지고 얍하려면 바이너리가 좋음\r\n\r\nGF(2^8)\r\n\r\n### 📌 Polynomial Divison\r\n\r\nf(x) = q(X)g(X) + r(x)\r\n\r\nr(x) = f(x) mod g(x)\r\n\r\n만약 r(x)가 0, (= g(x)가 f(x)를 나눴다면)\r\n\r\ng(x)|f(x)\r\n\r\ng(x) 는 f(x)의 `factor` or `divisor`이라고 부른다.\r\n\r\n#### irreducible\r\n\r\n> 어떤 다항식 f(x) 가 필드 F에 대해서 `irreducible`하다\r\n>\r\n> f(x)를 차수가 더 작은 두 개 이상의 다항식 곱으로 나타낼 수 없다\r\n>\r\n> 즉, 인수분해 될 수 없음\r\n>\r\n> prime과 비슷한 개념\r\n\r\n### 📌 GF(2) = Binary Field\r\n\r\n각 계수별로 mod 2 연산을 수행\r\n\r\nmod 2를 하면 덧셈과 뺄셈이 같아진다 `xor`\r\n\r\n`x` = `-x` = `xor`\r\n\r\n### 📌 Polynomial GCD\r\n\r\n두 다항식 a(x)와 b(x)의 GCD c(x)도 존재한다.\r\n\r\nc(x)는 a(x)와 b(x) 둘을 나눌 수 있다\r\n\r\n유클리드 알고리즘을 가지고 구할 수 있다\r\n\r\ntable 5.3은 GF(2³)\r\n\r\n![](./gf.png)\r\n\r\n> **Addition mod - 덧셈의 역원**\r\n>\r\n> (mod 2 이므로 같은 것을 더하면 0이 된다.)\r\n>\r\n> (x² + 1) 과 (x+1)을 더했을 때\r\n>\r\n> x² + x + 2 (2는 mod2로 인해 사라진다)\r\n>\r\n> 결과 : x² + x\r\n>\r\n> 좀 더 기계적?으로 보자면\r\n>\r\n> (x² + 1) = 101, (x+1) = 011\r\n>\r\n> 101과 011을 xor 연산하면 110. 즉, x² + x\r\n>\r\n> xor하는 이유는 mod 2에서 덧셈 = 뺄셈 = xor\r\n\r\n> **Multiplication mod**\r\n>\r\n> (x² + 1) 과 (x+1)을 곱했을 때 결과는 x³ + x² + x + 1\r\n>\r\n> modulo x³ + x + 1 인데 모듈러보다 결과값이 크므로 모듈러로 mod해준다\r\n>\r\n> (x³ + x² + x + 1) mod x³ + x + 1 는 x²\r\n>\r\n> 비트로 계산하려면 `xor`과 `shift`를 사용한다!!\r\n>\r\n> (x² + 1) = 101, (x+1) = 011\r\n>\r\n> 101 \\* 011 = 1111 = (1000 + 111)\r\n>\r\n> 1000을 mod 1011하면 결과는 011!\r\n>\r\n> (mod의 최고 차항을 mod로 나누면 최고차항을 뺀 나머지 다항식이 나머지가 된다. 예시로 x³ 을 x³ + x + 1로 나누면 나머지는 x + 1 )\r\n>\r\n> 1111 = (1000+111) = 011 + 111 = 100 즉, x²이다\r\n"},{"excerpt":"classification of Symmetric Encryption 현대에서 쓰이는 Symmetric Encryption은 Stream Cipher와 Block Cipher로 나뉜다.  Stream Cipher : key를 seed값으로 써서 bit stream generation 알고리즘을 돌림. 평문과 key를 연산 ideal case : One-t…","fields":{"slug":"/steam-block/"},"frontmatter":{"date":"April 18, 2022","title":"4-2 Stream Cipher와 Block Cipher","tags":["computer protection"]},"rawMarkdownBody":"\r\n## classification of Symmetric Encryption\r\n\r\n현대에서 쓰이는 Symmetric Encryption은 Stream Cipher와 Block Cipher로 나뉜다.\r\n\r\n![](./sb.png)\r\n\r\n- **Stream Cipher** : key를 seed값으로 써서 bit stream generation 알고리즘을 돌림. 평문과 key를 `xor`연산\r\n\r\n  ideal case : One-time pad\r\n\r\n- **Block Cipher** : 평문을 128bit단위로 잘랐다면 또 다른 128bit로 변경. 어떻게 변경할건지의 규칙이 key.\r\n\r\n  같은 평문이라도 어떤 key냐에 따라서 다른 cipher text생성\r\n\r\n  **key에 의해서 block cipher의 동작이 결정됨.**\r\n\r\n  **동작은 본질적으로 block 단위를 다른 블록으로 덮어쓰는 역할을 함**\r\n\r\n  (이 두 개가 중요함. 다른건 그냥 흐름정도만 이해)\r\n\r\n### Feistel Cipher\r\n\r\n**Block Cipher의 일종**\r\n\r\n> plain text를 두 부분으로 자르고 연산 반복  \r\n> <font size =\"2px\">(_두 개로 잘랐으니까 블록임. 암튼 블록임._) </font>  \r\n> 연산을 각각 한 다음에 두 개를 교차함  \r\n> 암호화와 복호화가 키 순서를 제외한 전체가 같은 계산을 반복한다\r\n\r\n- 많은 블록암호가 Feistel Cipher 형식을 취한다.\r\n\r\n- 물론 Feistel Cipher 형식이 아닌 블록암호도 있다 (ex. AES)\r\n\r\n- 내부적으로 substitution과 permutation으로 구성되어있다\r\n\r\n* Substitutions : 각 plaintext의 요소나 그룹 bit들을 다른 ciphertext 그룹으로 대체. 치환\r\n* Permutations : 각 원소의 순서를 바꿈. 위치이동. 전치. (permutation cipher와 혼동하면 안됨. 걔는 substitution의 일종)\r\n\r\nex) DES\r\n\r\n![](./des.png)\r\n\r\n치환, 전치 (두 개로 자르고 교차한다)\r\n\r\n라운드키, 서브키\r\n\r\n### Substitution-Permutation Network (SPN)(ex. AES)\r\n\r\n교차가 없음\r\n\r\nex) AES\r\n\r\n![](./aes.png)\r\n"},{"excerpt":"Access Control 접근제어 시큐리티 서비스 중 한 가지 어떤 공격에 대응하는 가장 효율적인 방법 중 하나 공격이 일어나기 전에 막는다 어떤 access 권한들이 있고 어떻게 허용할 것인지 엄격하게 정의 인가되지않은 공개, 부적절한 변경으로부터 데이터와 리소스를 보호하는 절차 Access Control의 Security policy 📌 Discre…","fields":{"slug":"/access-control/"},"frontmatter":{"date":"April 16, 2022","title":"1-2 Access Control","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Access Control\r\n\r\n---\r\n\r\n> 접근제어\r\n\r\n- 시큐리티 서비스 중 한 가지\r\n\r\n- 어떤 공격에 대응하는 가장 효율적인 방법 중 하나\r\n\r\n- 공격이 일어나기 전에 막는다\r\n\r\n- 어떤 access 권한들이 있고 어떻게 허용할 것인지 엄격하게 정의\r\n\r\n- 인가되지않은 공개, 부적절한 변경으로부터 데이터와 리소스를 보호하는 절차\r\n\r\n## Access Control의 Security policy\r\n\r\n---\r\n\r\n### 📌 Discretionary access control (`DAC` : 임의적 접근제어)\r\n\r\n​ 필수적인 요구조건이 있는 것이 아니라 사용자가 임의적으로 정함\r\n\r\n​ 정보의 소유자가 해당 정보에 대한 read, write, execute 권한을 모두 정함\r\n\r\n​ 사용자의 id나 groupid에 기반해서 제약 조건을 건다\r\n\r\nex) ACL(Access control list)\r\n\r\n`장점 ` : 주체별로 어떤 동작이 가능한지 세세하게 설정할 수 있다\r\n\r\n`단점` : 사용자를 어떻게 믿을 것 인지, 원치않게 권한이 상승할 수 있다\r\n\r\n### 📌 Mandatory access control (`MAC` : 강제적 접근 제어)\r\n\r\n​ 관리자가 접근 제어\r\n\r\n​ 규칙 기반 : **rule-based access control**\r\n\r\n​ ex)\r\n\r\n- Security label(중요도에 따라 계층이 나뉨)\r\n\r\n- Bell-LaPadula model\r\n  - read-up (x) : 2급이 1급 정보를 볼 수 없음\r\n  - write-down (x) : 1급 내용을 2급에 덮어쓸 수 없음\r\n- sandboxing : 벽을 두고 서로 넘어가지 못하게 함\r\n\r\n## Access Control Models(Implementations)\r\n\r\n---\r\n\r\n정책을 구현하는 실질적인 방법\r\n\r\n### 📌 Access Control Matrices(ACM)\r\n\r\n---\r\n\r\n- permissions을 정리하는 2차원 테이블\r\n\r\n- 객체와 주체가 있고 각 주체들이 객체들에 대해 어떤 동작을 할 수 있는지 명세\r\n\r\n- 직접적으로 구현하는 것은 비효율적. 공간이 어마어마!\r\n\r\n- 대부분 줄여서 사용\r\n\r\n- ex) 대부분의 entry들은 비어있을것. 이를 압축해서 표현\r\n\r\n### 📌 Access Control Lists (ACL)\r\n\r\n---\r\n\r\n![](./acl.png)\r\n\r\n- **객체 위주로 압축**, DAC의 일종\r\n\r\n- 간소화한 ACL : Unix File access control\r\n\r\n- 유닉스는 owner, group owner, other users 이렇게 세 가지로 뭉뚱그려서 표현\r\n\r\n- id별로 다 표시하진않음. ACM보다 정밀도가 떨어짐. 세부적 컨트롤이 어려움\r\n\r\n- ex) 특정 부분에 대한 access나 어떤 특정한 사용자를 제외한 모든 사용자는 접근이 불가같은 세부적인 컨트롤은 어렵다\r\n\r\n### 📌 Capabilities (CL)\r\n\r\n---\r\n\r\n![](./cl.png)\r\n\r\n- **주체 위주로 압축**\r\n\r\n​ 잘 사용되진않음\r\n\r\nex)\r\n\r\n> 놀이공원 티켓 : 어떤 놀이기구는 되고 어떤 앤 안됨\r\n>\r\n> android app permission : 이 앱은 어떤 리소스 접근은 되고 어떤건 안됨\r\n\r\n### 📌 Role-based Access Control (RBAC)\r\n\r\n---\r\n\r\n- 역할 기반\r\n\r\n- 주체가 어떤 역할, 직책을 가지고 있느냐가 중요\r\n\r\n- task 기반으로 자세하게 명령 가능. 세부적 컨트롤이 가능\r\n\r\n- 사용자 id 기반으로 권한을 부여한다면 본의 아니게 필요 이상 권한을 부여하게되기도하는데 역할 기반으로 권한을 줌으로써 세밀하게 task 설정 가능\r\n\r\n- 특정 작업에 대해서 권한 설정 가능\r\n\r\nex) create a credit account\r\n\r\n## User Authentication\r\n\r\n---\r\n\r\n사용자 인증\r\n\r\naccess control을 하기 위해선 누구인지 검증해야함\r\n\r\nidentification : 여러 주체들이 섞여있는 가운데서 누구인지 식별 가능\r\n\r\nAuthentication : 어떤 객체가 누구라고 주장했을 때 맞는지 확인\r\n\r\n- **유저가 알고있는 지식 기반**\r\n\r\n[비밀번호, PIN 등]\r\n\r\ndirect input vs challenge-response\r\n\r\ndirect input : 바로 입력하기\r\n\r\nchallenge-response : 질문에 답변해야 인증\r\n\r\n문제 : 패스워드 공간 문제(무작위 때려맞추기 공격 위험), 통계적인 분포, 어깨너머로 엿봄등\r\n\r\n- **유저가 지닌 물건 기반**\r\n\r\n[ID카드, security token, SIM, REID, OTP 등]\r\n\r\n문제 : 도난이나 분실 위험\r\n\r\n- **유저 자체나 행위 (생체 인증)**\r\n\r\n[지문, 얼굴, 서명 등]\r\n\r\n문제 : 프라이버시 문제, 바꾸기 어려움\r\n\r\n- **Two-factor authentication**\r\n\r\n위의 두 가지를 섞어 사용\r\n"},{"excerpt":"Divisibility b는 0이 아니다 b는 a의 divisor, a는 b의 multiple ex) 17|0, -5|30 a|1 이면 a는 ±1 a|b, b|a 이면 a = ±b 0이 아닌 모든 정수 b는 0의 약수가 된다 ( 나머지가 0이긴하니까... ) b|g and b|h 이면 b|(mg + nh) Division Algorithm 📌 Euclid…","fields":{"slug":"/number-theory/"},"frontmatter":{"date":"April 16, 2022","title":"2-2 Number Theory","tags":["computer protection"]},"rawMarkdownBody":"\r\n## Divisibility\r\n\r\n---\r\n\r\n```\r\n`a/b` = `a=mb` = `b|a`\r\n```\r\n\r\n_b는 0이 아니다_\r\n\r\nb는 a의 divisor, a는 b의 multiple\r\n\r\nex) 17|0, -5|30\r\n\r\n- a|1 이면 a는 ±1\r\n- a|b, b|a 이면 a = ±b\r\n- 0이 아닌 모든 정수 b는 0의 약수가 된다 ( 나머지가 0이긴하니까... )\r\n- b|g and b|h 이면 b|(mg + nh)\r\n\r\n### Division Algorithm\r\n\r\n---\r\n\r\n```\r\na = qn +r 일 때\r\n 0 ≤ r < n;\r\n q = [a/n] (작거나 같은 수 중 최대)\r\n```\r\n\r\n### 📌 Euclidean Algorithm : `for GCD`\r\n\r\n---\r\n\r\nfor `GCD`\r\n\r\ngcd(a,b) -> gcd(b, a mod b)\r\n\r\na>b 일 때, r이 0이 될 때까지 반복한다\r\n\r\n![](./ec1.png)\r\n\r\n### 모듈러 연산\r\n\r\n---\r\n\r\n```\r\na = qn +r\r\n0≤ r < n\r\n```\r\n\r\n-11 mod 7 = 3\r\n\r\n-11 = 7\\*-2 +3\r\n\r\n### 📌 합동(congruent)\r\n\r\n---\r\n\r\n(a mod n) = (b mod n)\r\n\r\n-> `a ≡ b (mod n)` : 우와! 합동이다!\r\n\r\n만약 `a ≡ 0 (mod n)`이라면, n|a이다.\r\n\r\n-> a를 n으로 나눴을 때 나머지가 0이라는 뜻이므로\r\n\r\nex)\r\n\r\n> 73 ≡ 4 (mod 23)\r\n>\r\n> : 73을 23으로 나눴을 때의 나머지와 4를 23으로 나눴을 때의 나머지가 같다\r\n>\r\n> 21 ≡ -9 (mod 10)\r\n\r\n#### 📌 Properties of Congruences\r\n\r\n---\r\n\r\n1. a ≡ b (mod n) iff n|(a-b)\r\n2. a ≡ b (mod n) 이면, b ≡ a (mod n)\r\n3. a ≡ b (mod n) & b ≡ c (mod n) 이면, a ≡ c(mod n)\r\n\r\n1번 증명 : 만약 `n | (a-b)` 이면 `(a-b) = kn`\r\n\r\n-> `a = b + kn`\r\n\r\n> `(b + kn) mod n` = b mod n\r\n\r\n따라서 `a mod n` = `b mod n`, 즉 `a ≡ b(mod n)`\r\n\r\n### 📌 Modular Arithmetic\r\n\r\n---\r\n\r\n1. [(a mod n) + (b mod n)] mod n = (a + b) mod n\r\n2. [(a mod n) - (b mod n)] mod n = (a - b) mod n\r\n3. [(a mod n) * (b mod n)] mod n = (a \\* b) mod n\r\n\r\n**증명**\r\n\r\na = r1 + jn,\r\n\r\nb = r2 + kn 이라고 할 때\r\n\r\n(a+b) mod n = (r1 + jn + r2 + kn) mod n\r\n\r\n= ( r1 + r2 +(j+k)n ) mod n \\# mod n 에 의해 (j+k)n 은 0이 된다.\r\n\r\n= ( r1 + r2 ) mod n\r\n\r\n= a (mod n) + b (mod n)\r\n\r\n### 📌 Arithmetic Modulo 8\r\n\r\n---\r\n\r\n항등원 : 연산을 해도 처음 값과 똑같이 나오게 해주는 수\r\n\r\n> 덧셈의 항등원 : 0, 곱셈의 항등원 : 1\r\n\r\n📌 역원 : 연산을 했을 때 항등원이 나오게 해주는 수\r\n\r\n덧셈의 역원은 모든 수에게 있지만 곱셈의 역원은 특정한 수에게만 있다\r\n\r\n**곱셈의 역원이 존재하려면 Modulo와 서로소여야한다.**\r\n\r\n> 덧셈의 역원 : [ a + (역원) ] mod n = 0\r\n>\r\n> ex) modulo 8에서 3의 역원은 5이다 : **(3+5) mod 8 = 0**\r\n>\r\n> 곱셈의 역원 : [ a * (역원) ] mod n = 1\r\n>\r\n> ex) modulo 8 에서 5의 역원은 5이다. : **(5\\*5) mod 8 = 1**\r\n\r\n### Properties of Modular Arithmetic for Int in Zn\r\n\r\n---\r\n\r\nZ : 모든 정수의 집함\r\n\r\nZn : Z를 n으로 나눴을 때 나머지가 되는 정수들의 집합\r\n\r\n= {0, 1, 2, ... , n-1}\r\n\r\n교환 법칙, 결합 법칙, 분배 법칙, 항등원, 역원\r\n\r\n(곱셈의 역원은 있을 수도 있고 없을 수도 있으니 정의되어있지않음)\r\n\r\n### 📌 Extended Euclidean Algorithm : `for 곱셈의 역원`\r\n\r\n---\r\n\r\n```\r\nfor 곱셈의 역원\r\n```\r\n\r\n![](./eea1.png)\r\n\r\n> modulo 1759에서 550의 곱셈의 역원은 355이다\r\n>\r\n> modulo 550에서 1759의 곱셈의 역원은 439이다\r\n>\r\n> 원래 1759 \\* -111 이지만 -111은 음수이므로 -111을 mod 550해서 양수로 만든다\r\n>\r\n> -111 mod 550 = 439\r\n\r\n### 📌 Fermat's Theorem\r\n\r\n---\r\n\r\n**prime numbers**\r\n\r\n어떤 정수 a는 (n제곱 형태의 ) prime numbers들의 곱 형태들로 표현할 수 있다\r\n\r\n편의상 앞으로 prime number를 **p**로 나타내겠음\r\n\r\n![](./fc.png)\r\n\r\n- p는 prime이고 a는 p로 나눠지지않는 양의 정수일 때 :a와 p가 서로소\r\n\r\n  a mod p = 0\r\n\r\n  **a(^p-1) mod p 를 했을 때 1이 나옴**\r\n\r\n- p는 prime이고 a는 양의 정수\r\n\r\n  a(^p) ≡ a (mod p)\r\n\r\n### Euler totient function\r\n\r\n---\r\n\r\n1부터 n까지의 양수 중 n과 서로소가 되는 수들의 개수\r\n\r\n![](./euler1.png)\r\n\r\np와 q가 prime number라면 서로소가 되는 수들의 개수는 p-1, q-1이다\r\n\r\n![](./euler2.png)\r\n\r\n### Primality test\r\n\r\n---\r\n\r\nprime인지 아닌지 test\r\n\r\n![](./pt.png)\r\n\r\n#### Trial division\r\n\r\n처음부터 무식하게 다 나눠보기\r\n\r\n#### Fermat test\r\n\r\n확률적인 방법\r\n\r\n페르마의 정리 : 만약 p가 prime이고 a와 p가 서로소라면,\r\n\r\n무조건 `a(^p-1) ≡ 1 (mod p)` 이다. (a는 유클리드 알고리즘을 사용해 구한다)\r\n\r\n`a(^p-1) ≡ 1 (mod p)` 가 아니라면 p는 prime이 아니다\r\n\r\n`a(^p) ≡ a (mod p)`\r\n\r\n왜냐면 a(^p-1) 였을 때 mod p 하면 1이었으니까 ...\r\n\r\n그 1에다가 a곱하고 mod p하면 a가 나올 수 밖에 없음 (둘이 서로소니까 나눠질 가능성은 0)\r\n\r\n#### Miller-Rabin test\r\n\r\n- Fermat test (기본적으로는 페르마 테스트)\r\n- NSR (nontrivial sqare root) test (에 추가)\r\n\r\n      `x² mod n = 1` 이 참일 때 x가 1 또는 n-1이 아니라면 n은 prime이 아니다\r\n\r\n​ ex) 4² mod 15 = 1 , 그러므로 15는 prime이 아니다\r\n\r\n#### Deterministic algorithm\r\n\r\nmiller-rabin은 틀릴 확률이 조금이지만 있음. trial처럼 100%맞는 알고리즘은 없을까?\r\n\r\nAKS 알고리즘\r\n\r\ntrial보다는 빠르지만 miller-rabin보다 느림\r\n\r\n#### Hybrid\r\n\r\nex) trialdivison + MR/Fermat\r\n\r\nprime인지 test할 수 n을 루트n까지 다 하지하고 어느정도만 trial division을 수행하다가 어느정도까지 수행을 했으면 MR/Fermat로 넘어가는\r\n\r\n### 📌 Power of Integers, Modulo 19\r\n\r\n거듭 제곱\r\n\r\n![](./mod19.png)\r\n\r\n- 페르마의 정리에 의해 18제곱에서는 모두 1 `a(^p-1) ≡ 1 (mod p)`\r\n\r\n- 수마다 특정 사이클이 존재한다\r\n\r\n- 사이클 내 중복인 수는 존재하지 않는다\r\n\r\n- 18까지 사이클이 유지되는, 사이클내에 1부터 17까지 전부 있는 수들은 `generator`라고 부른다. ex) 2, 3, 10, 13, 14, 15\r\n\r\n- `generator`의 n제곱 형태인 수들은 `generator`의 사이클을 축약해서 가지고 있다\r\n\r\n- 이전 mod 결과값?에 a를 곱해서 바로 다음의 mod 결과값을 구할 수 있다.\r\n\r\n  ex) 2를 예시로 볼 때 2의 5제곱 mod 19값인 13에서 바로 2를 곱한 26을 mod 19하면 2의 6제곱 mod 19값인 7이 나온다.\r\n\r\n### 📌 Discrete log\r\n\r\n![](./dis.png)\r\n\r\nex) 2와 17과 19를 인자로 주고 (2^n) mod 19 = 17일 때, n은 몇인가? 를 구하는 것을 디스크립트 로그라고한다. : 답은 10\r\n\r\n이후 정수 소인수분해와 디스크리트 로그에 기반한 암호화가 나옴\r\n\r\n수학적으로 풀기 어렵기 때문\r\n"},{"excerpt":"보안이란? 자동화된 정보 시스템을 보호 정보 시스템 자원의 confidentiality, integrity, availability 보존 보안의 요구 조건 : CIA + AA 📌 기밀성 (Confidentiality)  중요한 정보가 허가받지않은 개인 주체에 의해서 공개되거나 가용될 수 없다. 허가받은 사람만 중요한 정보를 볼 수 있어야 한다    개인이…","fields":{"slug":"/cia-aa/"},"frontmatter":{"date":"April 16, 2022","title":"1-1 컴퓨터 보안의 요구 조건 (CIA + AA)","tags":["computer protection"]},"rawMarkdownBody":"\r\n**보안이란?**\r\n\r\n- 자동화된 정보 시스템을 보호\r\n\r\n- 정보 시스템 자원의 confidentiality, integrity, availability 보존\r\n\r\n## 보안의 요구 조건 : CIA + AA\r\n\r\n### 📌 기밀성 (Confidentiality)\r\n\r\n- `Data Confidentialiy`\r\n\r\n  중요한 정보가 허가받지않은 개인 주체에 의해서 공개되거나 가용될 수 없다.\r\n\r\n  허가받은 사람만 중요한 정보를 볼 수 있어야 한다\r\n\r\n- `Privacy`\r\n\r\n      개인이 자신과 관련되어 어떤 정보들이 저장되는지, 누구에게 공개될 수 있는 지 제어를 하고 영향을 미친다\r\n\r\n      정보의 주권을 자신이 가지고있다\r\n\r\n### 📌 무결성 (Integrity)\r\n\r\n- `Data Integrity`\r\n\r\n      미리 정의되거나 허가된 방법으로 integrity되어야 한다.\r\n\r\n​ 허가 받지 않은 상태로 변경이 불가하다.\r\n\r\n​ 변경이 되었을 때 바로 확인이 가능해야한다.\r\n\r\n- `System Integrity`\r\n\r\n      시스템의 허가받지않은 변경을 막을 수 있어야한다.\r\n\r\n      시스템의 허가받지않은 변경이 불가하다\r\n\r\n### 📌 가용성 (Availability)\r\n\r\n정상적인 유저에게 정상적인 서비스를 제공한다\r\n\r\n### 📌 책무성 (Accountability)\r\n\r\n어떤일이 벌어졌을 때 책임 소재를 가릴 수 있다\r\n\r\n### 📌 인증 (Authentication)\r\n\r\n누가 진짠지 아닌지 확인할 수 있다\r\n\r\n<br/>\r\n\r\n## 컴퓨터 보안의 어려움\r\n\r\n---\r\n\r\n- 항상 공격자가 유리, 잠재적 공격에 모두 반응해야함\r\n\r\n- 계속 지켜봐야함\r\n- 시큐리티 매커리즘 : 여러 알고리즘의 조합이 어려움\r\n- 보안에 대한 투자 비용 대비 효용성 떨어짐\r\n"},{"excerpt":"OSI 보안 구조 Security attack Security mechaism Security service Threat & Attack 📌 Security attack 💥 passive attack 공격이 일어난 뒤 시스템에 변형이 일어나지않음 두 가지 타입이 존재 release of message contents traffic analysis ex) …","fields":{"slug":"/osi-structure/"},"frontmatter":{"date":"April 16, 2022","title":"1-1 OSI 보안 구조","tags":["computer protection"]},"rawMarkdownBody":"\r\n## OSI 보안 구조\r\n\r\n1. Security attack\r\n2. Security mechaism\r\n3. Security service\r\n\r\n## Threat & Attack\r\n\r\n### 📌 Security attack\r\n\r\n---\r\n\r\n#### 💥 **passive attack**\r\n\r\n> 공격이 일어난 뒤 시스템에 변형이 일어나지않음\r\n>\r\n> 두 가지 타입이 존재\r\n>\r\n> 1. release of message contents\r\n> 2. traffic analysis\r\n\r\nex) 메세지 도청, 메세지 복사\r\n\r\n- `release of message contents`\r\n\r\n  암호화로 방어\r\n\r\n- `traffic analysis` :\r\n\r\n  암호화된 패킷 자체가 유통되고있다는게 약점이 됨, 어느 시간대에 패킷이 많이 유통되는지도 힌트가 될 수 있음\r\n\r\n  Tor로 방어\r\n\r\n#### 💥 **active attack**\r\n\r\n> 시스템 자원이나 동작을 변형시킴\r\n\r\nex) 메세지 가로챔, 메세지 전송자 흉내내서 다른 메세지 전송\r\n\r\n- `Masquerade` : 다른 사람인척 (수신자인척 메세지 보냄)\r\n\r\n- `Replay` : 100원 보내는 동작이 있다면 이걸 10000번 수행\r\n\r\n- `Modification of messages` : 메시지 내용 수정\r\n\r\n- `Denial of service` : 메시지 수신 막기\r\n\r\n#### 그렇다면 active attack이 더 치명적일까?\r\n\r\n> 답은 경우에 따라 다르다!\r\n>\r\n> 패시브 어택의 경우 공격받았는지 조차 모름\r\n>\r\n> 피해를 받았음을 알면 대응이 가능할수도있음\r\n\r\n### 📌 Security service\r\n\r\n---\r\n\r\n> 1. Data Confidentiality\r\n> 2. Data Integrity\r\n> 3. Availability\r\n> 4. Authentication\r\n> 5. Nonrepudation (for accountability)\r\n> 6. Access Control\r\n\r\n#### Data Cofidentiality\r\n\r\n> 기밀성 보호에 초점\r\n\r\n패시브 어택에 대한 방어 (아무도 못 봐)\r\n\r\n트래픽 보호(어디서부터 어디로 가는지, 빈도, 패킷길이등)\r\n\r\n#### Data Integrity\r\n\r\n> 메시지가 변경되는 것에 초점\r\n\r\n단일 메세지, 메세지 스트림에 적용 가능\r\n\r\n커넥션이 없는 경우 : 단일 메세지 - 메세지 변조에 초점, 어떤 부분이 복제, 삭제, 추가 되었는가\r\n\r\n커넥션이 있는 경우 : 메세지 스트림 - reordering(메세지 순서가 바뀜)\r\n\r\n**원래의 상태가 바뀌지않는것에 중심을 둔다**\r\n\r\n#### Availability Service\r\n\r\n> 서비스 제공에 초점\r\n\r\nDOS(denial-of-service attack) 공격에 초점\r\n\r\n#### Authentication\r\n\r\n> 사용자 인증에 초점\r\n\r\n`Peer entity authentication` : 양방향 소통중 상대방이 누구인지 인증. 사용자를 인증\r\n\r\n`Data origin authentication` : 데이터가 전송될 때 그 데이터가 내가 기대하는 사람으로부터 받은게 맞는지 확인 (Masquerade등 막음:진위여부판단)\r\n\r\n#### Nonrepudiation (for accountability)\r\n\r\n> 책임 소재를 가리는 것에 초점\r\n\r\n사용자가 부인하지않게. 누군가 메세지를 보냈다면 그 사람이 보냈다는걸 확인할 수 있게\r\n\r\n#### Access Control\r\n\r\n(CIAAA 의 조건에 들어가진않지만 다섯개와 연결된 개념)\r\n\r\n커뮤니케이션 링크를 통해 호스트 시스템&app에 접근하는 것을 제어\r\n\r\n`identified` : 이 사람이 누구인지 먼저 신원 확인\r\n\r\n`authenticaticated` : 이 사람이 누구라고 주장할 때 맞는지 검증\r\n\r\n![](./core-concepts.png)\r\n\r\n **Attacks** : 보안 공격의 종류\r\n\r\n **Security Services** : 보안이 제공하는 서비스\r\n\r\n **Security Mechanisms** : 서비스 목적을 달성시키기위한 재료. 도구\r\n\r\n`Message authentication` 또는 `Digital signature`를 사용해 **Integrity**와 **Authenticity** 를 지킬 수 있다.\r\n\r\n`Digital signature`는 `Message authentication` 와 달리 **Accountablility (Nonrepudiation)**도 달성할 수 있다\r\n\r\n## Fundamental Security Design Principle\r\n\r\n---\r\n\r\n보안 디자인 설계 룰\r\n\r\n- Economy of mechanism : 작고 간단하게. 비용적&관리적측면에서 경제적으로!\r\n\r\n- Fail-safe defaults : 보안의 기본 정책은 exclusion이 아닌permission에 기본해야한다. ex) 이건 안돼(x) 이것만 허용(o)\r\n\r\n- Complete mediation : access 할 때 마다 모든 access 확인, 각각의 자원마다 체크한다.\r\n\r\n- Open design : 개방형 설계, 보안 시스템을 열고 모두가 볼 수 있게한다. 집단 지성\r\n\r\n- Separation of priviledge : 권한 세분화, 하나 뚫렸을 때 전체가 망가지지않게\r\n\r\n- Least privilege : 권한 최소화\r\n\r\n- Least common mechanism : 공유 메커니즘 최소화\r\n\r\n- Psychological acceptablility : 심리적으로 받아들일수있게 , 심리적 압박감&불편함 최소화 - 사용자 편의성 관련, 사용자에게 투명해야함. 사용자는 시큐리티 매커리즘이 있는지 모르게 해주는게 좋음\r\n\r\n- Isolation : 분리, public과 critical 분리. 중요한 시스템은 public이 접근할 수 없게 분리해야한다\r\n\r\n- Encapsulation : 캡슐화. 안의 내부적인 구성에 대해서는 알려주지않아도된다.\r\n\r\n- Modularity : 모듈별로 설계, 한 쪽의 에러가 다른 쪽에 영향을 끼치지않게\r\n\r\n- Layering : 겹치는 보호\r\n\r\n- Least astonishment : 사용자를 놀라게하면안됨. 사용자가 예상할 수 있는 범위내에서 동작해야함\r\n\r\n## Attack Surfaces\r\n\r\n---\r\n\r\n시스템이 있을 때 거기에 존재하는 취약점들을 말함\r\n\r\n공격자가 뚫고 들어갈 수 있는 표면\r\n\r\n### Attack Surface Categories\r\n\r\n---\r\n\r\n#### Network attack surface\r\n\r\n네트워크를 통해서 공격\r\n\r\n#### Software attack surface\r\n\r\n프로그래밍이 잘못되었다는 등의 이유로 소프트웨어를 통해 공격\r\n\r\n#### Human attack surface\r\n\r\n사람을 공격!\r\n\r\n중요 시스템을 다루는 사람을 공격!\r\n\r\n## Attack Tree\r\n\r\n---\r\n\r\n어떤 대상을 공격하는 체계\r\n\r\nbranching과 계층이 있다\r\n\r\n\\+ Cyber kill chain : 어택 트리와 마찬가지로 공격의 절차를 보여준다. 어택 트리가 공격의 목표에 다다르기위해 어떤 기술들을 쓸 수 있는지 트리형식으로 보여줬다면 사이버 킬 체인은 실제로 공격에 도달하기 위해 공격자가 뭐하고 뭐하고 뭐해야하는지 쭉 나열되어있음\r\n\r\n### Model for Network Security\r\n\r\n---\r\n\r\n![](./model.png)\r\n\r\n### Standards\r\n\r\n표준을 정하는 기관들\r\n\r\nNIST, ISOC, ITU-T, ISO\r\n\r\n그 외 TTA, KS, IEEE 등 더 있음\r\n"},{"excerpt":"Background decision-making : data를 토대로 분석해 더 나은 방향 추진 buying pattenrn : 물건을 사는 패턴 분석 large-scale에서 중요한 역할 Feature of Data Mining : 미래 예측 ai가 나오면서 예측이 더 쉬워짐 visulaization : 시각화, 그래프나 도표 Approach of Da…","fields":{"slug":"/datamining/"},"frontmatter":{"date":"April 14, 2022","title":"작성중","tags":["ai","inha"]},"rawMarkdownBody":"\r\n### Background\r\n\r\n---\r\n\r\ndecision-making : data를 토대로 분석해 더 나은 방향 추진\r\n\r\nbuying pattenrn : 물건을 사는 패턴 분석\r\n\r\nlarge-scale에서 중요한 역할\r\n\r\n### Feature of Data Mining : 미래 예측\r\n\r\n---\r\n\r\nai가 나오면서 예측이 더 쉬워짐\r\n\r\nvisulaization : 시각화, 그래프나 도표\r\n\r\n### Approach of Data Mining\r\n\r\n---\r\n\r\n**Supervised data** : 많은 인풋과 그에 따른 아웃풋 제공.(많은 표본들) 이후 인풋을 보고 아웃풋 예측\r\n\r\n**Unsupervised data** :\r\n\r\nL :{b,c,e} 4개 중에 2개 서포트 (50%)\r\n\r\nL -c :=e 4개 중에 3개 (75%)\r\n"},{"excerpt":"CBV api 사용해보기2 : crud CreateView DeleteView","fields":{"slug":"/CBV-api2/"},"frontmatter":{"date":"April 13, 2022","title":"CBV api 사용해보기2 : crud","tags":["django","python"]},"rawMarkdownBody":"\r\n## CBV api 사용해보기2 : crud\r\n\r\n---\r\n\r\n#### CreateView\r\n\r\n```python\r\nclass PostCreateView(CreateView):\r\n    model = Post\r\n    form_class = PostForm\r\n\r\n    def form_valid(self, form):\r\n        self.object = form.save(commit = False)\r\n        self.object.author = self.request.user\r\n        messages.success(self.request, \"포스트 저장 완료\")\r\n        return super().form_valid(form) #CreateView함수의 form_valid()\r\n\r\npost_new = PostCreateView.as_view()\r\n```\r\n\r\n#### DeleteView\r\n\r\n```python\r\nclass PostDeleteView(LoginRequiredMixin, DeleteView):\r\n    model = POST\r\n\r\n    # 성공하면 이동할 url\r\n    #success_url = reverse('instagram:post_list')\r\n    # success_url은 프로젝트 로딩전 호출, 그러나 instagram:post_list가 적힌 프로젝트.urls는 프로젝트 로딩이 되면서 읽어오기때문에 오류가 생긴다.\r\n\r\n    # 그렇다면 어떻게 success_url을 설정할까?\r\n    # 방법1) 함수로 구현\r\n    def get_success_url(self):\r\n        return reverse(\"instagram:post_list\")\r\n    # 함수는 실제로 success_url이 필요할 때 실행된다.\r\n\r\npost_delete = PostDeleteView.as_view()\r\n```\r\n\r\n```python\r\nclass PostDeleteView(LoginRequiredMixin, DeleteView):\r\n    model = POST\r\n\r\n    # 방법1) reverse_lazy 사용\r\n\tsuccess_url = reverse_lazy('instagram:post_list')\r\n    # reverse_lazy는 실제 success_url이 필요할 때 사용한다.\r\npost_delete = PostDeleteView.as_view()\r\n```\r\n"},{"excerpt":"Messages Framework 현재 User를 위한 1회성 메시지를 담는 용도  인스턴스를 통해 메시지를 남긴다. ​ 즉, View에서만 사용 가능 메시지는 1회 노출되고 사라진다 View를 통한 템플릿 시스템을 통해 노출을 하면 템플릿 내에서 JS를 통한 노출도 가능 Message Levels를 통한 메시지 분류 파이썬 로깅 모듈의 Level을 차용…","fields":{"slug":"/messages/"},"frontmatter":{"date":"April 13, 2022","title":"Django의 Messages Framework","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n## Messages Framework\r\n\r\n---\r\n\r\n현재 User를 위한 1회성 메시지를 담는 용도\r\n\r\n- `HttpRequest` 인스턴스를 통해 메시지를 남긴다.\r\n\r\n​ 즉, View에서만 사용 가능\r\n\r\n- 메시지는 1회 노출되고 사라진다\r\n\r\n- View를 통한 템플릿 시스템을 통해 노출을 하면 템플릿 내에서 JS를 통한 노출도 가능\r\n\r\n### Message Levels를 통한 메시지 분류\r\n\r\n---\r\n\r\n파이썬 로깅 모듈의 Level을 차용\r\n\r\n레벨에 따라 로깅 여부 판단\r\n\r\n​ 혹은 템플릿에서 다른 스타일로 노출\r\n\r\n**레벨 종류**\r\n\r\n- DEBUG : 디폴트 설정으로 무시되는 레벨, 개발 관련된 메세지이며, 실서비스에서는 무시\r\n- INFO : 해당 유저에 대한 정보성 메세지\r\n- SUCCESS : 액션이 성공적으로 수행되었음을 알림.\r\n- WARNING : 실패가 아직 발생하진않았지만, 임박했다.\r\n- ERROR : 액션이 수행되지 않았거나 다른 Failure가 발생했다.\r\n\r\n### Messages 등록\r\n\r\n---\r\n\r\n\\# views.py\r\n\r\n```python\r\nfrom django.contrib import messages\r\n\r\ndef post_new(request):\r\n    ...\r\n    if form.is_valid():\r\n        post = form.save()\r\n        #messages.add_message(request, messages.SUCCESS, \"새 글이 등록되었습니다.\")\r\n        message.success(request, \"새 글이 등록되었습니다.\")\r\n        return redirect(post)\r\n```\r\n\r\n### Messages 소비\r\n\r\n---\r\n\r\n**messages context_processor를 통해 messages 목록에 접근**\r\n\r\n.tag 속성을 통해 레벨을 제공\r\n\r\n.message 속성을 통해 내용을 제공 (=str(message))\\\r\n\r\n\\# template/post_new.html\r\n\r\n```html\r\n{% if messages %}\r\n<ul class=\"messages\">\r\n  {% for message in messages %}\r\n  <li>[{{ message.tag }}] {{ message.message }}</li>\r\n  {% endfor %}\r\n</ul>\r\n{% endif %}\r\n```\r\n\r\n### Bootstrap4 스타일과 대응\r\n\r\n---\r\n\r\n![](./bs.png)\r\n\r\n부트스트랩4와 바로 대응 시키려면 **messages tag**를 변경하면된다!\r\n\r\n#### messages tags 변경하기\r\n\r\n---\r\n\r\n\\# settings.py\r\n\r\n```python\r\nfrom djangp.contrib.messages import constants as messages_constants\r\n\r\nMESSAGE_TAGS = {\r\n    messages_constants.DEBUG : 'secondary',\r\n    messages_constants.ERROR : 'danger',\r\n}\r\n```\r\n\r\n\\# html\r\n\r\n```html\r\n{% if messages %} {% for message in messages %}\r\n\r\n<div class=\"alert alert-{{ message. tag }}\">{{ message.message }}</div>\r\n\r\n{% endfor%} {% endif %}\r\n```\r\n"},{"excerpt":"HttpRequest를 받아 HttpResponse로 응답한다 HttpRequest 객체 **클라이언트로부터의 모든 요청 내용을 담고 있으며 ** 함수 기반 뷰 : 매 요청시마다 뷰 함수의 첫번째 인자 로 전달 클래스 기반 뷰 : 매 요청시마다 를 통해 접근 패킷 헤더 : get data는 헤더에만 필요한 정보가 있음. 바디 사용 x 공백 바디 : pos…","fields":{"slug":"/httprequest-httpresponse/"},"frontmatter":{"date":"April 12, 2022","title":"HTTPRequest와 HttpResponse","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n**HttpRequest를 받아 HttpResponse로 응답한다**\r\n\r\n## HttpRequest 객체\r\n\r\n---\r\n\r\n**클라이언트로부터의 모든 요청 내용을 담고 있으며 **\r\n\r\n함수 기반 뷰 : 매 요청시마다 뷰 함수의 첫번째 인자 `request`로 전달\r\n\r\n클래스 기반 뷰 : 매 요청시마다 `self.request`를 통해 접근\r\n\r\n패킷\r\n\r\n[헤더 : get data는 헤더에만 필요한 정보가 있음. 바디 사용 x]\r\n\r\n공백\r\n\r\n[바디 : post 관련 data]\r\n\r\n### Form 처리 관련 속성들\r\n\r\n---\r\n\r\nrequest. ( )\r\n\r\n.method : 요청의 종류 \"GET\" 또는 \"POST\"\r\n\r\n.GET : GET 인자 목록 (QueryDict 타입)\r\n\r\n.POST : POST 인자 목록 (QueryDict 타입)\r\n\r\n.FILES : POST 인자 중에서 파일 목록 (MultiValueDict 타입)\r\n\r\n### MultiValueDict\r\n\r\n---\r\n\r\n> dict을 상속받은 클래스\r\n>\r\n> 동일 key의 다수 value를 지원하는 사전\r\n\r\nhttp 요청에서는 하나의 key에 대해서 여러 값을 전달받을 수 있어야 함.\r\n\r\nURL의 QueryString같은 Key로서 다수 Value지정을 지원\r\n\r\nex) name=TOM&name=Steve&name=Hongo\r\n\r\n## HttpResponse\r\n\r\n---\r\n\r\n어떠한 뷰 함수에 응답 반환값은 무조건 HttpResponse임\r\n\r\n(미들웨어 이미지 캡처)\r\n\r\n## JsonResponse\r\n\r\n---\r\n\r\n`HttpResponse`를 상속받아서 사용 가능\r\n\r\n직렬화 : Json 객체를 문자열로 변환\r\n\r\n장고에는 `Django JSONEncoder`라는게 존재.\r\n\r\n파이썬의 json.JsonEncoder를 상속받아서 DJango 만의 특징에 맞게 변환\r\n\r\n## StreamingHttpResponse\r\n\r\n---\r\n\r\n효율적인 큰 응답을 위함. & 메모리를 많이 먹는 응답\r\n\r\nbut Django는 short-lived 요청에 맞게 디자인!\r\n\r\n​ 큰 응답시에는 극심한 성능 저하로 이어질 수 있음\r\n\r\n​ : 이럴 때는 별도의 웹 서버등 다른 서비스를 이용하는게 좋음\r\n\r\n## FileResponse\r\n\r\n---\r\n\r\n`StreamingHttpResponse`를 상속받음  \r\n파일 내용 응답에 최적화\r\nContent-Length, Content-Type, Content-Disposion 헤더 자동 지정  \r\nContent-Disposion : 파일 다운로드 다이로그\r\n\r\n인자인 `as_attachment`를 True로 주면 Content-Disposion 헤더 지정\r\n"},{"excerpt":"필드 별로 유효성 검사 함수 추가 적용 MinLengthValidator가 이미 존재하긴함 모델단에도 설정 가능~ models.py에서 설정해 ModelForm에서 사용할수도있다 models.py forms.py 모델단에 지정한 validator를 ModelForm이 알아서 가져감 유효성 검사 호출 로직 form.is_valid() 가 호출되었을 때 1.…","fields":{"slug":"/clean-validators/"},"frontmatter":{"date":"April 12, 2022","title":"장고 폼의 유효성 검사 : clean과 validators","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### 필드 별로 유효성 검사 함수 추가 적용\r\n\r\n---\r\n\r\n```python\r\nfrom django import forms\r\n\r\ndef min_length_3_validator(value):\r\n    if len(value) < 3:\r\n        raise form.ValidationError(\"3글자 이상 입력해주세요\")\r\n\r\nclass PostForm(forms.Form):\r\n    title = forms.CharField(validators=[min_length_3_validators])\r\n```\r\n\r\n_MinLengthValidator가 이미 존재하긴함_\r\n\r\n```python\r\nfrom django.core.validators import MinLengthValidator\r\n\r\nmin_length_3_validator = MinLengthValidator(3)\r\n```\r\n\r\n#### 모델단에도 설정 가능~\r\n\r\n---\r\n\r\n**models.py에서 설정해 ModelForm에서 사용할수도있다**\r\n\r\n#models.py\r\n\r\n```python\r\nfrom django import models\r\n\r\ndef min_length_3_validator(value):\r\n    if len(value) < 3:\r\n        raise form.ValidationError(\"3글자 이상 입력해주세요\")\r\n\r\nclass Post(forms.Model):\r\n    title = models.CharField(max_length=100, validators=[min_length_3_validator])\r\n    content = models.TextField()\r\n```\r\n\r\n#forms.py\r\n\r\n```python\r\nfrom django import forms\r\nfrom .models import Post\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n        #fields = ['title', 'content']\r\n```\r\n\r\n모델단에 지정한 validator를 ModelForm이 알아서 가져감\r\n\r\n### 유효성 검사 호출 로직\r\n\r\n---\r\n\r\n**form.is_valid() 가 호출되었을 때**\r\n\r\n#### 1. form.full_clean() 호출\r\n\r\n​ **1. 각 필드 객체 별로 수행**\r\n\r\n​ 각 필드객체.clean() 호출을 통해 각 필드 Type에 맞춰 유효성 검사\r\n\r\n​ ex) email field가 email 형식인지\r\n\r\n​ `clean()`은 `is_valid()`가 호출되면 내부적으로 수행된다.\r\n\r\n​ **2. Form 객체 내에서**\r\n\r\n​ 필드 이름 별로 Formr객체.clean\\_필드명() 함수가 있다면 호출해서 유효성 검사\r\n\r\n​ Form객체.clean() 함수가 있다면 호출해서 유횽성 검사\r\n\r\n​ # ex)\r\n\r\n```python\r\nimport re\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        field = ['message', 'photo', 'tag_set']\r\n\r\n    def clean_message(self):\r\n        message = self.cleaned_data('message')\r\n        if message:\r\n            message = re.sub(r'[a-zA-z]+','',message)\r\n            #영어 제거\r\n        return message\r\n```\r\n\r\ndrf 시리얼라이저에서는 clean대신 validator\r\n\r\n### Form에서 수행하는 2가지 유효성 검사\r\n\r\n---\r\n\r\n**1. Validator 함수를 통한 유효성 검사**\r\n\r\n값이 원하는 조건에 맞지 않을 때 ValidationError 예외를 발생\r\n\r\n- 리턴 값은 사용되지 않는다\r\n- 인자 하나를 받는다\r\n\r\n**2. Form 클래스 내 clean, clean\\_멤버함수를 통한 유효성 검사 및 값 변경 **\r\n\r\n값이 원하는 조건에 맞지 않을 때 ValidationError 예외를 발생\r\n\r\n- 리턴값을 통해 값 반환\r\n\r\n### 함수형/클래스형 Validator\r\n\r\n---\r\n\r\n#### 함수형\r\n\r\n​ 유효성 검사를 수행할 값 인자를 1개 받은 Callable Object\r\n\r\n#### 클래스형\r\n\r\n​ 클래스의 인스턴스가 Callable Object : \\_\\_call\\_\\_함수 존재\r\n\r\n#### but 빌트인 Validator를 잘 사용하자!\r\n\r\n### 언제 validators를 쓰고, 언제 clean을 사용할까?\r\n\r\n---\r\n\r\n**가급적이면 모든 validators는 모델에 정의하고 ModelForm을 통해 모델의 validators 정보를 가져오기!**\r\n\r\n**clean이 필요할 때는**\r\n\r\n특정 Form에서 1회성 유효성 검사 루틴이 필요할 때\r\n\r\n다수 필드값에 걸쳐서, 유효성 검사가 필요할 때\r\n\r\n필드 값을 변경할 필요가 있을 때 (validator는 값만 체크할 뿐, 값을 변경할 수는 없음)\r\n"},{"excerpt":"은 HTML Form Field들을 파이썬 클래스화 은 Database Field들을 파이썬 클래스화 시킨다 Form  은 과 달리 textfield가 없음 문자열은 그냥 문자열일뿐 ...  이런식으로 사용 ModelForm 을 지정하면 해당 의 field정보를 가져와서  filed를 구성해준다. 과 연결되어있기때문에 모델 세이브도 가능 Form Mode…","fields":{"slug":"/form-modelform/"},"frontmatter":{"date":"April 12, 2022","title":"Django의 Form과 ModelForm","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n`Form`은 **HTML Form Field들을 파이썬 클래스화**\r\n\r\n`Model`은 **Database Field들을 파이썬 클래스화** 시킨다\r\n\r\n## Form\r\n\r\n---\r\n\r\n`Form` 은 `Model`과 달리 textfield가 없음\r\n\r\n문자열은 그냥 문자열일뿐 ...\r\n\r\n`content = forms.CharField(widget=form.Textarea)`\r\n\r\n이런식으로 사용\r\n\r\n## ModelForm\r\n\r\n---\r\n\r\n`Model`을 지정하면 해당 `Model`의 field정보를 가져와서 `Form` filed를 구성해준다.\r\n\r\n`Model`과 연결되어있기때문에 모델 세이브도 가능\r\n\r\n#Form\r\n\r\n```python\r\nfrom django import forms\r\n\r\nclass PostForm(forms.Form):\r\n    title = forms.CharField()\r\n    content = forms.CharField(widget=form.Textarea)\r\n```\r\n\r\n#ModelForm\r\n\r\n```python\r\nfrom django import forms\r\nfrom .models import Post\r\n\r\nclass PostForm(form.ModelForm):\r\n    class Meta:\r\n        model = Post\r\n        fields = '__all__'\r\n        #fields = ['title', 'content']\r\n```\r\n\r\nform의 유효성 검사는 fields에 한해서 검사한다.\r\n\r\n#### View에서 ModelForm 활용\r\n\r\n---\r\n\r\n```python\r\ndef post_new(request):\r\n    if request.method == \"POST\":\r\n        form = PostForm(request.POST, request.FILES)\r\n        #파일은 받지않는다면 request.FILES 없어도 됨\r\n        if form.is_valid():\r\n            post = form.save() #모델폼은 바로 모델save가능\r\n            return redirect(post)\r\n    else:\r\n        form = PostForm()\r\n    return render(request, 'myapp/post_form.html', {'form' : form,})\r\n\r\n```\r\n\r\n#### Model Form save함수의 인자commit\r\n\r\n\\# ex) post 작성시 author 입력은 없애고 싶으나 author이 필수항목일 때\r\n\r\n```python\r\npost = form.save(commit = False)\r\npost.user = request.user\r\n#author입력이 안된 form이 오므로 author를 지정해주고 save\r\npost.save()\r\n```\r\n\r\n**True**가 **default**\r\n\r\n**False**로 준다면 **.save()**를 실행하지않는다.\r\n\r\n​ instance.save() 함수 호출을 지연시키고자 할 때 사용한다. (save하긴해야함)\r\n\r\n​ 모델 인스턴스는 만들어졌으나 실제 db에 모델이 생성되지않음\r\n"},{"excerpt":"플렉스는 한 방향 레이아웃 시스템 그리드는 두 방향 (가로-세로) 레이아웃 시스템  그리드는 플렉스보다 더 복잡한 레이아웃 표현이 가능하다.  이와 같은 구조를 flex로 구현하려면 매우 힘듦...s 그러나 그리드로는 간단하게 구현 가능! 그리드는 어떻게 그리죠? 컨테이너 속성으로 격자를 만들고 아이템 속성으로 격자에 끼워 넣는다 1. 컨테이너 속성으로 …","fields":{"slug":"/grid/"},"frontmatter":{"date":"April 10, 2022","title":"그리드를 어떻게 그리드라","tags":["css"]},"rawMarkdownBody":"\r\n플렉스는 한 방향 레이아웃 시스템\r\n\r\n그리드는 두 방향 (가로-세로) 레이아웃 시스템\r\n\r\n![](./flex-grid.png)\r\n\r\n그리드는 플렉스보다 더 복잡한 레이아웃 표현이 가능하다.\r\n\r\n![](./grid-ex1.png)\r\n\r\n이와 같은 구조를 flex로 구현하려면 매우 힘듦...s\r\n\r\n그러나 그리드로는 간단하게 구현 가능!\r\n\r\n### 그리드는 어떻게 그리죠?\r\n\r\n1. 컨테이너 속성으로 격자를 만들고\r\n2. 아이템 속성으로 격자에 끼워 넣는다\r\n\r\n#### 1. 컨테이너 속성으로 격자 만들기\r\n\r\n```css\r\n.container {\r\n  display: grid;\r\n  grid-template-columns: 300px 300px 300px 300px;\r\n  grid-template-rows: 200px 200px 200px 200px;\r\n}\r\n```\r\n\r\n`grid-template-columns` : 격자의 세로가 몇 개이고 각 격자칸의 크기가 얼마난지 정한다. 위 예시의 경우 세로 4칸이 있고 각 칸은 모두 300px크기이다.\r\n\r\n`grid-template-rows` : 격자의 가로가 몇 개이고 각 격자칸의 크기가 얼마난지 정한다.\r\n\r\n#### fr과 %\r\n\r\n`px`외에도 `fr`, `%`, `em` 등으로 표현할 수 있다.\r\n\r\n`fr` : `%`, `px`등으로 공간이 채워지고 남은 공간을 기준으로 할당한다\r\n\r\n​ 300px 1fr 2fr 이라면 300px만큼 할당하고 남은 공간을 3으로 나눠 1/3과 2/3만큼 나눠 가진다.\r\n\r\n`%`: 남은 공간을 신경쓰지않고 전체 공간을 기준으로 할당한다.\r\n\r\n#### repeat\r\n\r\n`repeat ` 함수를 사용해서 반복적으로 공간을 할당할 수 있다.\r\n\r\n```css\r\n.container{\r\n    display: grid;\r\n    grid-template-columns: repeat(4, 300px)\r\n    grid-template-rows: repeat(4, 200px)\r\n}\r\n```\r\n\r\n#### 2. 아이템 끼워 넣기\r\n\r\n![](./grid-item.png)\r\n\r\n`grid-column` 을 통해 해당 아이템이 차지할 세로 격자칸을 정할 수 있다\r\n\r\n`grid-row` 를 통해 해당 아이템이 차지할 가로 격자칸을 정할 수 있다\r\n\r\n`grid-area`를 사용해 `grid-column` 과 `grid-row`를 동시에 선언할 수 있다.\r\n\r\ngrid-area: r-start / c-start / r-end / c-end\r\n\r\n그러나 나는 나눠서 표현하는게 편함\r\n\r\n반대로 grid-column과 grid-row를 grid-row-start, grid-row-end이런식으로 나눠서 쓸 수 있다.\r\n\r\n#### span\r\n\r\n얼만큼 늘린건지도 쓸 수 있다\r\n\r\n`grid-column : 1/span3;`\r\n\r\n1에서 3개 공간만큼 늘린다는 뜻\r\n\r\n참고 (https://studiomeal.com/archives/533)\r\n"},{"excerpt":"python manage.py shell등을 사용해서 뻥튀기할 모델의 인스턴스를 아무거나 가져온 후  가져온 인스턴스의 pk를 None으로 만든다  그리고 인스턴스를 save 한다면?  짜잔~ 가져온 인스턴스와 내용이 똑같지만 pk는 다른 모델이 생성됩니다~ 물론 for문을 사용해서 한 번에 만들수도있음.","fields":{"slug":"/instance-flex/"},"frontmatter":{"date":"April 10, 2022","title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때","tags":["django"]},"rawMarkdownBody":"\r\npython manage.py shell등을 사용해서\r\n\r\n1. 뻥튀기할 모델의 인스턴스를 아무거나 가져온 후  \r\n   `post = Post.objects.first()`\r\n\r\n2. 가져온 인스턴스의 pk를 None으로 만든다  \r\n   `post.pk = None`\r\n\r\n3. 그리고 인스턴스를 save 한다면?  \r\n   `post.save()`\r\n\r\n짜잔~ 가져온 인스턴스와 내용이 똑같지만 pk는 다른 모델이 생성됩니다~\r\n\r\n물론 for문을 사용해서 한 번에 만들수도있음.\r\n\r\n```python\r\npost_list = list(Post.objects.all())\r\nfor i in range(100):\r\n    post = random.choice(post_list)\r\n    post.pk = None\r\n    post.save()\r\n```\r\n"},{"excerpt":"getabsoluteurl  식으로 사용하던 것을  , 와 같이 사용 가능 모델 클래스에 을 구현한다. 장고 템플릿 태그 주석 : {# #}","fields":{"slug":"/get-absolute-url/"},"frontmatter":{"date":"April 10, 2022","title":"detail url을 간단하게 하고싶다면, get_absolute_url","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n#### get_absolute_url\r\n\r\n---\r\n\r\n`{% url 'blog:post_detail' post.pk %}` 식으로 사용하던 것을\r\n\r\n`redirect(post)` , `{{ post.get_absolute_url }}`와 같이 사용 가능\r\n\r\n모델 클래스에 `get_absolute_url()`을 구현한다.\r\n\r\n```python\r\nfrom django.urls import reverse\r\n\r\nclass Post(models.Model):\r\n    ...\r\n    def get_absolute_url(self):\r\n        return reverse('blog:post_detail', args=[self.pk])\r\n```\r\n\r\n장고 템플릿 태그 주석 : {# #}\r\n"},{"excerpt":"HTTP 상태코드 웹서버는 적절한 상태코드로서 응당해야한다 각 HttpResponse 클래스마다 고유한 status_code가 할당 REST API를 만들 때 유용 # response.py HTTP METHOD별 다양한 상태 코드 GET 일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답 POST 201(Created)…","fields":{"slug":"/http-status-code/"},"frontmatter":{"date":"April 10, 2022","title":"HTTP 상태 코드","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### HTTP 상태코드\r\n\r\n---\r\n\r\n웹서버는 적절한 상태코드로서 응당해야한다\r\n\r\n각 HttpResponse 클래스마다 고유한 status_code가 할당\r\n\r\nREST API를 만들 때 유용\r\n\r\n\\# response.py\r\n\r\n```python\r\nfrom django.http import HttpResponse\r\n\r\ndef test_view(request):\r\n    return HttpResponse(status = 201)\r\n```\r\n\r\n```python\r\nclass HttpResponseRedirect(HttpResponseRedirectBase): #HttpResponse를 상속받은 클래스\r\n    status_code = 302\r\n```\r\n\r\n### HTTP METHOD별 다양한 상태 코드\r\n\r\n---\r\n\r\n#### GET\r\n\r\n일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답\r\n\r\n#### POST\r\n\r\n201(Created) 응답. 새 리소스의 URI는 응답의 로케이션 헤더에\r\n\r\n새 리소스를 만들지 않은 경우, 200응답하고 리소스와 관련된 내용을 응답 본문에 포함. 반환할 결과가 없으면 204(내용없음)을 반환할 수도\r\n\r\n400(잘못된 요청)\r\n\r\n#### PUT\r\n\r\n성공- 200(OK) 204(내용없음)\r\n\r\n실패 - 409(충돌)\r\n\r\n#### DELETE\r\n\r\n성공시 204, 리소스가 없으면 404\r\n\r\n#### 비동기작업\r\n\r\n202(수락됨) - 요청은 수락되었지만 아직 완료되지않음\r\n\r\n비동기 요청의 상태를 반환하는 URI를 로케이션 헤더로 변환\r\n\r\n로케이션 헤더를 통해 비동기작업의 진행상황을 알 수 있음\r\n"},{"excerpt":"1. values_list 필드값을 인자로 넣어 생성된 모델 인스턴스들의 해당 필드값을 나열한다.   원래 튜플 형태로 출력되는데 flat = True 를 사용해서 튜플을 없앨 수 있다.  2. _ 이전 출력 결과를 다음 줄에서 _를 사용해 표현할 수 있다.","fields":{"slug":"/queryset/"},"frontmatter":{"date":"April 10, 2022","title":"작성중 : 쓸만해보이는 쿼리셋팁","tags":["django","askcompany"]},"rawMarkdownBody":"\r\n### 1. values_list\r\n\r\n필드값을 인자로 넣어 생성된 모델 인스턴스들의 해당 필드값을 나열한다.\r\n\r\n`Post.objects.all().values_list('created_at__year')`\r\n\r\n`Post.objects.all().values_list('created_at__year', flat = True)`\r\n\r\n원래 튜플 형태로 출력되는데 **flat = True** 를 사용해서 튜플을 없앨 수 있다.\r\n\r\n####\r\n\r\n### 2. \\_\r\n\r\n이전 출력 결과를 다음 줄에서 \\_를 사용해 표현할 수 있다.\r\n"},{"excerpt":"view는 무조건 HttpResponse객체를 반환해야한다. CBV Class Based View : View 함수를 만들어주는 클래스  클래스 함수를 통해, View 함수를 생성 상속을 통해 여러 기능들을 믹스인 CBV API Base views , ,  Generic display views ​ , , Generic date views Generic …","fields":{"slug":"/CBV-api/"},"frontmatter":{"date":"April 10, 2022","title":"CBV api 사용해보기","tags":["django","python"]},"rawMarkdownBody":"\r\nview는 무조건 HttpResponse객체를 반환해야한다.\r\n\r\n### CBV\r\n\r\n---\r\n\r\n**Class Based View** : View 함수를 만들어주는 클래스\r\n\r\n- `as_view()` 클래스 함수를 통해, View 함수를 생성\r\n\r\n- 상속을 통해 여러 기능들을 믹스인\r\n\r\n#### CBV API\r\n\r\n---\r\n\r\n- **Base views**\r\n\r\n  `View`, `TemplateView`, `RedirectView`\r\n\r\n- **Generic display views**\r\n\r\n​ `DetailView`, `ListView`,\r\n\r\n- **Generic date views**\r\n\r\n- **Generic editing views**\r\n\r\n  `FormView`, `CreateView`, `UpdateView`, `DeleteView`\r\n\r\n### CBV api 활용 예시(Generic display views)\r\n\r\n---\r\n\r\n```python\r\nclass DetailView:\r\n    def __init__(self, model):\r\n        self.model = model\r\n\r\n    def get_object(self, *args, **kwargs):\r\n        return get_object_or_404(self.model, id = kwargs['id']) #get_object_or_404를 통해 detail을 보고자하는 모델 인스턴스를 찾아 반환한다.\r\n\r\n    def get_template_name(self):\r\n        return '{}/{}_detail.html'.format(\r\n        \tself.model._meta.app_label, #앱이름\r\n            self.model._meta.model_name #모델명\r\n        )\r\n        #ex) instagram앱의 post모델을 가져올경우instagram/post_detail.html 을 반환해준다\r\n\r\n    def dispatch(self, request, *args, **kwargs):\r\n        object = self.get_object(*args, **kwargs)\r\n        return render(request, self.get_template_name(),{\r\n            self.model._meta.model_name: object,\r\n        })# post: 찾고자하는 post객체\r\n\r\n    @classmethod\r\n    def as_view(cls, model):#cls 는 알아서 들어옴\r\n        def view(request, *args, **kwargs):\r\n            self = cls(model)\r\n            return self.dispatch(request, *args, **kwargs)\r\n        return view\r\n```\r\n\r\n#### 1. SingleObjectMixin 클래스의 필드\r\n\r\n**SingleObjectMixin** : 제네릭뷰의 리스트뷰나 디테일뷰에 상속되는 클래스\r\n\r\n`model` : 어떤 모델 객체를 사용할 것 인지. 모델 객체를 통해 해당 모델이 소속된 앱이름도 알 수 있다. 나중에 app/model_detail.html등 template를 자동으로 불러오는데 사용된다.\r\n\r\n`queryset ` : 어떤 쿼리셋을 적용할 것인지. 리스트 해줄 모델 인스턴스들을 정할 수 있다.\r\n\r\n​ 쿼리셋이 없다면 default로 입력된 model명을 사용해서 `model.objects.all()`을 가져온다.\r\n\r\n​ 해당 클래스의 함수를 보면 `self.model._default_manager.all()`이라 되어있는데 `_default_manager`이 `objects`이다.\r\n\r\n물론 쿼리셋을 바꿀수도있다. ex) `queryset = Post.objects.filter(is_public = True)`\r\n\r\n```python\r\nclass PostDetailView(DetailView):\r\n    model = Post\r\n\r\n    def get_queryset(self): #DetailView에 있는 get_queryset함수를 오버라이딩한다.\r\n        qs = super().get_queryset() #defual qs 오버라이딩\r\n        if not self.request.user.is_authenticated:\r\n\t        qs = qs.filter(is_public=True)\r\n        return qs\r\n```\r\n\r\n`pk_url_kwarg` : default값은 pk\r\n\r\n​ url에서 `<int:id>` 형태로 받는 인자를 나타낸다. 예시와 같이 id의 경우 `pk_url_kwarg = 'id' `로 바꿔준다.\r\n\r\n`context_object_name` : render등으로 {'post' : post} 식으로 넘겨줄때 key이름을 정함. default로 `모델명`과 `'object'` 사용 가능\r\n\r\n#### 2. ListView\r\n\r\n---\r\n\r\n1개의 모델에 대한 List 템플릿 처리  \r\n모델명소문자\\_list 이름의 쿼리셋을 템플릿에 전달(object_list도 같이 전달해준다)  \r\n페이징 처리 지원 가능\r\n\r\n페이징 예시\r\n\r\n```python\r\nListView.as_view(model=Post, paginate_by = 10)\r\n```\r\n\r\n필드인 `page_obj`를 통해 현재 페이지를 확인할 수 있다\r\n`<Page 3 of 11>` 로 표기됨\r\n\r\ndjango-bootstrap4를 설치해서 꾸미기가능\r\n\r\n```html\r\n{% load bootstrap4%} {% bootstrap_pagination page_obj size = \"small\"\r\njustify_content = \"center\" %}\r\n```\r\n\r\n_view.py_\r\n\r\n```python\r\nfrom django.view.generic import ListView\r\nfrom shop.models import Item\r\n\r\nitem_list = ListView.as_view(model=Item)\r\n```\r\n\r\n_urls.py_\r\n\r\n```python\r\nfrom django.urls import path\r\n\r\nurlpatterns = [\r\n    path('items/', item_list, name='item_list'),\r\n]\r\n```\r\n\r\n단순 리스트 기능만 제공. 검색 기능등 다른 기능은 직접 추가해야함\r\n\r\n#### 3. DetailView\r\n\r\n---\r\n\r\nviews.py\r\n\r\n```py\r\nfrom django.views.generic import DetailView\r\n\r\npost_detail = DetailView.as_view(model = Post, pk_url_kwarg = 'id')\r\n\r\n#pk_url_kwarg는 urls.py에서 적은 url에 들어갈 인자이다.\r\n#만약 urls.py에 path('post/<int:pk>/',post_detail)\r\n#이라고 적었다면 pk_url_kwarg는 생략 가능하다\r\n#post_detail = DetailView.as_view(model = Post)\r\n```\r\n\r\nurls.py\r\n\r\n```python\r\nurlpatterns = [\r\n    path('post/<int:id>/', post_detail)\r\n]\r\n\r\n```\r\n\r\n상속을 통한 CBV 속성정리\r\n\r\n```python\r\nclass PostDetailView(DetailView):\r\n    model = Post\r\n    pk_url_kwarg = 'id'\r\n\r\npost_detail = PostDetailView.as_view()\r\n```\r\n\r\n#### 4. RedirectView\r\n\r\n---\r\n\r\n```python\r\nurlpatterns = [\r\n    path('', RedirectView.as_view(url = '/instagram/'))\r\n]\r\n# url 주소가 서버/instagram/인 곳으로 리다이렉트해줌\r\n\r\nurlpatterns = [\r\n    path('', RedirectView.as_view(pattern_name='instagram:post_list'))\r\n]\r\n\r\n# url path를 적을 때 설정한 name을 사용해서 이동시킴 앱:name\r\n```\r\n"},{"excerpt":"장식자(Decorators) 어떤 함수를 감싸는 (Wrapping) 함수 django.contrib.auth.decorators  : 로그아웃일 때 login_url로 redirect ex 1) ex 2)  : 지정 함수가 False를 반환하면 login_url로 redirect  : 지정 퍼미션이 없을 때 login_url로 redirect django…","fields":{"slug":"/view-decorators/"},"frontmatter":{"date":"April 10, 2022","title":"decorator를 사용해서 Django view 꾸며보기","tags":["django","python"]},"rawMarkdownBody":"\r\n### 장식자(Decorators)\r\n\r\n---\r\n\r\n어떤 함수를 감싸는 (Wrapping) 함수\r\n\r\n#### django.contrib.auth.decorators\r\n\r\n---\r\n\r\n`login_required ` : 로그아웃일 때 login_url로 redirect\r\n\r\nex 1)\r\n\r\n```python\r\nfrom django.contrib.auth.decorators import login_required\r\n\r\n@login_required\r\ndef protected_view(request):\r\n    return render(request, 'myapp/secret.html')\r\n```\r\n\r\nex 2)\r\n\r\n```python\r\nfrom django.contrib.auth.decorators import login_required\r\n\r\ndef protected_view(request):\r\n    return render(request, 'myapp/secret.html')\r\n\r\nprotected_view = loginrequired(protected_view)\r\n```\r\n\r\n`user_passes_test` : 지정 함수가 False를 반환하면 login_url로 redirect\r\n\r\n`permission_required` : 지정 퍼미션이 없을 때 login_url로 redirect\r\n\r\n#### django.views.decorator.http\r\n\r\n---\r\n\r\n`required_http_methods` : 데코레이터에 인자로 넣어준 메소드만 사용가능함\r\n\r\n`required_GET`\r\n\r\n`required_POST`\r\n\r\n`require_safe` : HEAD 요청이나 GET요청 허용\r\n\r\n### @method_decorator()\r\n\r\n---\r\n\r\n`@method_decorator()`를 통해 특정 메소드에만 데코레이터를 지정할 수 있다.\r\n\r\nex) `@method_decorator(login_required, name ='dispatch')`\r\n\r\n해당 함수 바로 위에 쓴다면 name인자 생략 가능\r\n\r\n근데 번거로운 방법이라 잘 사용안하는듯?\r\n\r\n```python\r\nclass PostListView(LoginRequiredMixin, ListView):\r\n    ...\r\n```\r\n\r\n이런 방법도 있음\r\n"},{"excerpt":"JSON 응답뷰 만들기 router를 사용해 두 개의 url생성 urls.py +HTTPie  JSON 직렬화 모든 프로그래밍 언어의 통신에서 데이터는 필히 문자열로 표현되어야함. 송신자 : 객체를 문자열로 반환하여 데이터 전송 - 직렬화 수신자: 수신한 문자열을 다시 객체로 변환하여 활용 - 비직렬화 쿼리셋타입의 객체 를 json으로 직렬화한다면? 에러…","fields":{"slug":"/json/"},"frontmatter":{"date":"April 07, 2022","title":"작성중 : json 응답뷰 만들기","tags":["django","DRF"]},"rawMarkdownBody":"\r\n### JSON 응답뷰 만들기\r\n\r\n---\r\n\r\n```python\r\nclass PostViewSet(ModelViewSet):\r\n    queryset = Post.objects.all() # 다룰 데이터의 범위\r\n    serializer_class = PostSerializer\r\n```\r\n\r\nrouter를 사용해 두 개의 url생성\r\n\r\n> urls.py\r\n\r\n```python\r\nfrom rest_framework.routers import DefaultRouter\r\nfrom . import views\r\n\r\nrouter = DefaultRouter()\r\nrouter.register('post', views.PostViewSet) #2개의 URL을 만들어줌\r\n#router.urls에 리스트 형태로 2개의 패턴이 생김 url pattern list\r\n\r\nurlpatterns = [\r\n    path('', include(router.urls)),\r\n]\r\n```\r\n\r\n+HTTPie\r\n\r\n`pip install httpie`\r\n\r\n### JSON 직렬화\r\n\r\n---\r\n\r\n모든 프로그래밍 언어의 통신에서 데이터는 필히 문자열로 표현되어야함.\r\n\r\n송신자 : 객체를 문자열로 반환하여 데이터 전송 - 직렬화\r\n\r\n수신자: 수신한 문자열을 다시 객체로 변환하여 활용 - 비직렬화\r\n\r\n쿼리셋타입의 객체 를 json으로 직렬화한다면?\r\n\r\n에러 - 룰추가 필요\r\n\r\nlist/dick/set comprehension\r\n\r\n1. 직접 변환\r\n\r\n```python\r\ndata =[\r\n    {'id':post.id, 'title':post.title, 'content':post.content}\r\n    for post in Post.objects.all()\r\n]\r\n\r\njson.dumps(data, ensure_ascii=False)\r\n```\r\n\r\n번거로움\r\n\r\n2. 직접변환 룰 지정\r\n"},{"excerpt":"큐마다 다른 폴리시 - 멀티레벨 큐 어떤 프로세스가 cpu바운드인지 io바운드인지 알 수 있? 그냥 프로세스만 받아서는 알기 어려움 멀티레벨큐 : 사용어렵 잘 설계해야함 멀티레벨 피드백 큐 여러 개의 큐를 두고 각각의 큐에 대해서 서로 다른 스케줄링 알고리즘을 가져감 프로세스가 여러가지 큐를 옮겨 다닐 수 있음 어떻게 옮겨가는가? 사용자가 결정해야함 피드…","fields":{"slug":"/6-2/"},"frontmatter":{"date":"April 06, 2022","title":"os 6-2","tags":["OS"]},"rawMarkdownBody":"\r\n큐마다 다른 폴리시 - 멀티레벨 큐\r\n\r\n\r\n\r\n어떤 프로세스가 cpu바운드인지 io바운드인지 알 수 있?\r\n\r\n그냥 프로세스만 받아서는 알기 어려움\r\n\r\n\r\n\r\n멀티레벨큐 : 사용어렵 잘 설계해야함\r\n\r\n## 멀티레벨 피드백 큐\r\n\r\n여러 개의 큐를 두고 각각의 큐에 대해서 서로 다른 스케줄링 알고리즘을 가져감\r\n\r\n프로세스가 여러가지 큐를 옮겨 다닐 수 있음\r\n\r\n\r\n\r\n어떻게 옮겨가는가? 사용자가 결정해야함\r\n\r\n피드백 방법에 근거해서 결정함. 이전 스케줄링의 결과가 다음 큐를 결정한다\r\n\r\n* 한 프로세스가 특정 큐에 종속되는게아니라 계속 옮겨다닐 수 있음\r\n\r\nex) 네개큐. 라운드로빈. 타임퀀텀만 다르게가져감\r\n\r\n타임퀀텀이 짧은건 I/O 바운드 어플리케이션에게 유리함. 긴건 cpu 바운드\r\n\r\n- 처음에는 다 Q0으로 들어감(프로세스가 어떤 애인지 모름)\r\n\r\n- 만약 프로세스가 주어진 타임 퀀텀(타임 슬라이스)을 다 쓴다면 프라이어리티를 하나 낮춘다 : 타임퀀텀이 부족해서 끝남 -> Q1으로 내려줌.\r\n- 블로킹되어서 끝났다면. 아이오요청을하면서 기다려야해서 waiting queue로 내려옴. 반대로 increase. 프라이어리티를 높인다(아이오바운드일 확률)\r\n\r\n동일한 나이스 밸류를 가지면(동일한 타임퀀텀)\r\n\r\n\r\n\r\n##  Linux Scheduling\r\n\r\n### Completely Fair Scheduler (CFS)\r\n\r\n큐레벨 말고도 스케줄링 클래스라는게 존재\r\n\r\n#### Scheduling classes\r\n\r\n두 개의 클래스가 존재\r\n\r\n* default\r\n* real-time : 주어진 시간내에 반드시 그 일을 끝내야하는\r\n\r\nreal-time이 default보다 큰 우선순위를 갖는다\r\n\r\n**quantum based(고정된 시간)가 아닌 proportion(각각의 프로세스에게 전체시간중에 얼만큼을 할당해줄지. 비율을 어떻게 할당해줄지)**\r\n\r\n*  Variable quantum size\r\n\r\n\r\n\r\n#### nice value\r\n\r\ndefault class에서 -20 + 19\r\n\r\n낮은 숫자가 높은 우선순위\r\n\r\n> -20은 시스템 앱처럼 굉장히 중요한 애들이 가져가고\r\n>\r\n> 19는 cpu bound인 애들 등이 가져간다\r\n\r\n\r\n\r\n#### virtul run time (상대적인 실행 시간)\r\n\r\n* 시스템은 가장 낮은 virtual run time을 선택\r\n\r\n> 동일한 nice value를 가지는 두 개의 프로세스 존재(p1, p2)\r\n>\r\n> nice value가 같으면 할당받을 수 있는 time quantum도 동일(20ms라고 가정)\r\n>\r\n> p1 (20) - p2 (20) - p1(20)\r\n>\r\n> 현재 p1(40), p2(20)만큼 돌았음\r\n>\r\n> 이 때 둘의 nice value가 같기 때문에 p2선택\r\n\r\n​\t\t\r\n\r\n| nice value | 우선순위 | weight |    할당된 시간     | scale factor |  virtul run time   |\r\n| :--------: | :------: | :----: | :----------------: | :----------: | :----------------: |\r\n|     0      |   높음   |   3    | 45(더 많이 돌게함) |      1       | 40(더 작은걸 실행) |\r\n|     5      |   낮음   |   1    |         15         |      3       |         60         |\r\n\r\n오래 수행되는 애들은(ex. cpu bound) virtul run time을 증가시켜서 선택 가능성을 감소시킨다\r\n\r\nfor starv방지. 공평한 스케줄링\r\n\r\n\r\n\r\n> 서로 다른 nice value를 가지는 두 개의 프로세스 존재\r\n>\r\n> p1 weight : p2 weight = 3:1\r\n>\r\n> time quantum은 동일 (nice value가 달라도 time quantum은 같을 수 있다)\r\n>\r\n> p1 (20) - p2 (20) - p1(20)\r\n>\r\n> * 총 60의 시간 중 weight에 의해 계산된 적정 cpu time 비율 (p1-45, p2-15)\r\n> * 실제 차지한 cpu time ( p1(40), p2(20) )\r\n>\r\n> \r\n>\r\n> scale factor (weight의 역수) : **priority가 높으면 scale factor도 높여줌**\r\n>\r\n> p1 scale factor = 1\r\n>\r\n> p2 scale factor = 3\r\n>\r\n> virtual runtime = 실제 cpu time x scalefactor\r\n>\r\n> p1의 virtual runtime은 40 * 1 = 40\r\n>\r\n> p2의 virtual runtime은 20 * 3 = 60\r\n>\r\n> virtual runtime이 적은 p1을 고른다\r\n\r\n\r\n\r\n* default의 nice value는 (-20~19)\r\n* real-time 까지 합쳐서 보면 -20 = 100, 19 = 139\r\n"},{"excerpt":"Django admin admin 등록 방법 (1) 기본 ModelAdmin으로 동작 admin 등록 방법 (2) 지정한 ModelAdmin으로 동작 admin 등록 방법 (3) python wrapping 파이썬의 장식자 문법 감싼 대상의 기능을 변경할 수 있다. admin에서 표기되는 모델 객체명 바꾸기 admin에서 모델 객체의 이름은 모델명 obj…","fields":{"slug":"/django-admin/"},"frontmatter":{"date":"April 05, 2022","title":"django ORM","tags":["django"]},"rawMarkdownBody":"\r\n## Django admin\r\n\r\n---\r\n\r\n#### admin 등록 방법 (1)\r\n\r\n---\r\n\r\n```python\r\nadmin.site.register(모델명)\r\n```\r\n\r\n기본 ModelAdmin으로 동작\r\n\r\n#### admin 등록 방법 (2)\r\n\r\n---\r\n\r\n```py\r\nclass ModelAdmin(admin.ModelAdmin):\r\n    pass\r\n\r\nadmin.site.register(모델명, ModelAdmin)\r\n```\r\n\r\n지정한 ModelAdmin으로 동작\r\n\r\n#### admin 등록 방법 (3)\r\n\r\n---\r\n\r\n```py\r\n@admin.register(모델명)\r\n\r\nclass ModelAdmin(admin.ModelAdmin):\r\n    pass\r\n```\r\n\r\n**python wrapping**\r\n\r\n파이썬의 장식자 문법\r\n\r\n감싼 대상의 기능을 변경할 수 있다.\r\n\r\n### admin에서 표기되는 모델 객체명 바꾸기\r\n\r\n---\r\n\r\n**admin**에서 모델 객체의 이름은 **모델명 object (n)**의 형식으로 나온다.\r\n\r\nex) Post object (1)\r\n\r\n이 이름을 바꾸고 싶다면 model선언에서` def __str__(Self):`를 사용한다.\r\n\r\n##### `def __str__(Self):`\r\n\r\n어떤 객체에 대한 문자열 표현을 할 수 있다.\r\n\r\nex)\r\n\r\n```py\r\nclass Post(models.Model):\r\n    message = models.TextField()\r\n    created_at = models.DateTimeField(auto_now_add=True)\r\n    updated_at = models.DateTimeField(auto_now=True)\r\n\r\n    def __str__(self):\r\n        return f\"({self.id})번째 포스트\"\r\n    \t#return \"({})번째 포스트\".format(self.id)\r\n        #return self.message\r\n```\r\n\r\n### list_display 속성 정의\r\n\r\n---\r\n\r\nadmin 테이블에서` list_display`에서 적은 속성명을 표기할 수 있다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message']\r\n```\r\n\r\n#### 1) 모델 필드 외 속성 추가하기\r\n\r\n꼭 모델 필드가 아니더라도 list_display에 추가할 수 있다.\r\n\r\n> Post의 메세지 길이도 list_play속성에 넣고싶다면?\r\n\r\n```python\r\nclass Post(models.Model):\r\n    message = models.TextField()\r\n    created_at = models.DateTimeField(auto_now_add=True)\r\n    updated_at = models.DateTimeField(auto_now=True)\r\n\r\n    def __str__(self):\r\n        return f\"({self.id})번째 포스트\"\r\n    \t#return \"({})번째 포스트\".format(self.id)\r\n    \t#return self.message\r\n\r\n    def message_length(self):\r\n    \treturn len(self.message)\r\n```\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n```\r\n\r\n만약 `message_length`가 자주 쓰이는 로직이라면 모델단에 정의하는게 좋으나 어드민에서만 사용한다면 어드민에서 정의해도 상관없다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n\r\n  def message_length(self, post): #post객체는 admin이 알아서 넘겨줌\r\n        return f\"{len(post.message)} 글자\"\r\n```\r\n\r\n#### 2) list_display_link\r\n\r\n해당 list_display 필드를 누르면 model 객체 상세로 이동한다.\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n```\r\n\r\n#### 3) search_fields\r\n\r\nadmin 테이블에서 검색 가능\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n  search_fields = ['message']\r\n```\r\n\r\n#### 4) list_filter\r\n\r\nadmin 메인에서 필터 기능 제공\r\n\r\n```python\r\nfrom django.contrib import admin\r\n\r\n@admin.register(모델명)\r\nclass ModelAdmin(admin.ModelAdmin):\r\n  list_display = ['id', 'message','message_length']\r\n  list_display_links = ['message']\r\n  search_fields = ['message']\r\n  list_filter - ['created_at']\r\n```\r\n"},{"excerpt":"1. Static과 Media란? - Static 파일 ​ 개발 리소스로서의 정적인 파일(css, js, image등) ​ 앱/프로젝트 단위로 저장&서빙 - Media 파일 ​ FileField/ImageField를 통해 저장한 모든 파일 ​ DB필드에는 저장 경로를 저장하며 파일은 파일 스토리지에 저장 ​ 프로젝트 단위로 저장&서빙 static 파일은 …","fields":{"slug":"/static-media/"},"frontmatter":{"date":"April 05, 2022","title":"django의 Static & Media 파일","tags":["django"]},"rawMarkdownBody":"\r\n### 1. Static과 Media란?\r\n\r\n---\r\n\r\n#### - Static 파일\r\n\r\n​ 개발 리소스로서의 정적인 파일(css, js, image등)\r\n\r\n​ 앱/프로젝트 단위로 저장&서빙\r\n\r\n#### - Media 파일\r\n\r\n​ FileField/ImageField를 통해 저장한 모든 파일\r\n\r\n​ DB필드에는 저장 경로를 저장하며 파일은 파일 스토리지에 저장\r\n\r\n​ 프로젝트 단위로 저장&서빙\r\n\r\n> static 파일은 배포 전 개발에 필요한 정적 파일들이고 Media 파일은 배포 후 사용자가 웹에 저장한 파일들이다 아마도\r\n\r\n`pip install pillow` : 이미지 라이브러리\r\n\r\n이미지 필드를 사용하려면 `pillow`를 다운로드해야함\r\n\r\n```python\r\nclass Post(models.Model):\r\n    image = models.ImageField()\r\n```\r\n\r\n### 2. Media 파일 처리 순서\r\n\r\n---\r\n\r\n1. HttpRequest.FILES를 통해 파일이 전달\r\n\r\n2. 뷰 로직이나 폼 로직을 통해, 유효성 검증 수행\r\n\r\n3. FileField/ImageField 필드에 \"경로(문자열)\"를 저장\r\n\r\n4. settings.MEDIA_ROOT 경로에 파일이 저장됨\r\n\r\n### 3. Media 파일을 위한 settings\r\n\r\n---\r\n\r\n##### `MEDIA_URL`\r\n\r\n각 media 파일에 대한 URL Prefix\r\n\r\n필드명.url 속성에 의해서 참조되는 설정\r\n\r\n##### `MEDIA_ROOT `\r\n\r\n파일 필드를 통한 저장시에 실제 파일을 저장할 ROOT 경로\r\n\r\n```python\r\nMEDIA_URL = \"/media/\"\r\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\r\n```\r\n\r\n+`BASE_DIR` ?\r\n\r\n`seetings.py`에 선언되어있음.\r\n\r\n`BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))`\r\n\r\n현재 파일(settings.py)의 절대경로의 부모의 부모 : 워킹디렉토리, 장고 프로젝트의 루트를 가리킴\r\n\r\n`MEDIA_ROOT = os.path.join(BASE_DIR, '..', 'public', 'media')`\r\n\r\n이렇게 하면 워킹 디렉토리의 부모 dir에서 public이라는 폴더를 생성하고 그 안에 media폴더를 만들겠다는 의미\r\n\r\n`MEDIA_ROOT` 설정을 안하면 디폴트로 워킹디렉토리 바로 아래에 이미지파일들이 쌓인다.\r\n\r\n### 4. urls.py에 등록\r\n\r\n---\r\n\r\nurls.py\r\n\r\n```python\r\nfrom django.conf.urls.static import static\r\n\r\nif settings.DEBUG: #안해도 되긴하는데 배포시에는 접근이 안되게?\r\n    urlpatterns += static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)\r\n```\r\n\r\n### 5. Image 호출\r\n\r\n---\r\n\r\n이미지 객체에는 url이라는 속성이 있어 `img.url`을 통해 해당 이미지의 url을 가져올 수 있다.\r\n\r\n이미지를 띄우고 싶을 때, `<img src = \"{img.url}\"/>`로 불러온다면\r\n\r\n장고 보안에 의해 이미지가 안나타나고 <img ... /> 문자열 그 자체로 나타난다.\r\n\r\n이미지를 나타내고 싶을 때는 `mark_safe()`를 사용한다.\r\n\r\n```python\r\nclass PostAdmin(admin.ModelAdmin):\r\n    def photo_tag(self,post):\r\n        if post.photo:\r\n            return mark_safe(f'<img src = \"{post.photo.url}\"/>')\r\n        return None\r\n```\r\n\r\n### 6. upload_to\r\n\r\n만약 서비스 크기가 커진다면 쌓이는 이미지 파일또한 많아진다.\r\n\r\n이미지 파일이 많아질경우 파일들이 저장되는 위치를 폴더별로 나누려면 `upload_to`를 사용한다.\r\n\r\nex)\r\n\r\n`photo = models.ImageField(blank = True, upload_to ='board/post/%Y/%m/%d')`\r\n\r\n> 이미지 파일들이 작성한 year, month, day에 따라 분류된다.\r\n\r\n문자열이 아니라 함수로도 설정할 수 있다.\r\n\r\n- 문자열로 지정 : 파일을 저장할 중간 디렉토리 경로로서 활용\r\n\r\n- 함수로 지정 : 중간 디렉토리 경로 및 파일명까지 결정 가능\r\n\r\n### 6. FileField\r\n\r\n---\r\n\r\n**File Field**는 **File Storage API**를 통해 파일을 저장\r\n\r\n해당 필드를 옵션 필드를 두고자 할 경우 null이 아닌 `blank = True`를 사용한다.\r\n"},{"excerpt":"Minimax Algorithm max와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다. max(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다. 위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때 max(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다 min(파란색)단인 1 depth…","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"date":"April 04, 2022","title":"Minimax 알고리즘 & alpha-beta 가지치기","tags":["ai","inha"]},"rawMarkdownBody":"\r\n### Minimax Algorithm\r\n\r\n\r\n---\r\n\r\nmax와 min을 번갈아가며 각 state에서 최선의 선택지를 고른다.\r\n\r\nmax(빨간색)단에서는 최대값을 올려보내고 min(파란색)단에서는 최소값을 올려보낸다.\r\n\r\n<img src =\"http://thumbnail.egloos.net/600x0/http://pds26.egloos.com/pds/201212/11/23/d0091423_50c73a317c0ed.png\"/>\r\n\r\n위 사진의 경우 차례대로 0,1,2,3 depth라고 할 때\r\n\r\nmax(빨간색)단인 2 depth에서 1과 8중 최대값인 8이 올라간다\r\n\r\nmin(파란색)단인 1 depth에서는 8과 7중 최소값인 7이 올란간다\r\n\r\n이것을 Minimax Algorithm이라고 하며, 가장 아래 depth부터 올라간다.(depth-first searching)\r\n\r\n### alpha-beta 가지치기\r\n\r\n---\r\n\r\nMinimax Algorithm을 할 때, searching할 필요가 없는 루트는 제거하는 방법이다.\r\n\r\n**Alpha**는 max단에서 정해지는 값이고, **Beta**는 min단에서 정해지는 변수이다.\r\n\r\n**Alpha** 는 이전(상위) 상태들 중에서 AI에게 가장 유리한 상태의 점수, **Beta** 는 이전(상위) 상태들 중에서 상대방에게 가장 유리한 상태의 점수이다.\r\n\r\n**Alpha cut-off** 는 자신이 상대방보다 불리하여, 자신이 그 경우를 선택하지 않을 때 불필요한 연산을 잘라내는 것이고, **Beta cut-off** 는 자신이 상대방보다 유리하여, 상대방이 그 경우를 선택하지 않을 확률이 높을 때 불필요한 연산을 잘라내는 것이다.\r\n\r\n#### 1. Alpha cut-off\r\n\r\n<hr>\r\n\r\n(1)\r\n\r\n<img src =\"http://pds25.egloos.com/pds/201212/12/23/d0091423_50c74f11d7ffe.png\"/>\r\n\r\n각각의 노드에 써있는 순서쌍이 (Alpha, Beta)라고 할 때\r\n\r\n재 1번으로 표시된 노드의 왼쪽 자식의 탐색을 끝냈고, 이제 2번 방향으로 진행해서 1번 -> 2번 -> 3번 -> 4번 노드 순으로 함수를 진행하고 있다고 생각해보자. 알파-베타 함수의 정의에 따라 부모 노드의 alpha, beta 값이 그대로 내려온다.\r\n\r\n위의 예에 대해 설명을 더 하자면, 1번 노드의 왼쪽 자식의 탐색을 끝내고 1번 노드의 알파 값이 5로 변경이 되었다. 이는, 1번 노드에서 현재까지 탐색된 경로들 중 최선의 경로를 선택해서 얻을 수 있는 최대값은 5라는 의미이다. 이제 2번 노드로 함수를 진행할 때, 1번 노드의 왼쪽자식으로부터 얻은 alpha 값을 넘겨주어 진행한다.\r\n3번, 4번 노드로 갈 때도 마찬가지.\r\n\r\n(2)\r\n\r\n<img src =\"http://pds27.egloos.com/pds/201212/12/23/d0091423_50c7501f5a0f1.png\"/>\r\n\r\n이제 5, 6, 7, 8번 노드 순으로 계속 진행한다.\r\n우선, 5번 노드의 하위 두 노드의 상태함수 값의 최소값은 4이므로 5번 노드의 베타값이 갱신이 되었다. 6번 노드의 알파값은 5이고, 5번 노드로부터 얻은 값 4와 비교해봤을 때 5가 더 크므로 6번 노드의 알파값은 변함없다. 7번 노드의 베타값은 6번 노드의 알파값인 5로 갱신되고, 이 때 alpha >= beta 가 되므로 alpha cut-off가 일어난다.\r\n\r\nalpha cut-off는 쉽게 말해서 **\"현재의 경로는 우리가 이미 아까 구해논 최적의 경로 값과 비교했을 때 상대방에게 더 유리한 경로이다. 그렇다면 현재의 경로를 애초에 택하지 않고 다른 경로를 택하면 되므로, 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"** 라는 논리이다.\r\n\r\n그림에서는 빨간색 플레이어가 8번 노드에서 왼쪽 자식으로 수를 두게 되면 최소 5의 상태함수값을 얻고, 오른쪽 자식으로 수를 두게 되면 상대방이 최선의 수를 둘 경우 4(혹은 그 이하 - 아직 나머지 자식들에 대한 탐색이 끝나지 않았으므로 모르는 것이다)의 상태함수값을 얻게 되어, 왼쪽 자식으로 수를 두는 것이 더 낫다. 따라서 더이상 오른쪽 자식의 남은 자식들에 대해 탐색할 필요가 없는 것이다.\r\n\r\n#### 2. beta cut-off\r\n\r\n---\r\n\r\n(1)\r\n\r\n<img src=\"http://pds27.egloos.com/pds/201212/12/23/d0091423_50c753d3207e2.png\"/>\r\n\r\n1 -> 2 -> 3번 노드 순으로 진행한다.\r\n1번에서 13, 16 중에 작은걸 베타 값으로 갱신하여 13을 리턴하였고,\r\n2번 노드에서 알파 값을 13으로 바꾼다. 여기서 alpha >= beta가 되므로 beta cut-off가 일어난다.\r\n\r\nbeta cut-off는 쉽게 말하면 **\"현재의 경로는 우리가 아까 구해논 상대방 입장에서의 최적의 경로 값과 비교했을 때 내가 더 유리한 경로이다. 따라서 만일 상대가 항상 최선의 수를 택한다면, 현재의 경로를 택하진 않을 것이다(만약 상대가 현재의 경로를 택해 준다면 내가 유리해지니까 땡큐고). 따라서 우리도 더 이상 현재의 경로에 대해 탐색을 진행할 필요가 없다\"** 라는 논리이다.\r\n\r\n파란색 플레이어가 그림의 3번 노드에서 왼쪽 자식으로 진행하게 되면 7 이하의 상태함수값을 얻게 되고, 오른쪽 자식으로 진행하게 되면 최악의 경우 적어도 13의 상태함수 값을 얻게 된다. 따라서 파란색 플레이어 입장에서는 왼쪽으로 진행하는 편이 더 나은 것이고, 더 이상 나머지를 탐색할 필요성이 없어지는 것이다.\r\n\r\n#### + 예제\r\n\r\n<img src =\"https://t1.daumcdn.net/cfile/tistory/998EA7425AB214BD16\"/>\r\n\r\nsearching은 아래부터 시작한다. i부터 차례대로 depth-first searching을 한다고 가정한다.\r\n\r\nj가 4이므로 max단의 e에는 4이상의 숫자가 들어가게된다.\r\n\r\n1. 만약 k가 4보다 작다면?\r\n\r\n   max단에서 k보다 큰 j를 선택하므로 k를 선택하지않는다.\r\n\r\n2) 만약 k가 4이상이라면?\r\n\r\n   max단의 e가 k를 선택하게된다. 그러나 d의 값이 e(=k)의 값보다 작은 2이므로 상위단인 b에서 e가 아닌 d를 선택하게되므로 똑같이 k로 갈 일이 없다.\r\n\r\n**따라서 e -> k는 가지치기를 하게된다**\r\n\r\n(참고 - http://musicdiary.egloos.com/v/4274653)\r\n"},{"excerpt":"작성중 1. RESTful API의 몇 가지 디자인 원칙 리소스(모델등)를 중심으로 디자인 클라이언트에서 엑세스 할 수 있는 모든 종류의 개체/ 서비스가 리소스에 포함 리소스마다 해당 리소스를 고유하게 식별하는 식별자 존재 ex)  요청/응답 포맷으로 흔히 JSON 사용 균일한(uniform) 인터페이스를 적용 리소스에 표준 HTTP 동사(GET, POS…","fields":{"slug":"/rest/"},"frontmatter":{"date":"April 04, 2022","title":"REST","tags":["django","DRF"]},"rawMarkdownBody":"\r\n작성중\r\n\r\n### 1. RESTful API의 몇 가지 디자인 원칙\r\n\r\n---\r\n\r\n1. 리소스(모델등)를 중심으로 디자인\r\n\r\n2. 클라이언트에서 엑세스 할 수 있는 모든 종류의 개체/ 서비스가 리소스에 포함\r\n\r\n3. 리소스마다 해당 리소스를 고유하게 식별하는 식별자 존재\r\n\r\n   ex) `https://my-trips.com/trips/1/`\r\n\r\n4. 요청/응답 포맷으로 흔히 JSON 사용\r\n\r\n5. 균일한(uniform) 인터페이스를 적용\r\n\r\n   리소스에 표준 HTTP 동사(GET, POST, PUT, PATCH, DELETE)\r\n\r\n### 2. HTTP METHOD별 다양한 상태 코드\r\n\r\n---\r\n\r\n#### GET\r\n\r\n일반적으로 200(OK) 응답, 리소스를 못 찾을 경우 404(Not Found) 응답\r\n\r\n#### POST\r\n\r\n201(Created) 응답. 새 리소스의 URI는 응답의 로케이션 헤더에\r\n\r\n새 리소스를 만들지 않은 경우, 200응답하고 리소스와 관련된 내용을 응답 본문에 포함. 반환할 결과가 없으면 204(내용없음)을 반환할 수도\r\n\r\n400(잘못된 요청)\r\n\r\n#### PUT\r\n\r\n성공- 200(OK) 204(내용없음)\r\n\r\n실패 - 409(충돌)\r\n\r\n#### DELETE\r\n\r\n성공시 204, 리소스가 없으면 404\r\n\r\n#### 비동기작업\r\n\r\n202(수락됨) - 요청은 수락되었지만 아직 완료되지않음\r\n\r\n비동기 요청의 상태를 반환하는 URI를 로케이션 헤더로 변환\r\n\r\n로케이션 헤더를 통해 비동기작업의 진행상황을 알 수 있음\r\n"},{"excerpt":"Meta 클래스란? 모델 내부에 정의되는 클래스로 Django모델 자체에 대한 정보, 속성을 추가하는 클래스이다. Meta 클래스는 권한, 데이터베이스의 이름, 단 복수 이름, 추상화, 순서 지정등과 같은 모델에 대한 다양한 사항을 정의하는데 사용할 수 있다. 다음은 Meta 클래스 활용 예시이다. 1. abstract 모델이 추상적인지를 결정한다. 추상…","fields":{"slug":"/meta-class/"},"frontmatter":{"date":"April 03, 2022","title":"Django의 Meta 클래스 활용","tags":["django"]},"rawMarkdownBody":"\r\n## Meta 클래스란?\r\n\r\n모델 내부에 정의되는 클래스로 Django모델 자체에 대한 정보, 속성을 추가하는 클래스이다.\r\n\r\n```python\r\nfrom django.db import models\r\n\r\n#모델 내부에 정의\r\nclass MyModel(models.Model):\r\n    ...\r\n    class Meta:\r\n\t\t...\r\n```\r\n\r\nMeta 클래스는 권한, 데이터베이스의 이름, 단 복수 이름, 추상화, 순서 지정등과 같은 모델에 대한 다양한 사항을 정의하는데 사용할 수 있다.\r\n\r\n다음은 Meta 클래스 활용 예시이다.\r\n\r\n### 1. abstract\r\n\r\n모델이 추상적인지를 결정한다. 추상 클래스는 인스턴스화 할 수 없고 확장 또는 상속만 가능하다.\r\n\r\n```python\r\n class Meta:\r\n        abstract = True\r\n```\r\n\r\n### 2. db_table\r\n\r\n데이터베이스 테이블 이름을 설정한다.\r\n\r\n```python\r\nclass Meta:\r\n    db_table = \"comment\"\r\n```\r\n\r\n기본적으로 Django에서 db table의 이름은 앱이름\\_모델이름으로 정의된다.\r\n\r\nex) _board앱의 Post모델의 경우: board_post로 정의됨_\r\n\r\nMySQL등 장고 외부 데이터베이스와 연동할 때 사용하는듯?\r\n\r\nMySQL 백엔드의 경우 테이블 이름은 소문자로 지정해야하고 Oracle은 테이블 이름에 30자 제한이 있음. 이럴 때 사용하는듯\r\n\r\n### 3. ordering\r\n\r\n모델 필드명을 기준으로 모델 객체의 순서를 정의한다.\r\n\r\n```python\r\nfrom django.db import models\r\n\r\nclass JobPosting(models.Model):\r\n    dateTimeOfPosting = models.DateTimeField(auto_now_add = True)\r\n\r\n\r\n    class Meta:\r\n        ordering = [\"-dateTimeOfPosting\"]\r\n```\r\n\r\n### 4. verbose_name\r\n\r\nDjango 모델을 admin페이지에서 조회할 때 모델 표기 방법을 변경한다.\r\n\r\n```py\r\nclass Meta:\r\n    verbose_name = \"포스트\"\r\n```\r\n"},{"excerpt":"container와 item flex하기전 알아야할 컨테이너와 아이템\n컨테이너가 전체 박스\n아이템이 컨테이너 안에 있는 요소 flex를 사용해서 정렬해주려면 컨테이너에 속성을 추가해준다. 주축 flex-direction속성으로 flex의 주축을 설정할 수 있다 row row-reverse column column-reverse 주축을 기준으로 정렬할때는 …","fields":{"slug":"/flex/"},"frontmatter":{"date":"April 02, 2022","title":"flex 해보기 ㅎㅎ","tags":["css"]},"rawMarkdownBody":"\r\n### container와 item\r\n\r\nflex하기전 알아야할 컨테이너와 아이템\r\n컨테이너가 전체 박스\r\n아이템이 컨테이너 안에 있는 요소\r\n\r\nflex를 사용해서 정렬해주려면 컨테이너에\r\n\r\n```css\r\ndisplay: flex;\r\n```\r\n\r\n속성을 추가해준다.\r\n\r\n### 주축\r\n\r\n```css\r\nflex-direction: row;\r\n```\r\n\r\nflex-direction속성으로 flex의 주축을 설정할 수 있다\r\n\r\n- row\r\n- row-reverse\r\n- column\r\n- column-reverse\r\n\r\n### 주축을 기준으로 정렬할때는 justify-content를 사용\r\n\r\n```css\r\njustify-content: flex-end;\r\n```\r\n\r\n- flex-start\r\n- center\r\n- flex-end\r\n- space-between : 맨 끝 간격제로\r\n- space-around : 맨 끝 간격있음\r\n\r\n### 반대축을 기준으로 정렬할때는 align사용\r\n\r\n- align-items\r\n- align-content - wrap을 했을때\r\n\r\n### wrap\r\n\r\n```css\r\nflex-wrap: wrap;\r\n```\r\n\r\n- wrap\r\n- wrap-reverse  \r\n  wrap을 하면 item이 공간을 벗어날때 다음 줄에 이어서 나오게한다.\r\n"},{"excerpt":"스케줄링 policy : CPU를 누구한테 할당할까\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐 FCFS 가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리 하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함 24, 3, 3 …","fields":{"slug":"/5-2/"},"frontmatter":{"date":"March 30, 2022","title":"OS 스케줄링","tags":["OS"]},"rawMarkdownBody":"\r\n스케줄링 policy : CPU를 누구한테 할당할까\r\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\r\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐\r\n\r\n## FCFS\r\n\r\n가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리\r\n\r\n하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함\r\n\r\n24, 3, 3 <-cpu burst time\r\n\r\n단점: 시피유 버스트 타임이 긴 프로세스가 먼저 선택된다면 하나가 시피유를 독점\r\n솔루션 : 시피유 버스트가 끝날때까지 기다리는게 아니라 일정 시간이 지나면 강제적으로 컨텍스트 스위치를 시켜버리자 time slice\r\n\r\n예제)\r\n\r\nP1 P2 P3순으로 실행(먼저 온 순서)\r\n\r\n- waiting time : 각 프로세스가 도착한 이후에 얼마나 기다렸는가\r\n\r\np2 p3 p1 순으로 왔을 때 훨씬 빨라짐\r\n\r\n## Shortest Job First (SJF)\r\n\r\nKey operations : length of CPU burst\r\n\r\n각각의 cpu 버스트의 길이를 가지고 짧은 애한테 우선순위 할당\r\n\r\noptimal함 : 쉽게 증명 가능\r\n\r\nwaiting time 기준으로는 가장 좋은 policy\r\n\r\n문제) 어떻게 cpu burst 타임을 알 수 있는지\r\n정확한 cpu burst time을 OS가 알 수 없음. 구현불가능!\r\n\r\ntwo variations이 존재\r\n\r\n- non preemptive (양보가 안되는. 우선순위)\r\n\r\n  어떤 SJF정책에 의해서 한 번 씨피유를 점유하면 그 잡이 끝날때까지는 스케줄링이 되지 않는다. 자리 안내줌\r\n\r\n- preemptive(양보가능한)\r\n\r\n  만약 SJF정책에 의해 짧은애가 선택이 되면\r\n  새로운 프로세스가 레디큐에 들어옴\r\n  다시 스케줄링 가능. 새로 들어온 애 먼저 들어가게 해줌 \r\n\r\n  ex)\r\n  끝난 시간 /바로 수행됐다면 끝났을 시간/ waiting time\r\n  p1 16 (0+7) 9\r\n  p2 7 (2+4) 1\r\n  p3 5 (4+1) 0\r\n  p4 11 (5+4) 2\r\n\r\n근데 cpu burst time을 알 수 없음\r\n\r\n노력1. 예측해보자!\r\nexponential averaging\r\n수학적인 컨셉 제공 but 실제로 os에 적용하긴 무리 : 알파값 정하기가 힘듦. 실패케이스\r\nn+1시점의 cpu burst time을 이전의 히스토리를 가지고 예측해보자\r\n\r\ntn : 바로 직전의 실제 cpu burst time\r\n타우n+1 : 이번에 예측할 cpu burst time\r\n타우n : 바로 직전에 예측했던 cpu burst time\r\n\r\n알파를 얼마로 정해야?\r\n알파 = 0 기존에 예측한거 유지\r\n알파 = 1 직전의 실제값만 씀\r\n알파값은 시스템과 응용프로그램에 따라 또 달라짐\r\n이론적인 컨셉만 제공하고 실제 사용은 안함\r\n\r\n더 나은 policy를 찾아야할 필요성\r\n\r\n---\r\n\r\n## Round Robin(RR)\r\n\r\nKey operations : 각각의 프로세스는 각자의 time quantum(q) 동안만 cpu를 차지할 수 있음. q가 끝나면 cpu를 돌려주고 레디큐의 맨 끝으로 돌아감.\r\n\r\nq는 10 - 100 밀리세컨드 정도\r\n\r\nq가 크면 : FIFO. FCFS와 같아짐.\r\nq가 작으면 : 컨텍스트 스위치 오버헤드가 커짐. SJP와 근접해짐.\r\n\r\n많은 os가 라운드로빈이 기반인 스케줄링 사용\r\n\r\n컨텍스트 스위치타임은 보통 <10\r\nq를 10~100으로 잡아서 컨텍스트 스위치타임의 오버헤드가 안보이게\r\n\r\n만약 n개의 프로세스가 있다면 어떤 프로세스가 자기 순서를 받을때까지 최대 (n-1)q 만큼만 기다리면 됨\r\n\r\nbad case) 10개의 프로세스가 100 time을 수행해야함\r\n\r\n1000-10 #waiting time\r\n1000-9\r\n1000-8\r\n.\r\n.\r\n.\r\n\r\n다들 오랜 시간 기다려야함.\r\n균등하게 비효율적.\r\n\r\n즉,  스케줄링 할 대상들이 비슷한 cpu burst time을 가질때 bad\r\n\r\nex) \r\n\r\n* q가 100 \r\n* p1 cpu burst:1 , I/O burst :10\r\n* p2는 그냥 계속 cpu burst\r\n\r\n![](./ex.png)\r\n\r\np1 1ms + 10ms waiting |1ms + 10ms|\r\np2 100ms . . . . . . . . 100ms . . . . . .\r\n1ms 후 100ms 수행\r\n\r\n\r\n\r\nU(CPU) = 100% (cpu가 얼마나 활용되고있는가)\r\n\r\nU(I/O) = 10ms 돌고 91ms 기다림\r\n10/101 = 10%\r\n\r\n단점) I/O 사용이 잘 안됨\r\n\r\n같은 ex, q만 다르다고 가정) q = 1\r\nU(CPU) = 100%\r\nU(I/O) = 거의 90% p1이 cpu burst할때 제외하고는 다 I/O (10/11)\r\n\r\n단점) 컨텍스트 스위칭이 자주 일어남. 오버헤드큼\r\n\r\n타임 퀀텀이 적절해야 라운드로빈 효율적\r\n근데 적절한 타임이 cpu burst와 i/o burst에게 다름\r\ncpu는 클수록. io는 작을수록\r\n\r\n다음해결방안 : (SJ)io bound process한테는 타임 퀀텀을 작게 (LJ)씨피유는 타임퀀텀을 크게\r\n\r\n프로세스마다 다르게 적용함 adaptive policy\r\n\r\n## Priority Scheduling\r\n\r\n각 프로세스마다 우선순위 부여 - 숫자형태로\r\n\r\n더 높은 우선순위 먼저 실행\r\nSJF도 프라이어리티 스케줄링의 일종이라고 볼 수 있음. 얘는 실행시간이 짧은애가 우선\r\n\r\n얘도\r\n프림티브\r\n논프림티브 둘 다 만들 수 있음\r\n\r\n문제) Starvation\r\n어떤 프로세스가 우선순위가 낮음. 우선순위가 더 높은 프로세스가 계속들어온다면 우선 순위가 낮은 프로세스는 실행될 수 없음.\r\n\r\n솔루션) Aging\r\n프라이어티에 나이 개념 도입\r\n대기 시간이 길어지면 우선순위롤 조금씩 올려줌\r\n\r\n## Multilevel Queue\r\n\r\n큐를 분리해서 사용\r\n\r\nforeground - 인터랙티브 : cpu보다 io가 더 느림\r\nbackground - batch : cpu가 긴.\r\n각 프로세스는 한 번 큐가 정해지면 그 큐만 사용? 반배정하듯이\r\n각각의 큐는 서로 다른 policy를 가질 수 있음\r\n\r\n- foreground - RR\r\n\r\n- background - FCFS\r\n\r\n> 반드시 저런건 아님. 설계하기나름\r\n\r\n어떤 큐에 있는 애한테 우선순위를 줄 것인지도 결정 필요\r\n이를 위한 policy도 추가적으로 필요\r\n\r\n- 고정된 프라이어티 스케줄링\r\n\r\n- 타임 슬라이스 (포그라운드한테 일정시간, 백그라운드한테 일정시간)\r\n\r\n  아직은 adaptive아님 아냐 아주 약간 adaptive...?\r\n\r\n실질적으로 사용하는게 Multilevel Feedback Queue\r\n\r\n"},{"excerpt":"📌 Interrupt CPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재 특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다 Interrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음. cpu 내에서 일어난건…","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"date":"March 30, 2022","title":"2-2 Interrupt 메카니즘","tags":["OS"]},"rawMarkdownBody":"\r\n# 📌 Interrupt\r\n\r\nCPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\r\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재\r\n\r\n* 특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다\r\n\r\nInterrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음.\r\n\r\ncpu 내에서 일어난건 trap, exception이라고 부름 인터럽트랑 다르게 취급\r\n\r\nsoftware-generated interrupt라고도 부름\r\n\r\nex. 0으로 나누면 안되는데 0으로 나눴다던지\r\n\r\n OS는 interrupt driven 프로그램 :\r\n\r\n* os내부의 커널은 생각보다 수동적. 밖에서 인터럽트가 들어와야 깨어나서 일을 함\r\n\r\n\r\n\r\n## 📌 Interrupt Handling\r\n\r\n📌 **인터럽트가 오면 어떻게 하죠?**\r\n\r\n* 현재 프로그램을 stop한다(현재 진행중이던 instruction은 시행한다. 하던건 끝내고 스탑함)\r\n* 현재 cpu의 상태를 저장한다(사용하던 레지스터값, pc등)\r\n* 인터럽트 벡터 테이블을 통해 ISR을 알아냄\r\n* ISR로 점프해서 실행\r\n\r\n> 사실 ISR이 커널의 핵심임\r\n\r\n\r\n\r\n![](./timeline.png)\r\n\r\n* cpu는 I/O request보내놓고 할 일 계속함\r\n\r\n* CPU 그래프?의 1에 해당하는 부분은 user-processing\r\n* 0에 해당하는 부분은 interuupt processing\r\n\r\n* I/O가 response(= interrupt)를 보낼때까지 CPU는 user processing mode\r\n* 조금 딜레이된 이유는 하던 명령까지는 하고 끝낸다\r\n\r\nOS는 interrupt driven 프로그램\r\n\r\n\r\n\r\n## OS Design and Implementation\r\n\r\n정답이 있는건아님.\r\n\r\n여러가지 os는 다 다르게 생겼다\r\n\r\n* 골을 세우고\r\n* 스펙을 정한다\r\n\r\n* os는 하드웨어 위에서 일하기때문에 하드웨어에 종속적\r\n* os는 유저에도 맞닿아있고 하드웨어에도 맞닿아있다\r\n* 사용하기도 쉽고 구현하기도 쉽고 유지도 쉬워야...\r\n* **policy와 mechanism을 분리해서 설계해야한다**\r\n\r\n\r\n\r\n* **📌 Policy** \r\n\r\n  뭘 해야하는가! what!!!, 환경, 사용자가 어떻게 사용하는지... 뭐 그런거에 의해 변경될 수 있음\r\n\r\n  \r\n\r\n* **📌 Mechanism**\r\n\r\n  어떻게 해야 하는가!, 어떤거 동작해야하는지, 기계적 how!!!, 하드웨어에 종속적\r\n\r\n\r\n\r\n둘이 변경되는 상황이 달라서 구분해두는게 좋음. 유연성 증가!\r\n\r\n\r\n\r\n## OS Implementation\r\n\r\n* 초창기 os는 어셈블리 기계어\r\n\r\n* 대부분의 os가 c로 설계\r\n* 요즘은 믹스, high-level language도 사용\r\n\r\n> 하이레벨 랭귀지 \r\n>\r\n> 장점 : 다른 하드웨어에 포트하기쉬움, 기계어로 직접 번역되어있지않기때문에 해당 기계어로 번역 가능, 빨리 작성 가능, 간결, 이해하기 쉬움, 디버깅도 쉬움, c도 하이레벨\r\n>\r\n> 단점 : 느림\r\n\r\n**사실 os의 주 성능은 하이레벨랭귀지... 사용여부보다는 policy가 더 중요**\r\n\r\n\r\n\r\n## OS Structure\r\n\r\n* Simple structure - MS-DOS\r\n* More complex - Initial UNIX\r\n* Layered approach\r\n* Microkernel structure \r\n* Hybrid\r\n\r\n\r\n\r\n> 추상화 \r\n>\r\n> 블랙박스화, 각각의 모듈은 다른 모듈의 세부적인 내용에 대해 알 필요 없다. 서로 무슨 일 하는지, 통신만 할 수 있기만 하면 됨\r\n\r\n\r\n\r\n> 분리 (Decomposition)\r\n>\r\n> os는 거대하기때문에 모듈화\r\n\r\n\r\n\r\n### MS-DOS\r\n\r\n윈도우가 나오기전 마이크로소프트웨어에서 만들던 os\r\n\r\n초창기 pc 운영체제\r\n\r\n모듈화가 안되어있음\r\n\r\n필수적인 기능만 존재\r\n\r\n싱글 태스크 - 싱글 유저\r\n\r\n프로그램 -> 커널 ->프로그램 형식의 단순한 형태\r\n\r\n\r\n\r\n### Initial UNIX\r\n\r\n![](./unix.png)\r\n\r\n* 📌 시스템 프로그램과 커널을 나눔\r\n\r\n* 나누긴 했지만 커널은 여전히 하나\r\n* 굉장히 큰 커널 하나! 커널 하나에서 i/o통신, 파일 시스템, cpu스케줄링등 다 하는 중\r\n* 모놀리식 구조라고도 함 (커널이 하나로 이루어져있다. 단순)\r\n\r\n\r\n\r\n### Layered Approach\r\n\r\n* 각각의 레이어는 자신보다 하위 계층과 소통할줄만 알면 된다\r\n* 📌 N이 클수록 상위. 일의 요청이 한 단계 아래로만 일어난다. 레이어1은 레이어0에게 일 요청\r\n* 낮을수록 하드웨어, 높을수록 사용자 인터페이스와 가까운\r\n* 모듈화\r\n* 블랙박스화됨. 각각의 레이어는 다른 레이어가 어떻게 구현되어있는지 모름. 일만 시킬줄알면됨\r\n* 현대 os는 레이어로 이루어져있지않음. 마이크로커널과 모듈화로 되어있음\r\n\r\n\r\n\r\n### Microkernel\r\n\r\n마이크로 : 작음\r\n\r\n커널이 작다!\r\n\r\n> 여러 파트로 나뉘어있으나 커널 파트한테 주는게 아니라 유저 레벨 프로그램으로 만듦. 커널의 마이크로한 기능들이 **유저 레벨 프로그램**처럼 동작함\r\n\r\n* 커널에서 필수적인 부분을 빼고는 제외함\r\n\r\n* 나머지는 유저 레벨 프로그램으로 만들어버림 \r\n\r\n  (os의 일부분... 기능이지만 os 밖에서 작동)\r\n\r\n* 유저 레벨 프로그램끼리는 **메세지 패싱**을 통해 주고받음\r\n\r\n* 예전에는 커널안에 같이 있어서 걍 메모리 주소 access했음\r\n\r\n* 메모리 카피가 일어남. 퍼포먼스 오버헤드 존재\r\n\r\n* 커널이 작아서 커널 업데이트하기가 쉬움, 디버깅도 당연 쉽\r\n\r\n* 커널을 다른 시스템에 적용하기도 쉬움. 작으니까~!\r\n\r\n* reliable. 커널 안에서 돌아가는 기능이 적어지면서 원래는 커널 안의 동작이 여러군데 영향을 끼쳤는데 이젠 밖에서 일어나니까 한 부분에 문제가 발생하도 다른 프로그램에 영향을 덜 끼친다 (같은 의미에서 secure해짐)\r\n\r\n* Mac OS X kernel 다윈의 한 부분이 마이크로커널로 구현됨\r\n\r\n\r\n\r\n### Modules\r\n\r\nloadable kernel modules (LKM)\r\n\r\n* 기본적으로 마이크로 커널과 비슷하게 생김\r\n* 하나의 프로그램으로 나눈게 아니라 동적으로 탑재할 수 있는 라이브러리 형태로 나눔. 기능이 필요할 때 마다 동적으로 사용\r\n* 마이크로커널처럼 핵심적인 os는 적음\r\n* 추가적인 서비스는 커널이 동작하는동안 동적으로 로딩해서 링킹하고 사용한다\r\n* 실질적으로 수행할때는 하나의 커널안에서 수행되어서 메시지 패싱이 필요없음\r\n\r\n\r\n\r\n### Hybrid System\r\n\r\n섞어씀 ㅎ\r\n\r\n모듈로 구성하되 특정 부분은 마이크로 ...\r\n\r\n요즘은 거의 다 섞어 씀\r\n\r\n## 📌 OS Structure 시험 안나온다함 킹받네\r\n"},{"excerpt":"OS(운영체제)란? 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.\n사용자와 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌.\nex) Windows, Linux OS의 역할 reso…","fields":{"slug":"/1-2/"},"frontmatter":{"date":"March 29, 2022","title":"OS의 역할과 역사","tags":["OS"]},"rawMarkdownBody":"\r\n## OS(운영체제)란?\r\n컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.\r\n사용자와 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줌.\r\nex) Windows, Linux\r\n\r\n## OS의 역할\r\n\r\n- resource allocator\r\n- program controller\r\n\r\nfor 유저의 편리한 사용\r\nfor 좋은 성능\r\n\r\n- 공유된 컴퓨터\r\n  큰 서버의 shared resource를 어떻게 분배할 것인가\r\n  handheld computers는 리소스가 작음. 배터리 처리\r\n  임베디드 컴퓨터는 유저 인터페이스가 없는 경우가 있어 os가 처리\r\n\r\n## OS의 역사\r\n## 1. (Early 1950s - Mid 1960s)\r\n하드웨어가 비쌈\r\ngoal : 어떻게 하드웨어를 효율적으로 사용할 것인가\r\npunch card를 사용해 하나하나 코딩\r\n사람이 os의 역할을 수행 (operator)\r\n\r\n- 카드를 받고 출력을 해서 유저에게 전달\r\n  📌 **slow job to job **\r\n\r\n---\r\n\r\n### Simple batch monitor(여러개의 job을 묶음)\r\n\r\n저성능 컴퓨터, 고성능 컴퓨터 함께 사용\r\n저성능은 인풋, 아웃풋 \r\n고성능은 연산\r\n\r\n**io할 때는 cpu연산 못함**\r\n\r\n<bold> faster job to job </bold>\r\n\r\n---\r\n\r\n### batch monitor(최초의 os)\r\n\r\n📌 **하드웨어 메커니즘이 나옴 - I/O와 CPU 분리**\r\nI/O를 하는동안 cpu연산을 못해서 분리\r\n\r\ninturrupt : cpu에게 I/O작업이 끝났음을 알려줌\r\n\r\n📌 **버퍼링과 interrupt 핸들링작업이 os에 추가됨**\r\n\r\n- computation과 비동기적(async) I/O가 분리됨\r\n\r\nsync I/O - read : 읽어와야 다음 작업 가능\r\nasync I/O - write : 쓰는 행위는 다음 작업에 영향을 안끼침\r\n(모든 read가 sync, write가 async인건 아니지만 대체로 그러함)\r\n\r\n### Multi-programmed batch monitor\r\n\r\n- 📌 **동시에 둘 이상의 active한 job(시작되었으나 아직 끝나지않은 작업)을 수행**\r\n- sync I/O도 분리\r\n- Degree of multiprogramming >= 1 : active job을 얼마나 수행할 수 있는지\r\n\r\n#### 멀티 프로그래밍이 생기면서 시작된 문제들\r\n\r\n\\* Memory protection and relocation\r\n하나의 job이 실수로 다른 job에 영향을 끼침\r\n다른 job의 addr를 침범\r\n하나의 메모리공간에 여러 job이 올라감. job의 주소 공간 예측 불가능 - 로지컬 주소와 피지컬 주소의 구분이 생김\r\n-> MMU(Memory-Management-Unit)\r\n\r\n\\* Higher utilization\r\n\r\n\\* Concurrent programming\r\n하나의 자원을 공유하면서 생기는 문제\r\n\r\n## 2. (Mid 1960s - Mid 1990s)\r\n\r\n하드웨어가 저렴해짐, 인력이 비싸짐\r\ngoal: 인력을... 효율적으로 ...\r\n\r\n### Interactive time-sharing OS\r\n\r\n하나의 cpu를 분할해서 여러 사람들이 사용\r\n\r\n- 터미널이 저렴 : 메인컴퓨터 하나에 여러 터미널 존재\r\n- 파일 시스템 등장\r\n- Response time과 protection이 더욱 중요해짐\r\n\r\n### PC OS - personal computer\r\n\r\n각자 컴퓨터가 생김\r\nOS가 subroutine libaray로 나눠짐(OS를 큰 기능별로 나눠서 사용)\r\n\r\n## 3.(Mid 1990s - )\r\n\r\n- 인터넷\r\n  Network I/O가 생김\r\n- 동영상등 멀티미디어 서포트\r\n  QoS(Quality of Service)\r\n  -> OS scheduling 발전\r\n  예전 : priority - 우선순위 기반\r\n  멀티미디어 서포트 이후 : badwidth 기반 - 각각의 프로세스에게 조금씩 할당\r\n- connected multimedia services\r\n  스트리밍\r\n- 모바일\r\n  적은 리소스, 배터리를 효율적으로 관리\r\n- 클라우드 컴퓨팅\r\n  virtualzation\r\n\r\n## OS의 특징\r\n\r\n- Large\r\n  수천만 라인\r\n- Complex\r\n  비동기적인 behaviors의 집합체\r\n  하드웨어 특성의 이해 필요\r\n- Poorly understood\r\n  오랜시간동안 기능이 추가되며 만들어짐\r\n  코드에 대한 이해도가 떨어져감\r\n"},{"excerpt":"1. OS의 구조  GUI : 그래픽 UI ex. 마우스 커서 command line : 커맨드입력창 시스템콜 : os 내부 기능 활용 커널(그림의 services) 2. 컴퓨터 하드웨어 CPU DISK disk controller memory 📌 bus\n등등... System bus Data bus\n서로 데이터를 주고받음 Command/Address b…","fields":{"slug":"/os-structure/"},"frontmatter":{"date":"March 29, 2022","title":"2-1 OS의 구조","tags":["OS"]},"rawMarkdownBody":"\r\n## 1. OS의 구조\r\n\r\n<br/>\r\n\r\n![](./osinstructure.png)\r\n\r\n- **GUI** : 그래픽 UI ex. 마우스 커서\r\n\r\n- **command line** : 커맨드입력창\r\n\r\n- **시스템콜** : os 내부 기능 활용\r\n\r\n- **커널**(그림의 services)\r\n\r\n## 2. 컴퓨터 하드웨어\r\n\r\n- CPU\r\n- DISK\r\n- disk controller\r\n- memory\r\n- 📌 bus\r\n  등등...\r\n  - System bus\r\n  \r\n    1. Data bus\r\n       서로 데이터를 주고받음\r\n    2. Command/Address bus\r\n       메모리 주소, 명령어(거의 read/write : 프린터에 뭘 쓰기위해 설정값을 바꾸려는 명령어도 write에 포함)\r\n  \r\n  - 버스 component classification\r\n    1. Bus arbiter(버스 관리자)\r\n       여러개의 버스 리퀘스트가 동시에 들어옴. 어떤애를 먼저 보낼지 충돌 관리\r\n    2. Bus master\r\n       신호를 보내는 쪽 : bus transactionn을 만듦.\r\n       ex) CPU, DMA controller, graphics adapter\r\n    3. Bus slave\r\n       신호를 받는 쪽\r\n       ex) Memory, Device controller\r\n\r\n## 3. I/O Operations\r\n\r\nI/O controller가 cpu commands에 따라 I/O operations 수행\r\nI/O controller register\r\n\r\n- Data register(input, output : 실질적으로 보내고 받는 데이터)\r\n- 📌 Control register(control, status) <- 컨트롤 레지스터의 값을 변경해줌으로써 i/o동작이 일어나도록 함\r\n\r\nex) 아웃풋 레지스터 수행할때\r\n\r\n1. cpu : read status register of I/O controller(레지스터가 사용 가능한 상태인지 확인)\r\n2. write cmd : data를 I/O controller한테 보냄\r\n3. 쓸 수 없는 상태라면 쓸 수 있는 상황이 될 때까지 1번을 반복\r\n\r\n### 📌 I/O operation이 끝났는지 확인할 수 있는 방법 :\r\n\r\n1. Polling I/O\r\n2. interrupt-driven I/O\r\n\r\n#### Polling I/O\r\ncpu가 주도\r\n주기적으로 I/O status reg를 체크\r\n\r\n#### Interrupt-driven I/O\r\nI/O controller가 주관\r\nI/O device controller가 cpu한테 알려줌\r\n\r\n### 📌 I/O register에 접근 방법\r\n\r\n1. Memory-mapped I/O : 메모리 addr주소에 접근\r\n2. Port-mapped I/O : 메모리 주소는 따로 있고 디바이스 별로 포트를 만들어서 접근. Port-mapped I/O가 대체로 쓰임\r\n"},{"excerpt":"장고 모델 <데이터베이스 테이블>과 <파이썬 클래스>를 1대1로 매핑 모델 클래스명은 단수형으로 지정\nex) Posts(x) Post(o) 첫 글자는 대문자 - PascalCase 네이밍 장고 모델을 통해 데이터베이스 형상을 관리할 경우 모델 클래스 작성 모델 클래스로부터 마이그레이션 파일 생성 : makemigrations 마이그레이션 파일을 데이터베이…","fields":{"slug":"/django-ORM/"},"frontmatter":{"date":"March 28, 2022","title":"django ORM","tags":["django"]},"rawMarkdownBody":"\r\n## 장고 모델\r\n\r\n<데이터베이스 테이블>과 <파이썬 클래스>를 1대1로 매핑\r\n\r\n- **모델 클래스명은 단수형으로 지정**\r\n  ex) Posts(x) Post(o)\r\n\r\n- **첫 글자는 대문자** - PascalCase 네이밍\r\n\r\n### 장고 모델을 통해 데이터베이스 형상을 관리할 경우\r\n\r\n1. 모델 클래스 작성\r\n2. 모델 클래스로부터 마이그레이션 파일 생성 : makemigrations\r\n3. 마이그레이션 파일을 데이터베이스에 적용 : migrate\r\n4. 모델 활용\r\n\r\n### 장고 외부에서 데이터 베이스 형상을 관리할 경우\r\n\r\n데이터베이스로부터 모델클래스 소스 생성 : inspectdb\r\n모델 활용\r\n\r\n## DB 테이블명\r\n\r\ndefault : \"앱이름\\_모델명\"  \r\nex) blog앱의 Post모델 -> \"blog_post\"\r\n커스텀을 위해선 모델 Meta 클래스의 db_table 속성 변경\r\n\r\n> migrate전에 변경해야함\r\n\r\n## migrate 쿼리 보기\r\n\r\npython manage.py sqlmigrate (앱이름) (마이그레이션파일이름)  \r\nex) python manage.py sqlmigrate blog 0001_initial\r\n\r\n## 테이블 목록 보기\r\n\r\npython manage.py dbshell (sqlite 설치 필요)  \r\n.tables\r\n\r\n## 스키마 보기\r\n\r\n.schema (db 테이블명: 앱이름\\_모델이름)  \r\nex) .schema blog_post\r\n"},{"excerpt":"에러내용 git push 전 pull 했는데 fatal: refusing to merge unrelated histories 오류가 날 때 깃허브 레파지토리를 먼저 만들고 로컬에서 프로젝트 생성 후 푸쉬하려고 할 때 두 프로젝트를 다른 것으로 인식해서 나는 에러 해결방법 --allow-unrelated-histories 독립적인 두 프로젝트를 병합하는 명…","fields":{"slug":"/1/"},"frontmatter":{"date":"March 27, 2022","title":"git pull 오류 : fatal: refusing to merge unrelated histories","tags":["ERROR"]},"rawMarkdownBody":"\r\n### 에러내용\r\n\r\ngit push 전 pull 했는데 **fatal: refusing to merge unrelated histories** 오류가 날 때\r\n\r\n> 깃허브 레파지토리를 먼저 만들고 로컬에서 프로젝트 생성 후 푸쉬하려고 할 때 두 프로젝트를 다른 것으로 인식해서 나는 에러\r\n\r\n### 해결방법\r\n\r\n```\r\n    git pull origin [브런치] --allow-unrelated-histories\r\n```\r\n\r\n--allow-unrelated-histories\r\n\r\n독립적인 두 프로젝트를 병합하는 명령어\r\n"},{"excerpt":"1. 패키지 다운로드 CORS란?\n동일한 출처의 리소스에만 접근하도록 제한하는 것. 프로토콜, 호스트명, 포트번호가 모두 같아야함.\nDjango 서버는 127.0.0.1:8000에서 실행되고 React서버는 127.0.0.1:3000에서 실행된다.\n두 서버의 포트번호가 다르기때문에 CORS 에러가 발생! 2. Django project의 settings.…","fields":{"slug":"/initial-settings/"},"frontmatter":{"date":"March 26, 2022","title":"Django REST Framework와 React 연동 첫걸음! 초기세팅을 해보자!","tags":["DRF","React"]},"rawMarkdownBody":"\r\n### 1. 패키지 다운로드\r\n\r\n```\r\n    pip install django\r\n    pip install djangorestframework\r\n    pip install django-cors-headers\r\n```\r\n\r\n**CORS란?**\r\n동일한 출처의 리소스에만 접근하도록 제한하는 것. 프로토콜, 호스트명, 포트번호가 모두 같아야함.\r\nDjango 서버는 127.0.0.1:8000에서 실행되고 React서버는 127.0.0.1:3000에서 실행된다.\r\n두 서버의 포트번호가 다르기때문에 CORS 에러가 발생!\r\n\r\n### 2. Django project의 settings.py 에 추가\r\n\r\n```python\r\n\r\n  ALLOWED_HOSTS = ['*']\r\n\r\n  INSTALLED_APPS = [\r\n\r\n    #   DRF\r\n    'rest_framework',\r\n\r\n    #CORS\r\n    'corsheaders',\r\n\r\n]\r\n\r\n# 사이트 간 HTTP 요청을 할 수 있는 권한이 있는 출처 목록\r\nCORS_ALLOWED_ORIGINS = [\r\n    'http://127.0.0.1:8000',\r\n    'http://localhost:3000',\r\n]\r\n\r\n# True이면 사이트 간 HTTP 요청에 쿠키를 포함할 수 있다. default값은 false.\r\nCORS_ALLOW_CREDENTIALS = True\r\n\r\n\r\nMIDDLEWARE = [\r\n    'corsheaders.middleware.CorsMiddleware',\r\n]\r\n\r\nTEMPLATES = [\r\n    {\r\n        'DIRS': [\r\n            os.path.join(BASE_DIR, 'frontend', 'build'), #리액트 템플릿 연결\r\n        ],\r\n    },\r\n]\r\n\r\nSTATICFILES_DIR = [\r\n    os.path.join(BASE_DIR, 'frontend','build','static'),\r\n]\r\n```\r\n\r\n**CORS_ALLOWED_ORIGINS**\r\n접근 가능한 출처명을 적는 리스트 CORS_ALLOWED_ORIGIN_REGEXES 를 사용해서 정규식으로 표현할수도 있다.\r\n\r\n```python\r\nCORS_ALLOWED_ORIGIN_REGEXES  =  [\r\n    r \"^https://\\w+\\.example\\.com$\" ,\r\n]\r\n```\r\n\r\n### 3. manage.py 수정\r\n\r\n```python\r\n\r\ndef main():\r\n    \"\"\"Run administrative tasks.\"\"\"\r\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')\r\n    try:\r\n        from django.core.management import execute_from_command_line\r\n    except ImportError as exc:\r\n        raise ImportError(\r\n            \"Couldn't import Django. Are you sure it's installed and \"\r\n            \"available on your PYTHONPATH environment variable? Did you \"\r\n            \"forget to activate a virtual environment?\"\r\n        ) from exc\r\n\r\n    try: #try문 하나 더 추가\r\n        if sys.argv[2] == 'react': #python [0]:manage.py [1]:runserver [2]:react\r\n            project_root = os.getcwd()\r\n            os.chdir(os.path.join(project_root, \"frontend\"))\r\n            os.system(\"npm run build\")\r\n            os.chdir(project_root)\r\n            sys.argv.pop(2)\r\n    except IndexError:\r\n        execute_from_command_line(sys.argv)\r\n    else:\r\n        execute_from_command_line(sys.argv)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n```\r\n\r\n추가한 try문으로 python manage.py runserver react로 리액트 서버까지 연결된 상태로 실행이 가능해진다.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}