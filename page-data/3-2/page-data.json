{"componentChunkName":"component---src-templates-post-jsx","path":"/3-2/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","excerpt":"Process 여기부터 중요하네 ... os는 프로세스를 중심으로 관리 Process Concept program은 passive process는 active 컴퓨터내에서 돌아가는 일의 단위 실행중인 프로그램 특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름 excution stream : 한줄한줄 실행하고있는 바로 그 상태! proces…","html":"<h2>Process</h2>\n<p>여기부터 중요하네 ...</p>\n<p>os는 프로세스를 중심으로 관리</p>\n<h2>Process Concept</h2>\n<blockquote>\n<p>program은 passive</p>\n<p>process는 active</p>\n</blockquote>\n<p>컴퓨터내에서 돌아가는 일의 단위</p>\n<p>실행중인 프로그램</p>\n<p><strong>특정한 프로세스 상태를 갖는 컨텍스트 안에서 돌아가는 실행의 흐름</strong></p>\n<p>excution stream : 한줄한줄 실행하고있는 바로 그 상태!</p>\n<p>process state : 아래 참고</p>\n<p>프로그램 : 실행시키기전까지는 프로그램</p>\n<p>코드 시퀀스. 기계어의 나열</p>\n<p>프로그램을 실행시킨게 프로세스</p>\n<p>실행되서 메모리에올라가서 한줄한줄 실행중~>&#x3C;</p>\n<p>프로그램은 여러개의 프로세스가 될 수 있다. ex. 크롬 브라우저 여러개 생성</p>\n<h3>process state (= process context)</h3>\n<ul>\n<li>Memory context</li>\n<li>Hardware context</li>\n<li>System context</li>\n</ul>\n<p>0과 max는 메모리 상대주소를 가리킴</p>\n<h4>Memory context</h4>\n<ul>\n<li>text : 컴파일 되어서 기계어로 된 code와 data</li>\n<li>파일안에 이미 존재하고 있는 data : 글로벌 변수</li>\n<li>stack : 지역변수, 함수인자, 함수호출되고 리턴될 주소</li>\n<li>heap : 동적으로 할당된 data (ex. new malloc)</li>\n</ul>\n<p>(도서관 관리)</p>\n<h4>Hardware context</h4>\n<p>CPU register, I/O registers</p>\n<p>(도서관 관리)</p>\n<h4>System context</h4>\n<p>Process table, open file table, page table</p>\n<p>(책장 주변 환경 관리)</p>\n<h3>📌 Multiprogramming vs Multiprocessing</h3>\n<ul>\n<li>유니 프로그래밍 : 하나의 프로세스가 메모리에 올라간다</li>\n<li>\n<p>멀티 프로그래밍 : 메모리 관점! 메모리에 여러개가 올라가는가</p>\n<p>동시에 여러 개의 프로그램이 실행되어서 메모리안에 여러개의 컨텍스트를 올려놓은 상태</p>\n</li>\n</ul>\n<p> <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 315px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/37c023c8f9d129debbba36b90296cdd2/3c1ae/uni-multi.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 63.52941176470588%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACI0lEQVQ4y3VSaW/aQBDl/3+vqqqqEvhWIVVpqUKjBBQI5UiwCUe4CdhAodCEVm2wvYdfZ9eYS+1I9tg7M2/fzJtI9HMF0U8GTj8UEU0Y+jtGZ7GESd7U/iR6iZN4Hqfvc/RPsWQdsbNbxBMpvH4Xw6s3b3H2JY34xyQiUCYYvOsLiG4DgUlsTXKIwjW4kQfPXACLGUStDL9RAb+/A+gcj334E0unR3x6scUc60IWL1dJOF8z4L0O2MSGikkh4PVacKtluKUbuDUTbt2E+LmCR55Zj+BPS4iX35BSBgzZtzE8swQnl4JTLkBSMm8FbH3fB+u1Neg6fY515Q58bIET0LGpXA3Ip2OIYR9SeXsE/nAP1qpvE1m7DreYJfZpsG4TvHILMRoEINSBAtKPalkDzqaQznp3FWPgmwIohpMR3GYN65srOEZRXy7GoyBMbSooX6H5IeB8GsxiOYegecjVM7i9a8nrNOA9VIMZVkpgJMgBoEbDRhSizKY2OM3RMYt60ApUnW0JD3t0wRBuIQMvewmP5iyIRAioqe0DutYgmIUM1kX+WoHZox2gNQSjEXilHHizCqFW5vtsK4R/ACgJ0D5UzOccbNDdtTzoQKx+4E/qHG6edrLfBqdVCwEPGGoGU0sLI0hlTsWMVFZrtGVIY+A1A55RIPVrOicUMVB4gxmKoliK5QLy+Umz089ewf/sX7HI8aF/XOBjt2cy9PIghj2GfwEF9NPUyQaPbgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='uni multi' title='uni multi' src='/blog/static/37c023c8f9d129debbba36b90296cdd2/3c1ae/uni-multi.png' srcset='/blog/static/37c023c8f9d129debbba36b90296cdd2/e7570/uni-multi.png 170w,\n/blog/static/37c023c8f9d129debbba36b90296cdd2/3c1ae/uni-multi.png 315w' sizes='(max-width: 315px) 100vw, 315px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>멀티 프로세싱 : cpu 관점 - cpu가 여러 프로세스를 동시에 번갈아가며 처리하고있는가</li>\n</ul>\n<p> 여러 개의 프로세스가 cpu를 번갈아가며 사용하면서 실행중. cpu가 multiplexed됨</p>\n<p>cpu를 쓰려는 프로세스들을 관리할 방법이 필요하다!</p>\n<p>각각의 프로세스들을 관리하기위해 만든게 process control block</p>\n<h3>📌 Process Control Block</h3>\n<ul>\n<li>process state</li>\n<li>program counter : 몇 번째 라인을 수행중인지</li>\n<li>레지스터들</li>\n<li>\n<p>스케줄링 information</p>\n<p>등등...</p>\n</li>\n</ul>\n<p>각각의 프로세스에게 할당되어있다!</p>\n<p>os는 이 프로세스 컨트롤 블록을 보고 프로세스를 관리</p>\n<h3>📌 Process table</h3>\n<p>각각의 프로세스들의 pcb를 모아둔것들</p>\n<p>초창기 유닉스는 pcb를 array로 구현</p>\n<p>길이가 고정되어있어서 일정 길이 이상으로 늘어나지못함</p>\n<p>지금은 linked list형태로 사용중</p>\n<h3>📌 Process State (좀 더 자세하게...?)</h3>\n<p>앞에 있는건 context라고 하기로 하자...</p>\n<p>얘는 진짜 딱 프로세스의 상태</p>\n<ul>\n<li>new : 프로세스 생성</li>\n<li>running : 레디들중에 선택</li>\n<li>waiting : running중 cpu에서 나와야 할 때 (ex. I/O or event wait)</li>\n<li>\n<p>ready :</p>\n<ul>\n<li>new하고 성공적으로 만들어지면 옴</li>\n<li>러닝중 인터럽트</li>\n</ul>\n</li>\n<li>terminated : 프로세스 종료</li>\n</ul>\n<p>process life cycle</p>\n<p>큐를 사용해서 구현</p>\n<h3>📌 State Transition</h3>\n<ul>\n<li>\n<p>Ready queue</p>\n<p>말그대로 레디중인애들</p>\n</li>\n<li>\n<p>Device quete (I/O waiting queue)</p>\n<p>I/O이벤트등으로 디스크를 기다리고 있는 프로세스들... 각각의 이유별로 큐를 만들어서 따로 관리</p>\n</li>\n<li>job queue</li>\n</ul>\n<p> 시스템에 있는 모든 프로세스들을 따로 만들어놓은 큐</p>\n<ul>\n<li>이 linked list를 구현할때 그냥 pcb를 가져와서 구현함</li>\n<li>cpu에서 일하고있는 큐는 위 셋 중 어떤 큐에도 들어가있지않다</li>\n<li>시간이 다 돼서 쫓겨난 애들은 레디큐로</li>\n</ul>\n<h3>📌 Schedulers</h3>\n<p>레디큐에서 cpu로 보낼애를 선택하는 법</p>\n<ul>\n<li>\n<p>📌 Short-term scheduler (= CPU scheduler)</p>\n<ul>\n<li>어떤애를 cpu로 보낼건지!</li>\n<li>짧은 시간 간격으로 돌면서 다음애 돌 애를 지속적으로 바꿔줌</li>\n<li>밀리세컨드 이하로 반복</li>\n<li>여러개의 프로세스가 동시에 움직이는 것 같지만 사실은 밀리세커드 단위로 바뀌고 있는 것</li>\n<li>자주 호출돼서 빨라야 함!</li>\n</ul>\n</li>\n<li>\n<p>long-term scheduler (= job scheduler)</p>\n<ul>\n<li>없는 os도 있음</li>\n<li>레디큐에 넣을 프로세스들을 선별</li>\n<li>cpu scheduler가 본선느낌이라면 얘는 예선느낌</li>\n<li>하나의 컴퓨터에서 너무 많은 프로세스를 만들어버리면 pcb도 많아짐... 책장 부족!</li>\n<li>degree of multiprogramming : 멀티프로그래밍의 정도를 나눔. 프로그램 몇 개가 메모리에 있을지 결정</li>\n</ul>\n</li>\n</ul>\n<h4>📌 스케줄러를 위한 프로세스의 두 종류</h4>\n<ul>\n<li>\n<p>I/O-bound process</p>\n<ul>\n<li>I/O 요청을 처리, 대기하는데 시간이 많이 걸림</li>\n</ul>\n</li>\n<li>\n<p>CPU-bound process</p>\n<ul>\n<li>I/O는 모르겠고~ cpu를 오래써야 끝날 수 있는 프로세스</li>\n</ul>\n</li>\n</ul>\n<p> job scheduler는 저 두 개를 적절히 섞어준다</p>\n<h3>CPU Switch From Process to Process</h3>\n<h4>📌 Context switch</h4>\n<ol>\n<li>원래 돌고 있던 프로세스의 컨텍스트를 save</li>\n<li>새로 올 프로세스의 컨텍스트를 가져옴</li>\n<li>오버헤드. 스위치하는동안에는 누구도 일을 하지 않음</li>\n<li>자주 일어나면 안좋음</li>\n<li>이걸 위해 레지스터를 여러개 구비해놓기도. (책을 치우고 갈 필요가 없음)</li>\n</ol>\n<h2>📌 Process Creation &#x26; Termination</h2>\n<blockquote>\n<p>두 가지 방법 존재</p>\n<ol>\n<li>새로운 프로세스 만들기</li>\n<li>클론하기</li>\n</ol>\n<p>보통 클론</p>\n</blockquote>\n<ul>\n<li>\n<p>📌 process creation :</p>\n<ol>\n<li>disk storage에서 프로그램의 code, data를 읽어 메모리에 넣는다</li>\n<li>stack공간을 만든다(empty stack)</li>\n<li>pcb 만들고 초기화</li>\n<li>레디큐에 프로세스를 넣는다</li>\n</ol>\n</li>\n<li>리눅스는 컴퓨터 부팅될 때 첫 프로세스만 이렇게 만듦</li>\n<li>나머지 프로세스는 기존의 프로세스를 클론해서 만든다</li>\n<li>기존에 있던 메모리 공간을 그대로 복사해온다</li>\n<li>복사하고 exec()을 통해 새로운 프로그램을 메모리에 올려버린다(이걸 안하면 기존 것과 똑같은 프로그램)</li>\n<li>프로세스를 만드는 시간이 줄어든다! 개이득!</li>\n</ul>","frontmatter":{"title":"3-2 프로세스 탐구","date":"April 20, 2022","update":null,"tags":["OS"],"series":"OS"},"fields":{"slug":"/3-2/","readingTime":{"minutes":7.73}}},"seriesList":{"edges":[{"node":{"id":"ac934700-c8a1-56ac-91a7-350a3b21aa36","fields":{"slug":"/1-2/"},"frontmatter":{"title":"OS의 역할과 역사"}}},{"node":{"id":"edf85d35-a010-51bd-95cb-e4ce77cb5311","fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}}},{"node":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}}},{"node":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},{"node":{"id":"3ce6c8ef-171c-515d-8439-79b45f5e3076","fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}}},{"node":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}}},{"node":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},{"node":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}}]},"previous":{"fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}},"next":{"fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},"pageContext":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","series":"OS","previousPostId":"3ce6c8ef-171c-515d-8439-79b45f5e3076","nextPostId":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178"}},"staticQueryHashes":[]}