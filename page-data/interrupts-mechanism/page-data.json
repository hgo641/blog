{"componentChunkName":"component---src-templates-post-jsx","path":"/interrupts-mechanism/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","excerpt":"📌 Interrupt CPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재 특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다 Interrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음. cpu 내에서 일어난건…","html":"<h1>📌 Interrupt</h1>\n<p>CPU 외부에서 CPU한테 이벤트를 알려주면서 CPU를 멈추게함\n각각의 인터럽트는 cpu가 수행할 인터럽트 서비스 루틴(ISR)이 존재</p>\n<ul>\n<li>특정 인터럽트가 오면 그에 해당하는 ISR이 실행된다</li>\n</ul>\n<p>Interrupt vector : inturrupt와 ISR을 매칭시켜놓음. 모든 서비스 루틴에 대한 주소를 가지고 있음.</p>\n<p>cpu 내에서 일어난건 trap, exception이라고 부름 인터럽트랑 다르게 취급</p>\n<p>software-generated interrupt라고도 부름</p>\n<p>ex. 0으로 나누면 안되는데 0으로 나눴다던지</p>\n<p> OS는 interrupt driven 프로그램 :</p>\n<ul>\n<li>os내부의 커널은 생각보다 수동적. 밖에서 인터럽트가 들어와야 깨어나서 일을 함</li>\n</ul>\n<h2>📌 Interrupt Handling</h2>\n<p>📌 <strong>인터럽트가 오면 어떻게 하죠?</strong></p>\n<ul>\n<li>현재 프로그램을 stop한다(현재 진행중이던 instruction은 시행한다. 하던건 끝내고 스탑함)</li>\n<li>현재 cpu의 상태를 저장한다(사용하던 레지스터값, pc등)</li>\n<li>인터럽트 벡터 테이블을 통해 ISR을 알아냄</li>\n<li>ISR로 점프해서 실행</li>\n</ul>\n<blockquote>\n<p>사실 ISR이 커널의 핵심임</p>\n</blockquote>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/a0d62/timeline.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 60.58823529411765%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABzElEQVQoz5VTDW/bIBT0//9VW1dV3Sp12lqpidc0TRwbf2CwjY0NGN+evXZLmkpTn3TS44DjcTyCXnfY73dgLEGWsgWHaI/4ECEiPs8zfCSCfZzj4uoGV19vcXH5DTe3d/hxH+LTl2t8vrwm/jsK0ULUGmX1fwSZ6CCVhWjMAl4PEDSuWgdJKIljXIEVzQve5kegdcF7ZTtrMPmRMo+PRjBNE47hvYdSClJWWD2s0HYabVmifvyFJssxjHTIOEI3CoN1GIyDHx3GiWg/zRVStgB/RefoW4Xt3U+k9DAlyxZURYmnhIPvIuSiQdYapGrAA9dItUfvTgSnE0EtBbbPOzxtNtC9/nMfqkTtnmG2jxh5Bj/0sM5BdMO/Kx+LLXvoOlJKqKqiigrMThZbEmEHOGOQr9Yo1yHSOEWrexgSlNqiNn6x40xwIg8FCdYlB1uvIKgnWVpAVw1VXaHUDpbWNdYjUnRAP0GaCQNZ6zzOPVxemU7VbYeGHqPhHEIIKCHBE4aCMZi+R1tX4MQleQEpyoVzzp5WeCxorYWnsaaFmzCE7qhfyYaQ8tkWxlIk8YF+E/2qOF66Y+bP+vBV9DU8CZtKwmt9Mj9vnvE2fgN/SJz4git3qAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='timeline' title='timeline' src='/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/ca1dc/timeline.png' srcset='/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/e7570/timeline.png 170w,\n/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/f46e7/timeline.png 340w,\n/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/ca1dc/timeline.png 680w,\n/hgo641.github.io/blog/static/de5c8fac0ce540691608e1cbe21a7b61/a0d62/timeline.png 754w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>cpu는 I/O request보내놓고 할 일 계속함</li>\n<li>CPU 그래프?의 1에 해당하는 부분은 user-processing</li>\n<li>0에 해당하는 부분은 interuupt processing</li>\n<li>I/O가 response(= interrupt)를 보낼때까지 CPU는 user processing mode</li>\n<li>조금 딜레이된 이유는 하던 명령까지는 하고 끝낸다</li>\n</ul>\n<p>OS는 interrupt driven 프로그램</p>\n<h2>OS Design and Implementation</h2>\n<p>정답이 있는건아님.</p>\n<p>여러가지 os는 다 다르게 생겼다</p>\n<ul>\n<li>골을 세우고</li>\n<li>스펙을 정한다</li>\n<li>os는 하드웨어 위에서 일하기때문에 하드웨어에 종속적</li>\n<li>os는 유저에도 맞닿아있고 하드웨어에도 맞닿아있다</li>\n<li>사용하기도 쉽고 구현하기도 쉽고 유지도 쉬워야...</li>\n<li><strong>policy와 mechanism을 분리해서 설계해야한다</strong></li>\n<li>\n<p><strong>📌 Policy</strong> </p>\n<p>뭘 해야하는가! what!!!, 환경, 사용자가 어떻게 사용하는지... 뭐 그런거에 의해 변경될 수 있음</p>\n</li>\n<li>\n<p><strong>📌 Mechanism</strong></p>\n<p>어떻게 해야 하는가!, 어떤거 동작해야하는지, 기계적 how!!!, 하드웨어에 종속적</p>\n</li>\n</ul>\n<p>둘이 변경되는 상황이 달라서 구분해두는게 좋음. 유연성 증가!</p>\n<h2>OS Implementation</h2>\n<ul>\n<li>초창기 os는 어셈블리 기계어</li>\n<li>대부분의 os가 c로 설계</li>\n<li>요즘은 믹스, high-level language도 사용</li>\n</ul>\n<blockquote>\n<p>하이레벨 랭귀지 </p>\n<p>장점 : 다른 하드웨어에 포트하기쉬움, 기계어로 직접 번역되어있지않기때문에 해당 기계어로 번역 가능, 빨리 작성 가능, 간결, 이해하기 쉬움, 디버깅도 쉬움, c도 하이레벨</p>\n<p>단점 : 느림</p>\n</blockquote>\n<p><strong>사실 os의 주 성능은 하이레벨랭귀지... 사용여부보다는 policy가 더 중요</strong></p>\n<h2>OS Structure</h2>\n<ul>\n<li>Simple structure - MS-DOS</li>\n<li>More complex - Initial UNIX</li>\n<li>Layered approach</li>\n<li>Microkernel structure </li>\n<li>Hybrid</li>\n</ul>\n<blockquote>\n<p>추상화 </p>\n<p>블랙박스화, 각각의 모듈은 다른 모듈의 세부적인 내용에 대해 알 필요 없다. 서로 무슨 일 하는지, 통신만 할 수 있기만 하면 됨</p>\n</blockquote>\n<blockquote>\n<p>분리 (Decomposition)</p>\n<p>os는 거대하기때문에 모듈화</p>\n</blockquote>\n<h3>MS-DOS</h3>\n<p>윈도우가 나오기전 마이크로소프트웨어에서 만들던 os</p>\n<p>초창기 pc 운영체제</p>\n<p>모듈화가 안되어있음</p>\n<p>필수적인 기능만 존재</p>\n<p>싱글 태스크 - 싱글 유저</p>\n<p>프로그램 -> 커널 ->프로그램 형식의 단순한 형태</p>\n<h3>Initial UNIX</h3>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/04948/unix.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 61.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACVklEQVQoz42T6W7aUBCFef9HadOoVZW2UQWEkLAlNhjvgIFQICZgA8YsZvHXiyFp8q8jjWfGVz73nKNxynVH1Ot1arUaum6gaTq23cDzfGqKgmEYdLtP6KJKkoSqqjiOQ+WhknxnmibFQhGr0aTZsEgZrWdyRYVy1abwaHBX0clXNMqyxU2hRjr/KN5plCQLSW2JdKhbPapaG1n0qugV44lHxeby8jMpRAwHA/SqjH28UZbotx3m8znj8QtT32cymRBFG/4nEsBoHaELCUrhnn6ngz8es1qukgwXIevVhmW4TPr5PCAIFm9nC9G/1uNZKo7jBHkhhposY1oWdqOBoQsvj73IZsNGFeydVlPMZjKbwlNd02g2W8J7XXiv0ev1/gGuVmtaLQfXddltt/izAG8eMl0s8YMlI2+WzJPFCu88h4Llbrdns4mEJTsOh/gk+RX0fVTdJbn+ivvhmkzb56fW59oeUbRdit05mV6INwthG4EARZBgfzgzjE+gxxsSbPGQnjxuuzPyHZ9vJZ0vtzIXdwq5kkbFGpJtTxn1/sBkxC4I2A77HKJIMDyDJTW5acdmvUZqu2TULmmlTdYc8KNi8LvmkLYGpNUO17LY1SBM1Lzpi3kHKOIQhkS2zvRlxF17zMVDi+/1Hlkh72u1w5U+INMJuChZfCrbTMLTKh3iOME45gcP48OBeL1iL3wpmR3BrsVvseBXZY2rkprkrweDG7HQ15LJeLZ4A3xlmjD8IPvM3niekzV6FJwRpa5HTvwNeaufzMc+q3WZhusToCCy3+8TjL9UnnaXasqvFwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='unix' title='unix' src='/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/ca1dc/unix.png' srcset='/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/e7570/unix.png 170w,\n/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/f46e7/unix.png 340w,\n/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/ca1dc/unix.png 680w,\n/hgo641.github.io/blog/static/f958aae7cbca3ed0e5b421156437c66d/04948/unix.png 834w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<ul>\n<li>📌 시스템 프로그램과 커널을 나눔</li>\n<li>나누긴 했지만 커널은 여전히 하나</li>\n<li>굉장히 큰 커널 하나! 커널 하나에서 i/o통신, 파일 시스템, cpu스케줄링등 다 하는 중</li>\n<li>모놀리식 구조라고도 함 (커널이 하나로 이루어져있다. 단순)</li>\n</ul>\n<h3>Layered Approach</h3>\n<ul>\n<li>각각의 레이어는 자신보다 하위 계층과 소통할줄만 알면 된다</li>\n<li>📌 N이 클수록 상위. 일의 요청이 한 단계 아래로만 일어난다. 레이어1은 레이어0에게 일 요청</li>\n<li>낮을수록 하드웨어, 높을수록 사용자 인터페이스와 가까운</li>\n<li>모듈화</li>\n<li>블랙박스화됨. 각각의 레이어는 다른 레이어가 어떻게 구현되어있는지 모름. 일만 시킬줄알면됨</li>\n<li>현대 os는 레이어로 이루어져있지않음. 마이크로커널과 모듈화로 되어있음</li>\n</ul>\n<h3>Microkernel</h3>\n<p>마이크로 : 작음</p>\n<p>커널이 작다!</p>\n<blockquote>\n<p>여러 파트로 나뉘어있으나 커널 파트한테 주는게 아니라 유저 레벨 프로그램으로 만듦. 커널의 마이크로한 기능들이 <strong>유저 레벨 프로그램</strong>처럼 동작함</p>\n</blockquote>\n<ul>\n<li>커널에서 필수적인 부분을 빼고는 제외함</li>\n<li>\n<p>나머지는 유저 레벨 프로그램으로 만들어버림 </p>\n<p>(os의 일부분... 기능이지만 os 밖에서 작동)</p>\n</li>\n<li>유저 레벨 프로그램끼리는 <strong>메세지 패싱</strong>을 통해 주고받음</li>\n<li>예전에는 커널안에 같이 있어서 걍 메모리 주소 access했음</li>\n<li>메모리 카피가 일어남. 퍼포먼스 오버헤드 존재</li>\n<li>커널이 작아서 커널 업데이트하기가 쉬움, 디버깅도 당연 쉽</li>\n<li>커널을 다른 시스템에 적용하기도 쉬움. 작으니까~!</li>\n<li>reliable. 커널 안에서 돌아가는 기능이 적어지면서 원래는 커널 안의 동작이 여러군데 영향을 끼쳤는데 이젠 밖에서 일어나니까 한 부분에 문제가 발생하도 다른 프로그램에 영향을 덜 끼친다 (같은 의미에서 secure해짐)</li>\n<li>Mac OS X kernel 다윈의 한 부분이 마이크로커널로 구현됨</li>\n</ul>\n<h3>Modules</h3>\n<p>loadable kernel modules (LKM)</p>\n<ul>\n<li>기본적으로 마이크로 커널과 비슷하게 생김</li>\n<li>하나의 프로그램으로 나눈게 아니라 동적으로 탑재할 수 있는 라이브러리 형태로 나눔. 기능이 필요할 때 마다 동적으로 사용</li>\n<li>마이크로커널처럼 핵심적인 os는 적음</li>\n<li>추가적인 서비스는 커널이 동작하는동안 동적으로 로딩해서 링킹하고 사용한다</li>\n<li>실질적으로 수행할때는 하나의 커널안에서 수행되어서 메시지 패싱이 필요없음</li>\n</ul>\n<h3>Hybrid System</h3>\n<p>섞어씀 ㅎ</p>\n<p>모듈로 구성하되 특정 부분은 마이크로 ...</p>\n<p>요즘은 거의 다 섞어 씀</p>\n<h2>📌 OS Structure 시험 안나온다함 킹받네</h2>","frontmatter":{"title":"2-2 Interrupt 메카니즘","date":"March 30, 2022","update":null,"tags":["OS"],"series":"OS"},"fields":{"slug":"/interrupts-mechanism/","readingTime":{"minutes":8.47}}},"seriesList":{"edges":[{"node":{"id":"ac934700-c8a1-56ac-91a7-350a3b21aa36","fields":{"slug":"/1-2/"},"frontmatter":{"title":"OS의 역할과 역사"}}},{"node":{"id":"edf85d35-a010-51bd-95cb-e4ce77cb5311","fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}}},{"node":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}}},{"node":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},{"node":{"id":"3ce6c8ef-171c-515d-8439-79b45f5e3076","fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}}},{"node":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}}},{"node":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},{"node":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}}]},"previous":{"fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}},"next":{"fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},"pageContext":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","series":"OS","previousPostId":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","nextPostId":"a18a1199-15b8-567b-b381-9877cb7e1482"}},"staticQueryHashes":[]}