{"componentChunkName":"component---src-templates-post-jsx","path":"/4-2/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","excerpt":"Dispatcher os의 프로세스를 구동하는 부분의 가장 안쪽이다 디스패처의 역할! 어떤 프로세스를 돌리고 스탑, 상태 세이브 다른 프로세스의 스테이트를 로드해옴 switching context switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유…","html":"<h2>Dispatcher</h2>\n<p>os의 프로세스를 구동하는 부분의 가장 안쪽이다</p>\n<blockquote>\n<p>디스패처의 역할!</p>\n<p>어떤 프로세스를 돌리고</p>\n<p>스탑, 상태 세이브</p>\n<p>다른 프로세스의 스테이트를 로드해옴</p>\n</blockquote>\n<ul>\n<li>switching context</li>\n<li>switching to user mode : 디스패처가 호출되는 시점은 커널모드.(os가 수행중) 바꿔주는 역할을 다 하고 나면 새로운 프로세스로 돌아가야함(유저모드)</li>\n<li>적절한 위치로 점프 (새로운 프로세스의 실행해야할 위치, load state로 점프)</li>\n</ul>\n<p>디스패치는 사실 수동적</p>\n<h3>디스패처는 어떻게 컨트롤을 유지할 수 있을까?</h3>\n<blockquote>\n<p> cpu는 한 번에 하나의 일만 할 수 있다</p>\n<p>유저 프로세스가 실행되고 있다는 말은 디스패처가 실행되고있지않다는 말</p>\n<p>그럼 어떻게 디스패처를 컨트롤할까?</p>\n</blockquote>\n<ul>\n<li>📌 non-preemptive way : 프로세스가 디스패처를 깨워줄거라고 믿음</li>\n<li>📌 preemptive way : 디스패처가 일정시간마다 깨어나서 프로세스를 쫓아냄</li>\n<li>interrupt, traps and faults에 의해 호출됨</li>\n<li>\n<p>ex. interrupt (하드웨어)</p>\n<ul>\n<li>터미널에서 문자입력</li>\n<li>디스크에서 읽어오는거 끝남 (I/O)</li>\n<li>타이머</li>\n</ul>\n</li>\n<li>\n<p>Traps and Faults(소프트웨어) - 프로세스가 os한테 요청</p>\n<ul>\n<li>시스템 콜 : process가 os한테 어떤일을 해달라고 요청</li>\n<li>floating  : 계산불가능. os가 처리</li>\n<li>page fault</li>\n</ul>\n</li>\n</ul>\n<p>nonpremmtive는 완벽하지않음. 프로세스가 자리 안내줄수도있음. </p>\n<p>그래서 preemptive가 필요</p>\n<h2>Scheduling Policy</h2>\n<ol>\n<li>\n<p>프로세스 테이블을 스캔해서 돌 수 있는애를 앉힌다 </p>\n<ul>\n<li>시간이 오래 걸림</li>\n</ul>\n</li>\n<li>레디큐의 제일 첫번째에 있는 프로세스를 실행</li>\n<li>레디큐에서 우선순위가 높은 것을 실행</li>\n<li>우선순위를 결정하는게 policy</li>\n<li>\n<p>왜 디스패처가 하지않을까?</p>\n<ul>\n<li>policy와 mechanism을 분리하기위해</li>\n</ul>\n</li>\n</ol>\n<h2>Context Switching</h2>\n<ul>\n<li>디스패처가 기존의 state를 save하고 restore하는 것을 context switch mechanism을 통해 구현한다</li>\n<li>\n<p>다음 프로세스가 건들여서 손상을 일으킬 것 같은 모든 것을 저장한다.... 걍 웬만하면 다 저장?</p>\n<ul>\n<li>Program counter</li>\n<li>Processor status word(condtion codes 등)</li>\n<li>프로세스가 사용하던 cpu상태 정보</li>\n<li>레지스터들</li>\n<li>메모리는 정리하지않아도 될까? (책장)</li>\n<li>메모리는 저장하기에 너무 크고 비용이 큼</li>\n<li>memory management part가 별도로 담당하기때문에 context switching에서는 고려하지않는다</li>\n</ul>\n</li>\n</ul>\n<h2>Context Switching Implementation</h2>\n<p>machine... 에 따라 다른 컨텍스트 스위칭 수행존재...</p>\n<p>os마다 구현하는 방법에 따라 다름</p>\n<p>status를 메모리에 옮김</p>\n<p>메모리의 어디에? 스택 or PCB</p>\n<ul>\n<li>스택 : 프로세스가 사용하는 메모리 공간</li>\n<li>PCB : os가 사용하는 메모리 공간</li>\n</ul>\n<p>뒤에 예시 그림은 stack</p>\n<ul>\n<li>before interrupt</li>\n<li>\n<p>interrupt call</p>\n<p>수행중이던 프로세스 멈추고 prcoess status word를 넣고 그 다음 return addr(=pc)를 넣음</p>\n</li>\n<li>\n<p>PUSHA instruction</p>\n<p>책상에 있는걸 다 책장에 정리해야함</p>\n</li>\n</ul>\n<p>​\t\t레지스터 정보를 모두 스택에 저장</p>\n<p>​\t\t단 %rsp는 원래  return addr를 가리키던 n이었으나 레지스터 정보를 넣고 n-a로 업데이트된다(실제로는 n-a까지 들어갔지만 스택에는 n이 들어가버림) </p>\n<ul>\n<li>Saving stack pointer</li>\n</ul>\n<p>​\t\t<strong>그래서 %rsp는 os-PCB의 StkPtr에 저장</strong></p>\n<ul>\n<li>\n<p>Selecting Next Process</p>\n<p>scheduling policy는 OSPCBCur가 새 프로세스 OS-PCB의 StkPtr을 가리키게함</p>\n<p>OS-PCB의 StkPtr값을 CPU's StkPtr에 넣음</p>\n</li>\n<li>\n<p>POPA instruction</p>\n<p>새 프로세스의 스택에 있는 레지스터들을 전부 가져옴</p>\n<p>그 다음 return addr과 PSW도 가져온다</p>\n</li>\n</ul>\n<p>Selecting Next Process과정에서 만약 새 프로세스가 처음 생성된 애, empty 스택이라면?</p>\n<p>스택이 비었다면 디스패처 오류</p>\n<p>시스템은 처음 생성된 프로세스에게 임시로 stack에 할당해줌 디폴트값</p>\n<h2>CPU Scheduling</h2>\n<h2>Scheduling Policy</h2>\n<p>우선순위 기준점</p>\n<ul>\n<li>cpu utilization : 책상 사용량을 증대!</li>\n<li>throughput : 주어진 시간동안 몇 개의 프로세스가 일을 했냐</li>\n<li>turn around time : 특정프로세스가 일을 하고 싶은데 얼마나 자주? 보통 낮으면 좋지만 무조건적인건아님</li>\n<li>waiting time : 기다리는 시간</li>\n<li>response time : 프로세스한테 job을 요청했는데 job이 끝날때까지의 시간. 프로그램 종료를 뜻하는건 아님. 특정 동작</li>\n</ul>\n<h3>First-Come, First-Served(FCFS)</h3>\n<p>fifo라고도 불림 first in first out</p>\n<p>먼저 왔으면 먼저 내보냄</p>\n<p>문제 : 앞에 애가 엄청 오래걸리는 애인데 뒤에 애들은 몇 초만에 끝날 때-monopolize, Convoy effect</p>\n<p>해결방안 : 먼저 온 애를 먼저 앉히되, 특정 시간동안만 일하게하고 다음에 부름 - maximum time을 <strong>timeslice</strong>라고 함</p>\n<p>time slice외에 I/O요청등에 의해 내려오는 경우도 있음. 이걸 blocked됐다고 말함</p>\n<h3>Shortest Job First(SJF)</h3>\n<p>그럼 짧은 애부터 실행하자!ㅎㅎ</p>","frontmatter":{"title":"4-2","date":"April 21, 2022","update":null,"tags":["OS"],"series":"OS"},"fields":{"slug":"/4-2/","readingTime":{"minutes":6.475}}},"seriesList":{"edges":[{"node":{"id":"ac934700-c8a1-56ac-91a7-350a3b21aa36","fields":{"slug":"/1-2/"},"frontmatter":{"title":"OS의 역할과 역사"}}},{"node":{"id":"edf85d35-a010-51bd-95cb-e4ce77cb5311","fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}}},{"node":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}}},{"node":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},{"node":{"id":"3ce6c8ef-171c-515d-8439-79b45f5e3076","fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}}},{"node":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}}},{"node":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},{"node":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}}]},"previous":{"fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}},"next":{"fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},"pageContext":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","series":"OS","previousPostId":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","nextPostId":"5e929406-a010-55f2-8762-1f8c050eaf4c"}},"staticQueryHashes":[]}