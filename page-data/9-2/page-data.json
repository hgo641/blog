{"componentChunkName":"component---src-templates-post-jsx","path":"/9-2/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"0ba2b47e-2d52-512c-9a36-4c8bab1a7d0a","excerpt":"Symmetric Encryption의 문제 어떻게 secure채널을 통해서 안전한 키를 전달하지? 전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다 만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : …","html":"<h4>Symmetric Encryption의 문제</h4>\n<ul>\n<li>어떻게 secure채널을 통해서 안전한 키를 전달하지?</li>\n<li>전자서명이 있으면 쉽게 해결되나 대칭키만 가지고는 해결할 수 없는 nonrepudiation</li>\n<li>\n<p>CBC-MAC이 존재하긴하나 Integrity와 Authentication만 보증한다</p>\n<blockquote>\n<p>만약 A가 B에게 100만원을 준다는 문서를 주었으나 A가 주지않았을 때 : </p>\n<p>B가 CBC-MAC을 통해 받은 Ciphertext를 key로 복호화해서 A로부터받았음을 확인</p>\n<p>B가 법정에서 증거를 제출하려면 받은 Plaintext와 key와 MAC(Message Authentication)을 제공</p>\n<p>key는 secure하게 보관되어야하므로 A와 B만 가지고있다</p>\n<p>그러나 이 Plaintext가 정말 A가 보낸건지 B가 key를 사용해서 임의로 만든건지 구분할 수 없다</p>\n<p>즉, key가 최소 두 명이상한테 공유되었기때문에 누가 쓴건지 구별이 불가능하다.</p>\n<p>key는 single claimed sender를 가져야한다. 보낸이한테만 유일한 키</p>\n</blockquote>\n</li>\n</ul>\n<h2>Public-Key Cryptosystems</h2>\n<p><code class=\"language-text\">Plaintext</code> -> <code class=\"language-text\">Public key</code> -> <code class=\"language-text\">Encryption algorithm</code></p>\n<p><code class=\"language-text\">Ciphertext</code> -> <code class=\"language-text\">Private key</code> -> <code class=\"language-text\">Decryption algorithm</code></p>\n<h4>Encryption with public key : 메세지를 숨기고 싶을 때</h4>\n<ul>\n<li>누구의 퍼블릭 키, 누구의 프라이빗 키인지가 중요하다</li>\n<li>Bob이 Alice에게 암호문을 보낼 때, Alice의 퍼블릭키를 사용해서 암호화</li>\n<li>Alice는 받은 암호문을 Alice의 프라이빗키를 사용해 복호화한다 </li>\n</ul>\n<blockquote>\n<p>키 분배 문제 해결 </p>\n<ul>\n<li>키 분배 문제 : 어떻게 key를 안전하게 교환할 것인가</li>\n<li>Public-Key는 A가 Key pair를 생성하면 공개키를 모두에게 공개</li>\n<li>굳이 안전하게 전달할 필요가 없음</li>\n</ul>\n</blockquote>\n<h4>Encryption with private key : 전자서명</h4>\n<ul>\n<li>Private key를 가지고 Encryption : 전자서명에 해당</li>\n<li>Encryption algorithm == Signature Generation</li>\n<li>Decryption algorithm == Signature Verification</li>\n<li>Bob이 Alice에게 암호문을 보낼 때, Bob의 Private key를 사용해서 암호화</li>\n<li>Alice는 받은 암호문을 Bob의 Public key를 사용해서 복호화</li>\n<li>서명을 해서 보냄. 받아서 복호화한 Plaintext와 서명이 잘 맞아 떨어진다면 중간에 오류나 변조없이 도착한 것임 : Integrity 보장</li>\n<li>Bob의 Privae key를 통해서 온 것이므로 nonrepudiation 해결</li>\n</ul>\n<h3>Conventional and Public-Key Encryption</h3>\n<ul>\n<li>conventional : 전통적인 (= Symmetric)</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Conventional Encryption</th>\n<th align=\"center\">Publick-Key Encryption</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">같은 알고리즘이 <strong>같은 키</strong>와 사용된다 (AES같은 경우엔 완전히 같진않고 역연산)</td>\n<td align=\"center\">두 개의 키가 존재한다 하나는 Encryption에 다른 하나는 Decryption에 사용</td>\n</tr>\n<tr>\n<td align=\"center\">보내는 사람과 받는 사람이 알고리즘과 키를 공유한다</td>\n<td align=\"center\">알고리즘은 서로 공유하나 보내는 사람과 받는 사람이 같은 키가 아닌 키 pair를 사용한다</td>\n</tr>\n<tr>\n<td align=\"center\">대칭 암호에서는 키가 안전하게 유지되어야한다</td>\n<td align=\"center\">공개키는 안전하게 전달 될 필요가 없다</td>\n</tr>\n<tr>\n<td align=\"center\">키가 안전하게 유지되고 있다면 메세지를 키 없이 복호화하는게 어렵다</td>\n<td align=\"center\">키 중에 하나가 Private Key)가 안전하게 유지되고 있다면 메세지를 복호화하는게 어렵다</td>\n</tr>\n<tr>\n<td align=\"center\">알고리즘을 알고 Cipher text를 몇개를 알아도(암호문쌍) 어떤 키가 사용됐는지 알아내는게 어렵다</td>\n<td align=\"center\">알고리즘을 알고 공개키하나도 알고 Ciphertext(암호문쌍)을 알아도 private key를 알아내긴 어렵다</td>\n</tr>\n</tbody>\n</table>\n<h3>Public-Key Cryptosystem</h3>\n<ul>\n<li>Authentication and Confidentiality</li>\n<li>Source A, Destination B 일 때</li>\n<li>\n<ol>\n<li>A가 자신의 Private key를 가지고 서명</li>\n<li>A가 B의 Public key를 가지고 암호화</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>B가 자신의 Private key를 가지고 복호화</li>\n<li>B가 A의 Public key를 가지고 A가 맞는지 확인</li>\n</ol>\n</li>\n</ul>\n<h4>Public-key cryptosystems can be classified into three catagories:</h4>\n<ul>\n<li>Encryption/Decryption</li>\n<li>Digital Signature</li>\n<li>\n<p>Key exchange</p>\n<ul>\n<li>공개키 쓴다고 symmetric 암호 안쓰는 건 아님</li>\n</ul>\n</li>\n</ul>\n<h4>Public-Key Requirements</h4>\n<ul>\n<li>수신자가 키 페어를 만들기 쉬워야함</li>\n<li>퍼블릭 키와 메세지를 사용해서 ciphertext를 만드는 일이 쉬워야함</li>\n<li>프라이빗 키와 cipher text를 사용해서 plaintext를 만드는 일도 쉬워야함</li>\n<li>퍼블릭 키를 알고있어도 프라이빗 키를 추측하는건 어려워야함</li>\n<li>퍼블릭 키와 ciphertext를 알아도 private key없이 plain text를 추측하는건 어려워야함</li>\n</ul>\n<h2>RSA(Rivest-Shamir-Adleman) Algorithm</h2>\n<ul>\n<li>PU = {e, n}</li>\n<li>PR = {d, n}</li>\n<li>암호화는 e를 사용해서, 복호화는 d를 사용해서 함</li>\n<li>두 개다 mod n을 사용해야함. n은 권장사항이 2048 bit이상이며 보통 3072, 4096사용</li>\n</ul>\n<p> ex ) Bob -> Alice에게 암호문을 보낼 때</p>\n<ul>\n<li>\n<p>Key Generation by Alice</p>\n<blockquote>\n<p>Select p, q : p and q both primte p!=q</p>\n<p>Calculate n = p x q</p>\n<p>Select integer e (e는 오일러(n)과 서로소여야함)</p>\n<p>이후 구할 d때문. e x d = 1 mod 오일러(n)</p>\n</blockquote>\n</li>\n<li>\n<p>Encryption by Bob with Alice's Public Key</p>\n<blockquote>\n<p>Plain text = m, m은 n보다 작은 숫자의 범위</p>\n<p>C = M^e mod n</p>\n</blockquote>\n</li>\n<li>\n<p>Decryption by Alice with Alice's Private Key</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/3ee8a281b7266d96e0200c9a71c4f474/994d6/enc_dec.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.35294117647058%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAADAUlEQVQ4yy1T2W7TQBTN//8CEhISEjwgxKJCFyduktoT24m38XiPszUQ2jSx2wASQjocmz6MruVrHZ9tenk2h+/78F0XiechEibs8QjW8BpGX4O4OMdsOoXLnZSyO2GgIP0It9UG2+UW29UWO85dnKNX5guE7gyedolC11AZI5TVAvOyQJrECFsA24J0bKRxjDRNEUcpxGiCkTaEpd9gdKVjeHWNjUzQK1qGYYCZaUJ9/gApDERRhCRJkBUFivbkOXLO9iRZBtcQEJ/OMLvsIzy/gBIOtpt7nB7/EDCvOsm2bUNeXSAbXSMxb5ApgjoW1HiIzBKI+U3kuYhjhYhyPU2H7OtwCarGArvtvjsdYBCGBLSQ6n2sWtkTE8vRAOnZRwQf38PjT1owxZNQtu9FcAwHglLNSx1lWtGGHJvV7pkhTbfGY5SUuxxcYaGdY2mOkV5+RTDQEHCfUnY5n5NhjBXD+H36izvadV8sGcg3bLIFHu4a9NqUPceBfXODKAg6BjE9zchaXXyBRxs6ZmnW7dqUl+UKTzMPj7sDnn4c0YQRHvePqA8/0avKNQJ6IqVCGCrKZ7JBhNAPId0AcuYj9MLuneTe8yU2ZHgiSM1Zsy41VdaHX6gfTv9TbhNNycBlMIauYzLow9YHsM8+Y8pj9PuQ7GFO2cnMYT1iPBGkma/RrHdoKLXZn54BuVBM1KHshLNgijm7VrKD1asXqF6/xHw2RcFd5VM67VgtyHD9HTVlN2TcrPhMBcft/XOxgxCmKRBwplmOOElZ4gTl2SdEb14je/cWFf2M6WsgIwLe4rR/Qk0L6mKB+vYOzcNPHFuGZb5kDwOWWcGxpxAsrSUsWBMLEz7bYgJb0+ANR/Q5hktWa6Z6YiBH+l4zoI7h9g5H/uS/h2lCdgFcynZ5Y3xOL/Dh8l5L00DIu6149coshWpr0zJsfaPMpqKPtz9Qb3Zk2AFWkJGEEKL7uCjLzvz2uhXXfSQMKDfGnY8Z3ymlsJiT1fE39t8POLA2x92xmwdK/gfyE9GAGSrJ9wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='enc dec' title='enc dec' src='/static/3ee8a281b7266d96e0200c9a71c4f474/ca1dc/enc_dec.png' srcset='/static/3ee8a281b7266d96e0200c9a71c4f474/e7570/enc_dec.png 170w,\n/static/3ee8a281b7266d96e0200c9a71c4f474/f46e7/enc_dec.png 340w,\n/static/3ee8a281b7266d96e0200c9a71c4f474/ca1dc/enc_dec.png 680w,\n/static/3ee8a281b7266d96e0200c9a71c4f474/02d09/enc_dec.png 1020w,\n/static/3ee8a281b7266d96e0200c9a71c4f474/994d6/enc_dec.png 1093w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<blockquote>\n<p>C^d mod n == (M^e mod n)^d mod n</p>\n<p>-> M^ed mod n</p>\n<p>(ed = k x 파이(n) + 1 mod n) : d는 e의 곱셈의 역원</p>\n<p>((M^파이(n))^k x M )mod n</p>\n<p>오일러 이론에 의해 (M^파이(n))^k 는 1이 된다</p>\n<p>M mod n = M S: M이 n보다 작으므로 </p>\n</blockquote>\n</li>\n</ul>\n<h4>Example of RSA Algorithm</h4>\n<blockquote>\n<p>p = 11, q = 17</p>\n<p>n = p x q = 187</p>\n<p>∮(n) = (p-1)(q-1) = 160</p>\n<p>e = 7 (160과 서로소인 수)</p>\n<p>d = 23 ( e*d를 mod 160했을 때 1이 나옴. d는 e의 곱셈의 역원)</p>\n<ul>\n<li>plaintext는 n(187)보다 작은 숫자</li>\n</ul>\n</blockquote>\n<h3>RSA Signature</h3>\n<blockquote>\n<p>Decryption : Signature generation</p>\n<p>Encryption : Signature Verification</p>\n</blockquote>\n<ul>\n<li>\n<p>Alice 가 Bob에게 보낼 때 Alice가 자신의 private key로 Signature generation을 한다. (M, S)를 전달</p>\n<ul>\n<li>M은 메시지</li>\n<li>S는 서명한 M (M^d mod n)</li>\n</ul>\n</li>\n<li>\n<p>Bob 은 받은 S를 Alice의 public key(e)를 사용해서 Signature Verification을 한다</p>\n<ul>\n<li>S ^ e mod n = M</li>\n</ul>\n</li>\n</ul>\n<h3>Left to Right binary</h3>\n<p><strong>Square and Multiply라고도 불림</strong></p>\n<p>a^b mod n</p>\n<ul>\n<li>\n<p>for k부터 0까지 루프를 돈다</p>\n<ul>\n<li>k는 b의 비트수 (bk ~ b0)</li>\n<li>예제의 경우 bit수가 10개이므로 k는 9~0</li>\n</ul>\n</li>\n<li>\n<p>c는 현재 a의 몇 제곱인지를 알려줌(10진수). </p>\n<ul>\n<li>b의 bit를 10001까지 수행했을 경우 10001은 10진수로 17 = c </li>\n<li>결과값에는 영향을 주지 않음. (지워도 상관없음. 이해를 돕기위한 값)</li>\n</ul>\n</li>\n<li>f의 initial은 1</li>\n<li>f는 (a의 bi제곱 mod n)을 의미</li>\n<li>f는 일단 제곱을 무조건 시킴  + (c = cx2)</li>\n<li>\n<p>해당 bit인 bi가 1일 경우</p>\n<ul>\n<li>c = c+1</li>\n<li>f 에 a를 곱함</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>운이 좋을 경우 (1000000)</p>\n<p>: 제곱만 수행 (곱셉 연산 한 번)</p>\n<p>운이 나쁠 경우 (1111111)</p>\n<p>: 제곱과 곱하기를 수행 (곱셈 연산 두 번)</p>\n<p>지수 e가 2048일 경우</p>\n<p>즉, 총 log2 n ~ 2logn 의 연산을 수행</p>\n<p>(2048 ~ 4096)</p>\n<p>평균적으로 3/2 log2n (3072)</p>\n<p>만약 이렇게 로그에 기반해서 연산안하고 바로 a x a x a x ...a 했다면 2^2048번의 연산을 수행해야한다고함</p>\n</blockquote>\n<h3>Efficient Operation Using the Public Key</h3>\n<p>근데 저렇게 해도 숫자가 너무 커서 오래걸림</p>\n<p>그래서 e를 2^16 +1로 고정</p>\n<p>어차피 공개키라 고정해도 상관없음</p>\n<p>2^16 +1하면  제곱 16번 + bit 1인게 두개라서 2번 곱셈</p>\n<p>가끔 3이나 17같은 엄청 작은 숫자를 쓰기도 하나 공격에 취약할수도있음</p>\n<p>d는 프라이빗이라 고정해놓으면 안됨</p>\n<h3>RSA의 안전성</h3>\n<ul>\n<li>\n<p>Brute force</p>\n<ul>\n<li>d에 모든 값 대입 </li>\n<li>2048가지의 경우 존재 너무 오래걸림</li>\n</ul>\n</li>\n<li>\n<p>Mathematical attacks</p>\n<ul>\n<li>소인수 p와 q의 쌍을 구하려함</li>\n</ul>\n</li>\n<li>\n<p>Chosen ciphertext attack</p>\n<ul>\n<li>RSA의 구조적인 특성을 이용한 공격</li>\n</ul>\n</li>\n</ul>\n<h3>Factoring Problem</h3>\n<ul>\n<li>n으로 p, q두 쌍을 구할 수 있으면 RSA는 깨짐</li>\n</ul>\n<h2>Chosen Ciphertext Attack (CCA)</h2>\n<ul>\n<li>공격자가 Plain text와 Cipher text의 쌍을 알 때 private key없이 어떤 Cipher text의 Plain text를 추측할 수 있는 것</li>\n<li>공격자가 어떤 C에 대한 P를 물어봐서 P를 얻어냄</li>\n<li>이를 바탕으로 또 다른 C를 물어보지않고도 P를 추측</li>\n<li>\n<p>ex</p>\n<blockquote>\n<p>C의 P를 구하고자 할 때</p>\n<p>C' = C x 2^e mod n</p>\n<p>C'의 P를 요청함</p>\n<p>P' = C'^d mod n =  (C x 2^e)^d mod n = C^d x 2 mod n</p>\n<p>즉 C의 P는 P'에 2의 역원을 곱하면 된다</p>\n</blockquote>\n</li>\n</ul>\n<p>이런 공격을 방지하기 위해 RSA에 특별한 구조를 넣게 되어있음 RSA Security- OAEP</p>\n<p>안전성때문에 RSA-OAEP 사용</p>\n<h3>OAEP</h3>\n<p>뭐라는겨 </p>\n<p>MGF != MGF</p>\n<h2>Side Channel Attack</h2>\n<p>implementation attack</p>\n<p>알고리즘을 실행시키고있는 기계 자체를 공격</p>\n<p>알고리즘을 실행하면 기계에서 부수적인 정보가 나옴</p>\n<ul>\n<li>Timing attack : 누군가 private key를 가지고 연산을 하고있을 때 private key에 따라 연산 시간이 달라질수도있다</li>\n<li>\n<p>Power analysis : 전력 소모의 패턴을 분석. 제곱연산할때의 전력소모와 곱셈 연산을 할 때 전력소모를 구해서 분석. (전자기파 분석, 클라우드 분석)</p>\n<ul>\n<li>1이면 S M , 0이면 S</li>\n</ul>\n</li>\n</ul>\n<p>어떻게 막나?</p>\n<ul>\n<li>\n<p>Constant-time algorithm</p>\n<ul>\n<li>알고리즘을 비트가 0이냐 1이냐에 따라서 바뀌지않게 만든다</li>\n<li>M을 항상 하게 바꿈</li>\n<li>1이냐 0이냐에 따라 X[0] or X[1] 반환</li>\n<li>시간이 더 오래 걸리긴 함(필요없는 M도 하게 되어서)</li>\n<li>시간분석 대응가능. 일정한 시간 소요</li>\n</ul>\n</li>\n</ul>\n<h3>Fault-Based Attack</h3>\n<p>좀 더 공격적</p>\n<p>아까는 공격자가 그냥 관찰만</p>\n<p>연산이 수행되는 와중에 강력한 전압을 걸어주는등의 공격을 해서 오류가 생기게</p>\n<h3>Misconceptions Concerning Public-Key Encryption</h3>\n<ul>\n<li>공개키 알고리즘은 암호 공격에 대해서 시메트릭 암호보다 안전하다</li>\n</ul>\n<p>맞을수도있고 틀릴수도있음</p>\n<p>AES 128비트 버전과 RSA 2048 어떤게 더 안전할까?</p>\n<p>RSA가 시도할 경우의 수가 더 많음</p>\n<p>그러나 이렇게 무작위로 하지않음</p>\n<p>팩토링을 사용하면 효율적으로 가능. AES보다 더 빠르게</p>\n<p>공격할 방식 자체가 다르기 때문에 맞을수도있고 틀릴수도있음</p>\n<ul>\n<li>\n<p>공개키 알고리즘이 대칭 알고리즘을 완벽하게 대체할 수 있는 알고리즘이다</p>\n<p>x : 성능 측면에서 대칭 알고리즘이 훨씬 유리</p>\n<p>키 공유 문제에선 공개키 알고리즘이 유리</p>\n<p>하이브리드 알고리즘이 다수</p>\n</li>\n<li>\n<p>대칭 암호의 키공유문제를 해결하기 위해 나온게 공개키 알고리즘 : 공개키 암호를 쓰면 키 분배를 하는데 전혀 문제가 없을까?</p>\n<p>x : 상대적으로 대칭 암호에 비해 키 공유가 나은 것이지 근본적으로 해결되는 것은 아니다</p>\n<p>시메트릭 : 키를 안전하게 전달하는 것이 목표</p>\n<p>퍼블릭키 : 키를 숨기면서 전달할 필요가 없음. </p>\n<p>대칭 암호에서의 키 분배는 confidentialiry</p>\n<p>퍼블릭키는 authentication과 Integrity 보장해야함</p>\n<p>공격자가 다른 사람의 공개키인척 공유하면 안됨</p>\n<p>이런 문제때문에 공개키 인증서가 나옴</p>\n<p>정부에서 공인된 절차로 만든게 공인인증서</p>\n</li>\n</ul>\n<p>RSA에서 Factoring과 Discrete Logarithm(이산대수)이 중요하다...</p>","frontmatter":{"title":"9-2","date":"May 01, 2022","update":null,"tags":["computer protection"],"series":"컴퓨터 보안"},"fields":{"slug":"/9-2/","readingTime":{"minutes":14.635}}},"seriesList":{"edges":[{"node":{"id":"2f0042b0-4265-503d-bfb4-2f652be20247","fields":{"slug":"/cia-aa/"},"frontmatter":{"title":"1-1 컴퓨터 보안의 요구 조건 (CIA + AA)"}}},{"node":{"id":"12f645a6-a211-5998-802c-e24e800a9749","fields":{"slug":"/1-2/"},"frontmatter":{"title":"1-2 Access Control"}}},{"node":{"id":"219bd0e4-f5da-56b8-a631-177affc7a1f3","fields":{"slug":"/osi-structure/"},"frontmatter":{"title":"1-1 OSI 보안 구조"}}},{"node":{"id":"80496429-296e-5a3f-94fc-c1b5ac97e58b","fields":{"slug":"/2-2/"},"frontmatter":{"title":"2-2 Number Theory"}}},{"node":{"id":"1729eca4-79ba-505d-ad14-fe712b97b487","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 Symmetic Cipher Model (고전 암호)"}}},{"node":{"id":"392efc96-264f-5e10-b897-275865998fc5","fields":{"slug":"/5-1/"},"frontmatter":{"title":"5-1 Web Hacking Overview"}}},{"node":{"id":"efb55f6c-c7dd-549c-a0c8-bd32a55900f2","fields":{"slug":"/5-2/"},"frontmatter":{"title":"5-2 AES Process"}}},{"node":{"id":"f1fc1120-6efe-5c82-a468-e7b606dd5201","fields":{"slug":"/6-2/"},"frontmatter":{"title":"6-2 Modes of Operation"}}},{"node":{"id":"54cac675-2244-593f-8885-8e87b47f4d60","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1 다양한 보안 위협"}}},{"node":{"id":"8973c651-be66-5cbd-bed0-8034d04287eb","fields":{"slug":"/7-2/"},"frontmatter":{"title":"7-2 난수 생성"}}},{"node":{"id":"7078702e-cebc-5504-8b08-84848cf80eca","fields":{"slug":"/finite-field/"},"frontmatter":{"title":"4-2 finite field (Galois Field)"}}},{"node":{"id":"d0c7c15f-daf7-51ff-a6a8-bc9aa5dc632a","fields":{"slug":"/steam-block/"},"frontmatter":{"title":"4-2 Stream Cipher와 Block Cipher"}}},{"node":{"id":"3230e19c-884d-5de9-bd84-bd379aec8b3d","fields":{"slug":"/7-1/"},"frontmatter":{"title":"7-1 DoS attack"}}},{"node":{"id":"6f2caa92-9f2e-5880-b7b5-907163e69325","fields":{"slug":"/9-1/"},"frontmatter":{"title":"9-1"}}},{"node":{"id":"0ba2b47e-2d52-512c-9a36-4c8bab1a7d0a","fields":{"slug":"/9-2/"},"frontmatter":{"title":"9-2"}}},{"node":{"id":"e804d575-1a68-5078-99af-828d5a23d25a","fields":{"slug":"/10-1/"},"frontmatter":{"title":"10-1"}}}]},"previous":{"fields":{"slug":"/9-1/"},"frontmatter":{"title":"9-1"}},"next":{"fields":{"slug":"/LoginView/"},"frontmatter":{"title":"Django LoginView 사용"}}},"pageContext":{"id":"0ba2b47e-2d52-512c-9a36-4c8bab1a7d0a","series":"컴퓨터 보안","previousPostId":"6f2caa92-9f2e-5880-b7b5-907163e69325","nextPostId":"71a681c8-2fc0-5652-ba2c-5ad25267c318"}},"staticQueryHashes":[]}