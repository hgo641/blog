{"componentChunkName":"component---src-templates-post-jsx","path":"/15/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"e41df5b8-30c6-54fe-88c9-1d212c70c9f4","excerpt":"Working-Set Model 어떤 프로세스의 워킹셋은 어떻게 구할까? reference bit을 사용한다 페이지가 접근될때마다 r-bit을 1로 바꿔줌 1인 애들을 모아 워킹셋을 만듦 t1이 지나면 1을 0으로 초기화 워킹셋을 델타시간때마다 구할 수 있다 델타가 커지면 워킹셋을 구하기 애매 ex) 10000일 때 5000time으로 나누고 각 페이지마…","html":"<h2>Working-Set Model</h2>\n<p>어떤 프로세스의 워킹셋은 어떻게 구할까?</p>\n<p>reference bit을 사용한다</p>\n<ul>\n<li>페이지가 접근될때마다 r-bit을 1로 바꿔줌</li>\n<li>1인 애들을 모아 워킹셋을 만듦</li>\n<li>t1이 지나면 1을 0으로 초기화</li>\n</ul>\n<p>워킹셋을 델타시간때마다 구할 수 있다</p>\n<p>델타가 커지면 워킹셋을 구하기 애매</p>\n<p>ex)</p>\n<p>10000일 때 5000time으로 나누고</p>\n<p>각 페이지마다 r-bit 2bit준비</p>\n<p>페이지가 access되면 1st rbit에 1을 넣음</p>\n<p>interrupt가 들어오면 1st rbit을 2nd rbit에 옮겨 닮고 1st를 초기화</p>\n<p>interrupt이후 access된 메모리의 1st를 1로 만듦</p>\n<p>1st와 2nd에 있는 애들을 워킹셋에 추가함</p>\n<p>조금 더 작은 단위로 조사할 수 있다...</p>\n<p>더 자세하게 하고싶으면 더 세분화로 나눔... + r  bit많이 추가.</p>\n<p>단, 페이지마다 rbit을 관리해줘야해서 비용이 커짐</p>\n<h2>Page-Fault Frequency</h2>\n<p>허용 가능한 수준의 PFF(page fault frequency)를 사전에 정함</p>\n<p>local replacement policy를 통해서 프로세스마다 할당하는 프레임을 변경시킨다</p>\n<ul>\n<li>actual rate가 낮으면 frame수를 낮춤</li>\n<li>actual page fault rate가 크면 frame수를 높임</li>\n</ul>\n<p>-> PFF가 적절하게 조절될 수 있음</p>\n<p>단점 : 프로세스가 많아지면 모든 프로세스가 가져갈 수 있는 프레임수가 줄어든다</p>\n<p>사실 가장 근본적인 해결책은 메인 메모리를 많이 꽂아주는거</p>\n<p>그러나 메인 메모리도 늘어나는데 한계가 있다</p>\n<p>리눅스의 경우, pagefault가 많이 일어나면 특정 프로세스를 죽임 - OOM killer</p>\n<ul>\n<li>가장 많은 공간을 얻을 수 있는애를 죽임</li>\n<li>OOM_SCORE : 높을수록 메모리 회수를 많이 할 수 있음</li>\n</ul>\n<h2>Allocating Kernel Memory</h2>\n<p>커널 메모리는 미리 메모리 풀을 할당해놓음</p>\n<p>왜 커널은 따로 관리?</p>\n<p>커널 메모리 공간중에 일부는 연속적일 필요가 있다.</p>\n<p>ex) device io를 위한 메모리공간</p>\n<p>일반적으로 커널은 메모리allocation함수를 자주 호출한다</p>\n<p> allocation할 때마다 internal fregmentation이 많이 발생할수도 </p>\n<p>그래서 커널은 미리 많이 떼어두고 그 안에서 작게 작게 잘라서 준다</p>\n<p>어떻게 잘라서 줄까?</p>\n<h3>Buddy System Allocator</h3>\n<p>커널을 위해서 연속된 공간을 할당받아둠</p>\n<p>미리 할당 받은 공간을 이진 바이너리 처럼 관리</p>\n<p>특정한 함수가 공간을 할당해달라고 하면 그 공간의 크기가 될때까지 계속 반으로 나눔</p>\n<p>ex) 총 256KB인데 32KB 공간을 할당해달라는 요청이오면, 256 -> 128 2개 -> ... 32가 나올때까지 반으로 나눈다 (나머지는 free영역으로 관리)</p>\n<p>다음에 어떤 메모리 요청이 오면 그거에 맞는 공간을 할당해주기 쉬움 (여러 크기로 나눠져있는 상태)</p>\n<p>세분화 &#x26; 합치는게 빠름</p>\n<p>internal fragmentation이 심할수도</p>\n<ul>\n<li>아무리 잘게 쪼개도 2의 제곱 형태</li>\n</ul>\n<p>메모리를 항상 2의 제곱형태로 관리</p>\n<h3>Slab Allocator</h3>\n<p>커널은 하나의 큰 메모리 공간을 할당 받음 : kernal mem</p>\n<p>kernal mem을 multiple slab으로 나눔</p>\n<p>각각의 slab은 multiple pages로 구성됨</p>\n<ul>\n<li>연속된 contiguous page</li>\n</ul>\n<p>slab마다 다른 size의 object를 관리한다</p>\n<p>Cache</p>\n<ul>\n<li>하나나 그 이상의 slab으로 이루어짐</li>\n<li>자주 사용되는 data</li>\n<li>특정한 사이즈의 오브젝트만 사용할 수 있는 메모리 공간</li>\n<li>컴퓨터 구조에서 배우는 캐시랑 다른 애임 (slab allocator에서 사용되는 캐시)</li>\n<li>커널 데이터를 위해 미리 캐시만큼 할당해놓음</li>\n<li>object 생성 요청이 들어오면 해당 크기만큼의 캐시를 찾아 하나 매핑해줌</li>\n<li>캐시는 처음부터 크게 잡지않음</li>\n<li>캐시가 꽉차면 빈 slab하나를 더 가져와서 캐시 크기를 늘린다</li>\n</ul>\n<p>장점</p>\n<p>fragmentation이 없음</p>\n<ul>\n<li>slab단위로 캐시에 할당</li>\n<li>캐시안을 실제 커널에서 사용하는 메모리 사이즈로 줄여둬서 internal fragmentation 안생김</li>\n<li>external은 있을수도있음</li>\n</ul>\n<p>메모리 request를 할 때도 해당하는 size들이 캐시에서 할당받은 것이기 때문에 그 주소만 받아오면 바로 사용할 수 있다 &#x3C;뭔소리?</p>\n<p>따라서 fast memory request satisfaction이 가능하다</p>\n<h2>I/O Devices</h2>\n<p>지금까지는 cpu, 메모리에서 os가 해줘야할거 배움</p>\n<p>  Many I/O device도 있다...</p>\n<p>피씨에 장착이 됨</p>\n<p>Port : 디바이스와 프로세스를 연결하는 포인터</p>\n<ul>\n<li>포트는 제한적</li>\n<li>포트에 expansion bus interface를 연결해서 하나의 포트를 여러개로 나눌 수 있음. 나눠진 거에 추가적으로 컴포넌트 연결 가능 (느린 device일 경우 가능)</li>\n</ul>\n<p>Bus : 포트들을 프로세스와 연결</p>\n<ul>\n<li>shared bus</li>\n<li>daisy chain(직렬 연결) : device to device</li>\n</ul>\n<p>Controller</p>\n<ul>\n<li>호스트 어댑터라고도 함</li>\n<li>I/O 디바이스를 컨트롤함</li>\n<li>I/O디바이스 자체에 장착되기도 하고 GPU같은 경우는 메인보드에 별도로 장착</li>\n<li>또 다른 작은 컴퓨터, 간단한 프로세싱을 할 수 있는 프로세서와 메모리, 컨트롤러가 있음</li>\n</ul>\n<h3>I/O Hardware</h3>\n<p>컨트롤러에는 레지스터들이 있다</p>\n<ul>\n<li>status reg : busy(1bit)</li>\n<li>control reg : 명령어가 들어감</li>\n<li>data -in/ -out : 시스템으로 들어오는/호스트가 디바이스한테 보내주는 데이터</li>\n</ul>\n<p>status, control reg같은 경우는 적은 byte에 저장(1-4), data-in, out같은 경우는 여러 개의 데이터를 FIFO buffer를 이용해서 여러 개의 데이터를 동시에 보관</p>\n<p>큰 동작</p>\n<p>cpu가 status reg 값 확인(놀고있나 일하고있나)</p>\n<p>놀고있으면 control reg한테 일해달라고 요청</p>\n<p>cpu한테 전달할 data가 있으면 data-in reg에 값을 써둠</p>\n<p>레지스터들을 통해서 디바이스와 호스트 프로세스간의 소통이 이루어짐</p>\n<p>각각의 레지스터를 지칭할 주소가 필요</p>\n<p>주소는 어떻게 관리?</p>\n<p>Memmory-mapped I/O - 메모리를 따로 빼두고 씀</p>\n<ul>\n<li>사용하는 레지스터 공간이 클 때 사용</li>\n<li>일반적으로 port- mapped io 사용</li>\n</ul>\n<p>Port-mapped I/O - 포트별로 관리</p>\n<h2>Polling and Interrupt</h2>\n<h3>Polling</h3>\n<p>호스트가 일을 시키는데 아이오 디바이스가 일을 완료하는데 시간이 오래걸림</p>\n<p>디바이스가 직접 알려주지않고 호스트가 매번 일이 됐는지 확인하는게 폴링</p>\n<p>handshaking</p>\n<ul>\n<li>\n<p>host cpu는 io device controller 한테 일을 시키기전에 busy bit 확인</p>\n<ul>\n<li>1이면 기다림 0이면 일을 시킬 수 있음 (지속적으로 확인) &#x3C;- polling</li>\n<li>디바이스가 느리면 자주 확인해야함</li>\n<li>확인하는 정도를 잘 조절해야함</li>\n</ul>\n</li>\n<li>controller reg한테 read인지 write요청인지 써둠 (write일 경우 어떤 data가 나가는지도 data-out reg에 함께 써둠, 주소도 같이 전달)</li>\n<li>일을 시키고자 하는 정보들이 전부 전달이 됐으면 command-ready bit을 1로</li>\n<li>i/o컨트롤러는 커맨드 레디 비트가 1이되면 busy bit을 1로 만들어줌</li>\n<li>커맨드에 해당하는 transfer를 수행</li>\n<li>모든 data transfer이 끝나면 busy bit, error bit, command-ready bit 을 0으로</li>\n</ul>\n<h3>Interrupts</h3>\n<blockquote>\n<p>폴링은 하는데 3개의 명령어만 필요</p>\n<ul>\n<li>status reg로부터 값을 읽음</li>\n<li>읽은 bit중에 ready bit에 해당하는 부분만 &#x26;를 사용해서 뽑음</li>\n<li>1인지 0인지 판단</li>\n</ul>\n</blockquote>\n<p>간단하지만 문제는 이걸 자주 해야함</p>\n<p>그래서 interrupt 사용</p>\n<p>interrupt는 디바이스 컨트롤러가 호스트한테 직접 알려줌</p>\n<p>interrupt가 들어오면 cpu는 자기가 하던 instruction을 마치고 interrupt에 해당하는 interrupt handler를 불러서 수행</p>\n<p>핸들러가 끝나면 원래 하던 일을 복구</p>\n<p>만약에 디바이스 드라이버가 I/O를 초기화하는데 I/O의 크기가 매우 크면</p>\n<p>ex) 10MB 짜리 파일을 메모리에 저장해야할 때</p>\n<ul>\n<li>10MB = 4KB x 2560</li>\n<li>I/O가 2560번의 초기화를 해야함</li>\n</ul>\n<h3>DMA (Direct Memory Access)</h3>\n<p>io가 cpu한테 4kb보내주면  cpu가 그걸 메모리에 쓰는게 아니라 중간에 DMA가 존재</p>\n<p>DMA가 4KB 데이터를 메모리에 직접 쓰게 하자</p>\n<p>10MB다 끝나면 DMA가 알려주자</p>\n<ul>\n<li>large data movement같은 경우엔 DMA가 대신 일을 해줘서 cpu의 부담을 줄임</li>\n<li>cpu를 bypass해서 바로 io에서 memory로 데이터를 써주는 효과를 내자</li>\n<li>cpu는 처음 초기화할 때만 관여</li>\n<li>DMA가 mem에 데이터 저장</li>\n<li>일이 다 끝나면 DMA가 cpu한테 알려줌 dma가 인터럽트를 보냄</li>\n</ul>\n<p>cpu 는 dma한테</p>\n<p>작업의 크기</p>\n<p>어떤 명령어인지</p>\n<p>src, dest의 주소등을 알려줌</p>","frontmatter":{"title":"os 14-2","date":"June 12, 2022","update":null,"tags":["OS"],"series":null},"fields":{"slug":"/15/","readingTime":{"minutes":11.385}}},"seriesList":{"edges":[{"node":{"id":"1f4e5238-73be-5807-a94c-f4de69b70d29","fields":{"slug":"/git1/"},"frontmatter":{"title":"git pull 오류 : fatal: refusing to merge unrelated histories"}}},{"node":{"id":"a18a1199-15b8-567b-b381-9877cb7e1482","fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},{"node":{"id":"dcd66e70-19bb-529a-93eb-a40dcda3967d","fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}}},{"node":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기"}}},{"node":{"id":"7f18986d-bd27-5ec2-9316-919595eca11b","fields":{"slug":"/6-2/"},"frontmatter":{"title":"os 6-2"}}},{"node":{"id":"3dfd35bf-9f06-57e0-8aae-bbe57bac7616","fields":{"slug":"/grid/"},"frontmatter":{"title":"그리드를 어떻게 그리드라"}}},{"node":{"id":"3e388686-2418-5776-a4f4-7d485967ad50","fields":{"slug":"/instance-flex/"},"frontmatter":{"title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때"}}},{"node":{"id":"35cb486b-c0aa-5492-bf01-368334b4e4d5","fields":{"slug":"/datamining/"},"frontmatter":{"title":"작성중"}}},{"node":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},{"node":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","fields":{"slug":"/8-1/"},"frontmatter":{"title":"os 8-1"}}},{"node":{"id":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},{"node":{"id":"3b144405-2ae5-5814-a3eb-f3db08d57801","fields":{"slug":"/auth-user/"},"frontmatter":{"title":"AUTH_USER_MODEL 사용"}}},{"node":{"id":"a1a1c386-4e12-55c0-b88e-b1ab29cfc979","fields":{"slug":"/sync-tools/"},"frontmatter":{"title":"os 10-1 Synchronization Tools"}}},{"node":{"id":"a8468bab-91a9-5069-bc3f-049d1a5aceb9","fields":{"slug":"/env/"},"frontmatter":{"title":"SECRET KEY 환경변수에 숨기기"}}},{"node":{"id":"85ca9819-7740-5d19-bde1-f1825944fb23","fields":{"slug":"/11-1/"},"frontmatter":{"title":"os 11-1"}}},{"node":{"id":"fe1864b8-839f-505a-8647-10db01ebd21a","fields":{"slug":"/11-2/"},"frontmatter":{"title":"os 11-2"}}},{"node":{"id":"641a26c1-7a3f-591a-9294-2b8a329ef9a6","fields":{"slug":"/list-comprehension/"},"frontmatter":{"title":"list comprehension"}}},{"node":{"id":"8e10d9c5-ccdf-5fb1-9389-4a7d2618115c","fields":{"slug":"/zip/"},"frontmatter":{"title":"zip"}}},{"node":{"id":"232934ea-695b-59c3-9933-f70434f65675","fields":{"slug":"/access-token/"},"frontmatter":{"title":"git access token 발급 잔디 테스트"}}},{"node":{"id":"4692c2dc-2ae0-58ba-92be-fc345d912b43","fields":{"slug":"/requests/"},"frontmatter":{"title":"python 라이브러리 requests"}}},{"node":{"id":"a49c908d-fe72-5ab8-aeca-835d60f50497","fields":{"slug":"/docker-concept/"},"frontmatter":{"title":"docker 개념"}}},{"node":{"id":"756b4f22-d300-58fe-8d33-fafc6ff511f6","fields":{"slug":"/docker-env/"},"frontmatter":{"title":"docker env설정(작성중ㅎㅎ)"}}},{"node":{"id":"d6ccffc2-7b03-5581-b29a-ac306dc06194","fields":{"slug":"/jupyter-setting/"},"frontmatter":{"title":"장고 shell 명령 주피터에서 할 때 초기세팅"}}},{"node":{"id":"254cabc8-767a-509a-8ac6-1b7c1fee5877","fields":{"slug":"/install-openssl/"},"frontmatter":{"title":"ubuntu에서 openssl 설치하기"}}},{"node":{"id":"7b7a0020-f454-5945-885b-8972512e0d8e","fields":{"slug":"/ssl-concept/"},"frontmatter":{"title":"ssl 인증서란?"}}},{"node":{"id":"9bf2c6c3-9f60-5a55-98d1-e060211c8163","fields":{"slug":"/sync-exam/"},"frontmatter":{"title":"os 10-2 Synchronization Examples"}}},{"node":{"id":"910aa000-d355-501d-a941-b234944b4fec","fields":{"slug":"/bash/"},"frontmatter":{"title":"bash: vi: command not found"}}},{"node":{"id":"4bec6f60-3a0e-5050-b6c4-1a9d7a232ba4","fields":{"slug":"/1/"},"frontmatter":{"title":"os 13-1"}}},{"node":{"id":"02483ae7-ba0a-5e03-aa72-19a907837984","fields":{"slug":"/2/"},"frontmatter":{"title":"os 13-2"}}},{"node":{"id":"ce978a60-290f-5fbb-b75d-f9ec9e6f57e2","fields":{"slug":"/1/"},"frontmatter":{"title":"os 12-1"}}},{"node":{"id":"bfc80393-1cd7-5fc8-bc04-e744783e77de","fields":{"slug":"/2/"},"frontmatter":{"title":"os 12-2"}}},{"node":{"id":"e41df5b8-30c6-54fe-88c9-1d212c70c9f4","fields":{"slug":"/15/"},"frontmatter":{"title":"os 14-2"}}},{"node":{"id":"a8eb5fd5-89bd-592a-bbbd-81ff257715b2","fields":{"slug":"/1/"},"frontmatter":{"title":"os 14-1"}}},{"node":{"id":"d86a8175-8ed2-572f-9679-d8d2a48d0697","fields":{"slug":"/2/"},"frontmatter":{"title":"os 14-2"}}},{"node":{"id":"b2e15c0a-3e85-5d09-bb9a-930a3af8456a","fields":{"slug":"/kr-str/"},"frontmatter":{"title":"[c++] 한글을 한 글자씩 출력하기"}}},{"node":{"id":"ad012487-5365-57df-8a83-b70be15aa316","fields":{"slug":"/arr-addr/"},"frontmatter":{"title":"arr과 &arr의 차이"}}},{"node":{"id":"5063006c-e0ec-58ad-bbd0-0e5f2ab7ad99","fields":{"slug":"/git2/"},"frontmatter":{"title":"git error: cannot lock ref 'refs/remotes/origin/main': unable to resolve reference 'refs/remotes/origin/main': reference broken 문제 해결"}}}]},"previous":{"fields":{"slug":"/2/"},"frontmatter":{"title":"os 12-2"}},"next":{"fields":{"slug":"/1/"},"frontmatter":{"title":"os 14-1"}}},"pageContext":{"id":"e41df5b8-30c6-54fe-88c9-1d212c70c9f4","series":null,"previousPostId":"bfc80393-1cd7-5fc8-bc04-e744783e77de","nextPostId":"a8eb5fd5-89bd-592a-bbbd-81ff257715b2"}},"staticQueryHashes":[]}