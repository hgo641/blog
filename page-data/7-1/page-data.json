{"componentChunkName":"component---src-templates-post-jsx","path":"/7-1/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","excerpt":"7-1 스레드! 멀티스레드! 스레드를 어떻게 구현하는지! 스레드라는게 왜 나왔나요? cpu 하나의 성능 개선 : 한계에 다다름 cpu를 여러개? 멀티 코어 = 멀티 프로그래밍 여러개의 프로그램을 돌릴 수 있게 됨 A와 B가 각기 다른 일을 수행(멀티 프로그래밍) 여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드) 여러개의 코어에서 한 프로그램…","html":"<p>7-1</p>\n<p>스레드! 멀티스레드! 스레드를 어떻게 구현하는지!</p>\n<h4>스레드라는게 왜 나왔나요?</h4>\n<p>cpu 하나의 성능 개선 : 한계에 다다름</p>\n<p>cpu를 여러개? 멀티 코어 = 멀티 프로그래밍</p>\n<p>여러개의 프로그램을 돌릴 수 있게 됨</p>\n<ol>\n<li>A와 B가 각기 다른 일을 수행(멀티 프로그래밍)</li>\n<li>여러 개의 책상에서 동일한 목표를 위해 일을 수행(멀티 쓰레드)</li>\n</ol>\n<p>여러개의 코어에서 한 프로그램이 하는 일을 분배해서 수행</p>\n<h4>스레드가 생기고 나온 문제</h4>\n<ul>\n<li>Dividing activites (일을 어떻게 나눌지)</li>\n<li>Balance (혼자 팀플 ...)</li>\n<li>Data splitting (데이터를 어떻게 나눠줄지)</li>\n<li>Data dependency (한 명이 수정했는데 다른 사람들이 그 수정한 파일에 기반을 두고 있을 경우 어떻게 할 것 인지)</li>\n<li>Testing and debugging</li>\n</ul>\n<p>Parallelism : 여러 코어에서 동시에 수행 (멀티 코어)</p>\n<p>Concurrency : 하나의 코어에서 수행</p>\n<h4>기존 프로세스의 특성</h4>\n<p><strong>하나의 프로세스는 두 가지 특성으로 나눌 수 있다</strong></p>\n<p><em>an execution stream in the context of a particular process state(resource)</em></p>\n<ul>\n<li>unit of resource ownership</li>\n</ul>\n<blockquote>\n<p>resource ownership을 가진 애를 process라고 부르자!</p>\n</blockquote>\n<ul>\n<li>unit of execution stream</li>\n</ul>\n<blockquote>\n<p>execution stream은 나눌 수 있지않을까?</p>\n<p>외부에서 돌아가는 excuted stream을 thread라고 부르자!</p>\n<p>하나의 프로그램 안에서 execution stream을 여러 개로 나눔</p>\n</blockquote>\n<ul>\n<li>execution stream이 여러 개라면 각각의 stack과 register가 필요하다! stack, reg 스레드마다 분리 (code, data, files는 공유함)</li>\n</ul>\n<h4>스레드의 특징</h4>\n<ul>\n<li>\n<p>스레드는 state 3개 (running, ready, stopped(brocked = wait))</p>\n<ul>\n<li>그럼 생성 종료는 어떻게?</li>\n</ul>\n<p>실제로 os상에서 구현할 때는 라이브러리 같은걸 제공하게되는데 거기서는 생성, 종료 state를 추가적으로 만들긴함. 기본적인 state임 신경안써도 ㄱㅊ</p>\n</li>\n<li>프로세스 state는 5개 (new, run, wait, ready, terminate)</li>\n<li>프로세스가 termination되면 당연히 그 안의 스레드도 termination</li>\n<li>스레드마다 context(reg, stack에 대한 정보들)를 따로 관리해야한다</li>\n<li>stack이 따로 있고 static memory(for local vairables)도 존재할수도 있음</li>\n<li>\n<p>그러나 사실상 접근하는 메모리 공간은 process의 메모리 공간에 공유함</p>\n<p><img src=\"./thread.png\"></p>\n<ul>\n<li>프로세스의 모든 스레드들은 이걸 공유함 (그림의 share부분 참고)</li>\n</ul>\n</li>\n<li>여러 os에서 다양한 형태의 스레드를 사용한다</li>\n<li>MS-DOS : 싱글유저 - 싱글스레드</li>\n<li>초창기 유닉스 : 여러 개의 프로세스 but 프로세스당 스레드 하나</li>\n<li>현대 유닉스 : multiple threads</li>\n</ul>\n<p>멀티스레드 어디서 사용? 보통서버 아키텍처에서 많이사용</p>\n<p>ex. 이메일 서비스</p>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/41314/email.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABhElEQVQoz22R3W7TQBCF+/4Pg4CrqmmIHW7CRYA0SlvFhaauXRNjYpvEv/vzMV6XiAtWGmk9c+abs+MLay2W8bS9JspKilNDnuek6Z7iWJPkJ5I04/Nyyc1qRXooiEXXa+P6/vYPrIvhYtoGmoq86lg8/GCXFrRNTSf5558l3ubJAZq6pmoagn3JIkiolaC6Fp3/wlQnBx2Bkui3G9CK/50BbrSGLIVDBmV+rtm+Qz3cY0VzBlpr0PsEHYUoiW65QIePDA+K45j1ek0YRWhx12++onbfUNtbrLiydYW6vcFk+3+AMl0F9+g4dJMcTAYMZ9jlLgzJkxf0ZoX6HohenR0ZAfZfPqFfohGoBaaNQZUFWuxrWYs8bgypWTMu3qiebntHe7eme34SnXX1IZRAtVLu7hwi4uGncPoNx0J2dOCVAtXxNV+Oucdg1Lrl1mNedWPf4ND3ffzZB/zrCd77d8zevpHvGf58jj+d4nseTjOE5DxXF/38o9NNJ1dMJK4uL7kWxh8q21vQc2XliQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='email' title='email' src='/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/ca1dc/email.png' srcset='/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/e7570/email.png 170w,\n/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/f46e7/email.png 340w,\n/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/ca1dc/email.png 680w,\n/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/02d09/email.png 1020w,\n/hgo641.github.io/blog/static/37159265178febb7412adbf2c8327671/41314/email.png 1074w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>멀티스레드.......... vs 멀티프로세스</p>\n<p>뭔 차이냐....... 이 말이여</p>\n<p>프로세스 생성에 대한 오버헤드가 큼! 프로세스에 필요한 공간 할당. 메모리에 올려야 함</p>\n<p>멀티 스레드는 a,b,c도 같은 프로세스안에서 돌게하므로 성능상의 이득을 취하면서도 프로세스 생성에 대한 오버헤드도 줄일 수 있다!</p>\n<h4>멀티 스레드의 이점</h4>\n<ul>\n<li>\n<p>Responsiveness(응답성)</p>\n<ul>\n<li>위 예시에서 싱글스레드는 a를 처리해야 b처리 가능</li>\n</ul>\n</li>\n<li>\n<p>Resource sharing</p>\n<ul>\n<li>멀티 프로세스의 경우 각기 독립적인 메모리 공간을 사용</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>멀티 프로세스는 각각 abc리퀘스트를 처리하기 위해서 프로세스를 따로 만들어줌. 각기 독립적인 메모리 공간. 따라서 프로세스들간 소통을 하기위해선 커널을 거쳐서 shared memory 나 message passing을 통해서 소통해야함</p>\n<p>그러나 멀티 스레드는 같은 프로세스안 Resourcce sharing에 유리.</p>\n</blockquote>\n<ul>\n<li>\n<p>economy</p>\n<ul>\n<li>takes less time</li>\n</ul>\n<p> 뉴 스레드를 만드는게 프로세스를 만드는 것보다 빠름</p>\n<p> 프로세스는 모든 컨텍스트를 새로 만들고 초기화</p>\n<p> 스레드는 스레드 컨텍스트(stack)만 서로 만듦</p>\n<p> 마찬가지로 종료도 스레드가 유리</p>\n<p> 한 프로세스내에서 두 개의 컨텍스트를 스위치하는 시간도 빠름</p>\n<p>코어가 늘어나는것에대해서 성능도 증가</p>\n<ul>\n<li>Uses very little resources</li>\n</ul>\n<p>스레드가 필요한건스택과 per-thread staticy memory 뿐</p>\n</li>\n</ul>\n<p>스레드가 많아지면 멀티프로세서같이 코어가 많은 아키텍처에서는 프로세스가 advantage를 얻을 수 있다</p>\n<h2>Threads Implementation</h2>\n<ol>\n<li>user-level : 사용자가 코드에 작성하는 것(사용자가 나눈 일의 단위)</li>\n<li>kernel-level : 커널이 관리하는 스레드(cpu 자원 할당 단위)</li>\n</ol>\n<p>두 개를 나눠서 구현하게 됨</p>\n<h3>User-Level Threads : Multi thread using only user-level thread</h3>\n<ul>\n<li>100% 유저 레벨</li>\n<li>커널은 얘의 존재를 모름. 커널이 보기에는 프로세스 하나</li>\n<li>유저레벨에서 코드를 나눠서 작성함</li>\n<li>이걸 위해 user-level library 존재</li>\n</ul>\n<p><strong>user-level library</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 스레드 만들고 소멸\n- 스레드간의 스케줄링\n-\n- 스레드 컨텍스트 스위칭될 때 컨텍스트를 saving and restore\n- 스레드 간의 데이터 소통</code></pre></div>\n<p>실질적으로 cpu할당은 프로세스단위로 이루어짐</p>\n<ul>\n<li>어플리케이션은 유저레벨 스레드를 사용해서 모든 스레드를 관리한다</li>\n<li>스케줄링도 어플리케이션안에서 다 함 ( 어플리케이션 맞춤)</li>\n<li>커널은 유저레벨스레드의 존재를 모르고 프로세스 하나가 동작하는줄 앎</li>\n<li>어떤 스레드가 blocking system call을 할 때 커널은 그 프로세스를 통째로 block, waiting시킨다</li>\n<li>\n<p>장점</p>\n<ul>\n<li>스레드간 스위칭을 할 때 커널이 관여를 안함 (오버헤드 없음 mode switching없음 usermode &#x3C;-> kernel mode)</li>\n<li>스케줄링이 베스트 알고리즘을 선택할 수 있다</li>\n<li>os에서 스레드모드를 지원하지않아도 라이브러리만 있으면 구현을 할 수 있다</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>어떤 스레드가 시스템콜을 날리면 모든 스레드가 block</li>\n<li>코어가 여러개여도 활용을 모함 (한 책상을 여러명이 돌려씀)</li>\n</ul>\n</li>\n<li>사실상 초기 스레드 모형이며 지금은 사용하지않음. 너무 구림</li>\n</ul>\n<h3>Kernel-Level Threads</h3>\n<ul>\n<li>one to one mapping between user-level and kernel-level</li>\n<li>유저레벨 스레드와 커널레벨 스레드가 둘 다 존재</li>\n<li>유저레벨 스레드와 커널레벨 스레드가 1대1 매핑</li>\n<li>\n<p>유저 레벨 스레드 라이브러리를 쓰지않고 커널의 기능을 호출(api - kernel function)</p>\n<ul>\n<li>커널이 프로세스뿐만아니라 스레드에 대한 컨텍스트 정보도 유치</li>\n<li>스레드간 스위칭 지원</li>\n<li>스레드 스케줄링</li>\n<li>synchronization</li>\n</ul>\n</li>\n<li>사용자가 어플리케이션 내부적으로 따로 스레드를 생성하고 관리하는건 없고 사용자가 스레드를 만들고싶을 때는 시스템한테 요청을 함. 시스템이 스레드를 관리를 온전히 다 한다. 유저레벨에선 관리할 필요가 없음.</li>\n<li>cpu 자원할당이 스레드 위주로 돌아감</li>\n<li>모든 스레드를 커널이 관리</li>\n<li>코드에서 유저레벨 스레드를 생성하면 실제 커널 레벨 스레드가 생성된다는 말</li>\n<li>\n<p>장점:</p>\n<ul>\n<li>여러개의 스레드를 여러개의 cpu코어에서 동시에 돌릴 수 있다</li>\n<li>어떤 스레드 하나가 block되어도 다른 스레드가 돌아간다</li>\n<li>커널에 대한 여러가지 루틴들도 멀티스레드처럼 만들 수 있다(뭔 소리?)</li>\n</ul>\n</li>\n<li>\n<p>단점:</p>\n<ul>\n<li>스레드 스위칭자체가 컨텍스트 스위칭과 같은 오버헤드를 야기한다</li>\n</ul>\n</li>\n<li>modern linux, windows가 원투원 매핑 사용</li>\n</ul>\n<h3>Combined Threads</h3>\n<p><code class=\"language-text\">Many-to-Many</code></p>\n<p>커널레벨모드도 유저레벨모드도 존재</p>\n<p>유저가 나눠놓은 일의 단위와 cpu가 할당한 주체의 단위를 다르게 가져간다</p>\n<p>커널은 사실상 스레드의 존재를 크게 의식하지않음</p>\n<p>커널은 단지 유저에게 virtual processor같은</p>\n<p>커널은 유저가 요청한대로 커널레벨스레드를 만들어주고 커널레벨스레드단위로 스케줄링하고 관리해줌</p>\n<p>유저레벨 스레드는 커널레벨 스레드가 가상의 프로세서라고 생각하고 활용</p>\n<p>어떤 스레드를 어떤 프로세서에 넣을지 관리를 해줌</p>","frontmatter":{"title":"os 7-1","date":"April 22, 2022","update":null,"tags":["OS"],"series":null},"fields":{"slug":"/7-1/","readingTime":{"minutes":10.985}}},"seriesList":{"edges":[{"node":{"id":"1c0ade67-50d9-566d-8cdf-505bc94e9e30","fields":{"slug":"/1/"},"frontmatter":{"title":"git pull 오류 : fatal: refusing to merge unrelated histories"}}},{"node":{"id":"a18a1199-15b8-567b-b381-9877cb7e1482","fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},{"node":{"id":"dcd66e70-19bb-529a-93eb-a40dcda3967d","fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}}},{"node":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기"}}},{"node":{"id":"7f18986d-bd27-5ec2-9316-919595eca11b","fields":{"slug":"/6-2/"},"frontmatter":{"title":"os 6-2"}}},{"node":{"id":"3dfd35bf-9f06-57e0-8aae-bbe57bac7616","fields":{"slug":"/grid/"},"frontmatter":{"title":"그리드를 어떻게 그리드라"}}},{"node":{"id":"3e388686-2418-5776-a4f4-7d485967ad50","fields":{"slug":"/instance-flex/"},"frontmatter":{"title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때"}}},{"node":{"id":"35cb486b-c0aa-5492-bf01-368334b4e4d5","fields":{"slug":"/datamining/"},"frontmatter":{"title":"작성중"}}},{"node":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},{"node":{"id":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},{"node":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","fields":{"slug":"/8-1/"},"frontmatter":{"title":"os 8-1"}}},{"node":{"id":"3b144405-2ae5-5814-a3eb-f3db08d57801","fields":{"slug":"/auth-user/"},"frontmatter":{"title":"AUTH_USER_MODEL 사용"}}},{"node":{"id":"987ed322-774d-5a43-8f42-1899db096cad","fields":{"slug":"/10-1/"},"frontmatter":{"title":"os 10-1"}}},{"node":{"id":"a8468bab-91a9-5069-bc3f-049d1a5aceb9","fields":{"slug":"/env/"},"frontmatter":{"title":"SECRET KEY 환경변수에 숨기기"}}},{"node":{"id":"7eb19461-ddc3-5b03-ac5a-4fce46553994","fields":{"slug":"/11-1/"},"frontmatter":{"title":"os 11-1"}}},{"node":{"id":"2cebb9b3-24d4-5a97-9261-d7a2757ee845","fields":{"slug":"/11-2/"},"frontmatter":{"title":"os 11-2"}}},{"node":{"id":"641a26c1-7a3f-591a-9294-2b8a329ef9a6","fields":{"slug":"/list-comprehension/"},"frontmatter":{"title":"list comprehension"}}},{"node":{"id":"8e10d9c5-ccdf-5fb1-9389-4a7d2618115c","fields":{"slug":"/zip/"},"frontmatter":{"title":"zip"}}},{"node":{"id":"232934ea-695b-59c3-9933-f70434f65675","fields":{"slug":"/access-token/"},"frontmatter":{"title":"git access token ¹ß±Þ"}}},{"node":{"id":"4692c2dc-2ae0-58ba-92be-fc345d912b43","fields":{"slug":"/requests/"},"frontmatter":{"title":"python 라이브러리 requests"}}},{"node":{"id":"a49c908d-fe72-5ab8-aeca-835d60f50497","fields":{"slug":"/docker-concept/"},"frontmatter":{"title":"docker 개념"}}}]},"previous":{"fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}},"next":{"fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},"pageContext":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","series":null,"previousPostId":"3c3d7c71-bf68-593e-9b21-c03bfff45743","nextPostId":"d8cb2c75-c4f1-5607-9036-fdfb429643bd"}},"staticQueryHashes":[]}