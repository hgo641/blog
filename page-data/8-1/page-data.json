{"componentChunkName":"component---src-templates-post-jsx","path":"/8-1/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","excerpt":"Critical Section Problem 동기화! 각 프로세스의 코드에는 크리티컬 섹션이 존재한다 critical section : 공유 데이터가 업데이트 일어나는 부분 entry section : 크리티컬 섹션에 들어가기위한 코드의 부분 exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분 remainder section : 크리…","html":"<h2>Critical Section Problem</h2>\n<blockquote>\n<p>동기화!</p>\n<p>각 프로세스의 코드에는 크리티컬 섹션이 존재한다</p>\n<ul>\n<li>critical section : <strong>공유 데이터</strong>가 업데이트 일어나는 부분</li>\n<li>entry section : 크리티컬 섹션에 들어가기위한 코드의 부분</li>\n<li>exit section : 크리티컬 섹션에서 빠져나오기 위한 코드의 부분</li>\n<li>remainder section : 크리티컬섹션이 아닌 나머지부분</li>\n</ul>\n<p>위 섹션들은 모두 코드임</p>\n</blockquote>\n<ul>\n<li>n개의 프로세스가 있다고 가정</li>\n<li>각각의 프로세스는 코드를 가지는데 그 코드에 크리티컬 섹션이 존재</li>\n<li>크리티컬 섹션안에서는 정보의 업데이트가 가능하다</li>\n<li>공유되는 변수나 테이블등을 바꿀 수 있음</li>\n<li>어떤 프로세스가 크리티컬 섹션을 가지고있으면 다른 프로세스가 그 크리티컬 섹션에 진입할 수 없다</li>\n</ul>\n<h4>Solution to Critical Section Problem</h4>\n<ul>\n<li>\n<p>Mutual Exclusion (상호배제)</p>\n<ul>\n<li>한 번에 한 프로세스만 크리티컬 섹션에 들어갈 수 있다</li>\n<li>한 프로세스가 어떤 크리티컬 섹션에 들어가 있으면 다른 프로세스가 동일한 크리티컬 섹션안에 들어가지못한다</li>\n</ul>\n</li>\n<li>\n<p>Progress</p>\n<ul>\n<li>만약에 크리티컬 섹션에 아무도 없는데 들어가고싶어하는 사람이 있으면 그 결정은 바로 나야한다</li>\n<li>즉 최대한 빨리 결정이 나야한다는 것! 무기한 연장되지않는다</li>\n<li>그 결정은 remainder 섹션에 있지 않은 애들이어야한다 </li>\n</ul>\n</li>\n<li>\n<p>Bounded Waiting (유한한 대기. 언젠간 들어갈 수 있게)</p>\n<ul>\n<li>어떤 프로세스가 크리티컬 섹션에 들어가고 싶어서 request를 날렸을 때 바운디드 웨이팅에 한계가 있다. 즉 무기한 기다리지않는다</li>\n</ul>\n</li>\n</ul>\n<h4>Critical Section Handling in OS</h4>\n<blockquote>\n<p><strong>예시</strong> : 크리티컬 섹션 핸들링이 되지않는다면?</p>\n<p>fork()를 하면 next<em>available</em>pid를 제공</p>\n<p>만약 두 프로세스가 동시에 fork()를 한다면?</p>\n<p>동시에 next<em>available</em>pid에 접근해서 </p>\n<p>방금 생성한 프로세스 p2, p3가 서로 다른 프로세스임에도 같은 프로세스 아이디를 가져갈 수도 있다</p>\n</blockquote>\n<ul>\n<li>\n<p>preemptive(cpu를 뺏어갈수있는 스케줄링)</p>\n<ul>\n<li>어떤 프로세스가 커널모드에서 run하고 있을 때 cpu를 뺏는게 가능</li>\n</ul>\n</li>\n<li>\n<p>non-preemptive (능동적)</p>\n<ul>\n<li>cpu 뺏는게 안됨</li>\n<li>특정 프로세스가 커널모드를 끝날 때까지 or 양보할 때까지 동작하는게 보장이 됨</li>\n<li>커널 안에서의 작업이 <strong>완전히 끝나는 것을 보장</strong></li>\n<li>애초에 critical problem, race conditions가 발생하지않음</li>\n<li>일을 하는중에 누군가 뺏어가지않음</li>\n<li><strong>문제가 생기는건 preemptive한 커널 구조</strong></li>\n</ul>\n</li>\n</ul>\n<p>어떤식으로 해결해야할까?</p>\n<h3>Peterson's Solution</h3>\n<ul>\n<li>고전적인 소프트웨어 기반 해결책. 현대에는 적용할 수 없음</li>\n<li>두 개의 프로세스가 동시에 크리티컬 섹션에 들어갈때(두 개의 프로세스일때만 가능. 여러개는 못함)</li>\n<li>로드, 스토어 명령어는 atomic하다고 가정. = 명령어 중간에 껴들어갈수없다</li>\n<li>싱글 cpu가정</li>\n<li>\n<p>두가지변수사용</p>\n<ul>\n<li>int turn : 누구 순서인지</li>\n<li>bool flag[2] : </li>\n<li>flag[i] == True이면 Pi가 크리티컬 섹션에 들어갈 준비가 되었다는 뜻</li>\n<li>turn = j; #양보함 -> turn이 j로 바뀌어서 while문을 빠져나옴?</li>\n<li>pj가 다 끝나면 flag i를 다시 false로 바꿔줌??</li>\n<li>(while flag[j] &#x26;&#x26; turn == j ) : 기다림</li>\n<li>i가 크리티컬 섹션에 들어갈 수 있을 때는</li>\n<li>\n<ol>\n<li>상대방이 준비가 안됐을때</li>\n</ol>\n</li>\n<li>나의 턴일 때</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>while문과 critical section이 별개인듯</p>\n<p>먼저 순서를 양보해서 j가 준비되었고 턴이 j면 i는 while문을 계속 돎</p>\n<p>j의 크리티컬 섹션이 끝나서 flag[j] = false가 되면 i가 while문을 빠져나오고 크리티컬 섹션에 진입</p>\n</blockquote>\n<p>그러나 현대 컴퓨터에서 쓰일 수 없음...</p>\n<p>가장 큰 이유는 reorder때문</p>\n<p>아무리 순차적으로 코드를 짰어도 그거에 디펜던시가 없으면 컴퓨터가 효율성을 위해서 리오더링할 수 있음</p>\n<p>cpu가 알아서 turn을 먼저하고 flag를 나중에 해버림</p>\n<h4>Critical Section with Disable/Enable Interrupt</h4>\n<p>어떻게 막을 수 있을까?</p>\n<p>누군가 크리티컬 섹션에 진입했을때 인터럽트를 막아버림</p>\n<p>인터럽트 : 컨텍스트 스위칭을 유발할 때 생김</p>\n<p>컨텍스트 스위칭을 하기위해 인터럽트를 보냄</p>\n<p>인터럽트를 막았기 때문에 컨텍스트 스위칭이 되지않음(p1에서  p2로 넘어가지않음)</p>\n<ul>\n<li>그러나 인터럽트를 disable/enable 하는 것은 너무 강력한 메소드!</li>\n<li>이거 하려고... 인터럽트... 다 막으려고...~?</li>\n<li>벼룩잡으려다 초가삼간 태우는 꼴!</li>\n</ul>\n<blockquote>\n<p>소프트웨어만으로는 해결하기 힘든 문제</p>\n<p>하드웨어의 도움이 필요하다!</p>\n</blockquote>\n<h2>Synchronization Hardware</h2>\n<h3>Hardware Instruction : test<em>and</em>set</h3>\n<ul>\n<li>atomic = non-interruptible한 instruction</li>\n<li>어떤 메모리에서 테스트 값을 가져와서 그 값을 바꾸는 일도 함</li>\n</ul>\n<p>boolean test<em>and</em>set (boolean *target)</p>\n<blockquote>\n<p>target을 받아서 값을 가져옴</p>\n<p>타겟을 true로 만듦</p>\n<p>받은 target값을 그대로 return</p>\n<p># test : 얘가 원래 true였는지 false였는지 테스트</p>\n<p># set : target을 true로 셋~ </p>\n</blockquote>\n<blockquote>\n<p>예시</p>\n<p>lock = target, lock은 공유변수</p>\n<p>초기 lock값은 false</p>\n<p>tas()의 리턴값이 false라서 while문을 빠져나오지만</p>\n<p>lock이 true 로 set되어서 다른애들은 크리티컬 섹션 들어가지못함</p>\n</blockquote>\n<p>os 개념, 컨셉 이론. 전체적인 개념을 묻는 문제가 많이 나올것</p>","frontmatter":{"title":"os 8-1","date":"April 22, 2022","update":null,"tags":["OS"],"series":null},"fields":{"slug":"/8-1/","readingTime":{"minutes":7.445}}},"seriesList":{"edges":[{"node":{"id":"1c0ade67-50d9-566d-8cdf-505bc94e9e30","fields":{"slug":"/1/"},"frontmatter":{"title":"git pull 오류 : fatal: refusing to merge unrelated histories"}}},{"node":{"id":"a18a1199-15b8-567b-b381-9877cb7e1482","fields":{"slug":"/flex/"},"frontmatter":{"title":"flex 해보기 ㅎㅎ"}}},{"node":{"id":"dcd66e70-19bb-529a-93eb-a40dcda3967d","fields":{"slug":"/meta-class/"},"frontmatter":{"title":"Django의 Meta 클래스 활용"}}},{"node":{"id":"9ba353f1-cdcf-5911-a0bd-05ab1ab2c88e","fields":{"slug":"/alpha-beta-pruning/"},"frontmatter":{"title":"Minimax 알고리즘 & alpha-beta 가지치기"}}},{"node":{"id":"7f18986d-bd27-5ec2-9316-919595eca11b","fields":{"slug":"/6-2/"},"frontmatter":{"title":"os 6-2"}}},{"node":{"id":"3dfd35bf-9f06-57e0-8aae-bbe57bac7616","fields":{"slug":"/grid/"},"frontmatter":{"title":"그리드를 어떻게 그리드라"}}},{"node":{"id":"3e388686-2418-5776-a4f4-7d485967ad50","fields":{"slug":"/instance-flex/"},"frontmatter":{"title":"장고하다가 모델 인스턴스 뻥튀기 하고싶을때"}}},{"node":{"id":"35cb486b-c0aa-5492-bf01-368334b4e4d5","fields":{"slug":"/datamining/"},"frontmatter":{"title":"작성중"}}},{"node":{"id":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}}},{"node":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","fields":{"slug":"/8-1/"},"frontmatter":{"title":"os 8-1"}}},{"node":{"id":"5e929406-a010-55f2-8762-1f8c050eaf4c","fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},{"node":{"id":"3b144405-2ae5-5814-a3eb-f3db08d57801","fields":{"slug":"/auth-user/"},"frontmatter":{"title":"AUTH_USER_MODEL 사용"}}},{"node":{"id":"987ed322-774d-5a43-8f42-1899db096cad","fields":{"slug":"/10-1/"},"frontmatter":{"title":"os 10-1"}}},{"node":{"id":"a8468bab-91a9-5069-bc3f-049d1a5aceb9","fields":{"slug":"/env/"},"frontmatter":{"title":"SECRET KEY 환경변수에 숨기기"}}},{"node":{"id":"7eb19461-ddc3-5b03-ac5a-4fce46553994","fields":{"slug":"/11-1/"},"frontmatter":{"title":"os 11-1"}}},{"node":{"id":"2cebb9b3-24d4-5a97-9261-d7a2757ee845","fields":{"slug":"/11-2/"},"frontmatter":{"title":"os 11-2"}}},{"node":{"id":"8e10d9c5-ccdf-5fb1-9389-4a7d2618115c","fields":{"slug":"/zip/"},"frontmatter":{"title":"zip"}}},{"node":{"id":"641a26c1-7a3f-591a-9294-2b8a329ef9a6","fields":{"slug":"/list-comprehension/"},"frontmatter":{"title":"list comprehension"}}},{"node":{"id":"4692c2dc-2ae0-58ba-92be-fc345d912b43","fields":{"slug":"/requests/"},"frontmatter":{"title":"python 라이브러리 requests"}}},{"node":{"id":"232934ea-695b-59c3-9933-f70434f65675","fields":{"slug":"/access-token/"},"frontmatter":{"title":"git access token ¹ß±Þ"}}},{"node":{"id":"a49c908d-fe72-5ab8-aeca-835d60f50497","fields":{"slug":"/docker-concept/"},"frontmatter":{"title":"docker 개념"}}}]},"previous":{"fields":{"slug":"/7-2/"},"frontmatter":{"title":"os 7-2"}},"next":{"fields":{"slug":"/7-1/"},"frontmatter":{"title":"os 7-1"}}},"pageContext":{"id":"58f895f6-cc6d-51eb-b09a-0eade39b1e41","series":null,"previousPostId":"d8cb2c75-c4f1-5607-9036-fdfb429643bd","nextPostId":"5e929406-a010-55f2-8762-1f8c050eaf4c"}},"staticQueryHashes":[]}