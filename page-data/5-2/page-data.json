{"componentChunkName":"component---src-templates-post-jsx","path":"/5-2/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","excerpt":"스케줄링 policy : CPU를 누구한테 할당할까\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐 FCFS 가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리 하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함 24, 3, 3 …","html":"<p>스케줄링 policy : CPU를 누구한테 할당할까\n하나의 응용프로그램이 있을때 시피유 버스트와 아이오 버스트로 나뉨.\n각각의 프로세스마다 시피유 버스타한 부분이 있을텐데 이를 어떻게 시피유에 할당해주냐</p>\n<h2>FCFS</h2>\n<p>가장 간단한 방법. 줄 선 순서대로. 먼저 온 프로세스부터 처리</p>\n<p>하나의 cpu burst한 부분을 단위로 cpu 스케줄링을 함</p>\n<p>24, 3, 3 &#x3C;-cpu burst time</p>\n<p>단점: 시피유 버스트 타임이 긴 프로세스가 먼저 선택된다면 하나가 시피유를 독점\n솔루션 : 시피유 버스트가 끝날때까지 기다리는게 아니라 일정 시간이 지나면 강제적으로 컨텍스트 스위치를 시켜버리자 time slice</p>\n<p>예제)</p>\n<p>P1 P2 P3순으로 실행(먼저 온 순서)</p>\n<ul>\n<li>waiting time : 각 프로세스가 도착한 이후에 얼마나 기다렸는가</li>\n</ul>\n<p>p2 p3 p1 순으로 왔을 때 훨씬 빨라짐</p>\n<h2>Shortest Job First (SJF)</h2>\n<p>Key operations : length of CPU burst</p>\n<p>각각의 cpu 버스트의 길이를 가지고 짧은 애한테 우선순위 할당</p>\n<p>optimal함 : 쉽게 증명 가능</p>\n<p>waiting time 기준으로는 가장 좋은 policy</p>\n<p>문제) 어떻게 cpu burst 타임을 알 수 있는지\n정확한 cpu burst time을 OS가 알 수 없음. 구현불가능!</p>\n<p>two variations이 존재</p>\n<ul>\n<li>\n<p>non preemptive (양보가 안되는. 우선순위)</p>\n<p>어떤 SJF정책에 의해서 한 번 씨피유를 점유하면 그 잡이 끝날때까지는 스케줄링이 되지 않는다. 자리 안내줌</p>\n</li>\n<li>\n<p>preemptive(양보가능한)</p>\n<p>만약 SJF정책에 의해 짧은애가 선택이 되면\n새로운 프로세스가 레디큐에 들어옴\n다시 스케줄링 가능. 새로 들어온 애 먼저 들어가게 해줌 </p>\n<p>ex)\n끝난 시간 /바로 수행됐다면 끝났을 시간/ waiting time\np1 16 (0+7) 9\np2 7 (2+4) 1\np3 5 (4+1) 0\np4 11 (5+4) 2</p>\n</li>\n</ul>\n<p>근데 cpu burst time을 알 수 없음</p>\n<p>노력1. 예측해보자!\nexponential averaging\n수학적인 컨셉 제공 but 실제로 os에 적용하긴 무리 : 알파값 정하기가 힘듦. 실패케이스\nn+1시점의 cpu burst time을 이전의 히스토리를 가지고 예측해보자</p>\n<p>tn : 바로 직전의 실제 cpu burst time\n타우n+1 : 이번에 예측할 cpu burst time\n타우n : 바로 직전에 예측했던 cpu burst time</p>\n<p>알파를 얼마로 정해야?\n알파 = 0 기존에 예측한거 유지\n알파 = 1 직전의 실제값만 씀\n알파값은 시스템과 응용프로그램에 따라 또 달라짐\n이론적인 컨셉만 제공하고 실제 사용은 안함</p>\n<p>더 나은 policy를 찾아야할 필요성</p>\n<hr>\n<h2>Round Robin(RR)</h2>\n<p>Key operations : 각각의 프로세스는 각자의 time quantum(q) 동안만 cpu를 차지할 수 있음. q가 끝나면 cpu를 돌려주고 레디큐의 맨 끝으로 돌아감.</p>\n<p>q는 10 - 100 밀리세컨드 정도</p>\n<p>q가 크면 : FIFO. FCFS와 같아짐.\nq가 작으면 : 컨텍스트 스위치 오버헤드가 커짐. SJP와 근접해짐.</p>\n<p>많은 os가 라운드로빈이 기반인 스케줄링 사용</p>\n<p>컨텍스트 스위치타임은 보통 &#x3C;10\nq를 10~100으로 잡아서 컨텍스트 스위치타임의 오버헤드가 안보이게</p>\n<p>만약 n개의 프로세스가 있다면 어떤 프로세스가 자기 순서를 받을때까지 최대 (n-1)q 만큼만 기다리면 됨</p>\n<p>bad case) 10개의 프로세스가 100 time을 수행해야함</p>\n<p>1000-10 #waiting time\n1000-9\n1000-8\n.\n.\n.</p>\n<p>다들 오랜 시간 기다려야함.\n균등하게 비효율적.</p>\n<p>즉,  스케줄링 할 대상들이 비슷한 cpu burst time을 가질때 bad</p>\n<p>ex) </p>\n<ul>\n<li>q가 100 </li>\n<li>p1 cpu burst:1 , I/O burst :10</li>\n<li>p2는 그냥 계속 cpu burst</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/8643c/ex.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 28.235294117647058%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHUlEQVQY011Qi06EMBDk/3/MBxAgyikXEEXK24Nwcjz6GLf0TE43mczudrqdrRVFEeIkAWMMSeDjxbWR5zmElFjmC6aSQQwnKCGgpDC859LUSuE3JOUWYwXCMMRTECC8v8OzYyNwXRwOB7RNg+L4Cn4+g26CtzX4VwvRn4g7cHpMCb4P16HZ2rYN8zzjQphJODUV5q6F7t+GWhZsH29YkyPEOEBO3+Ck3dKYuDZuSWelaQqNLMuQ09pxHKMsy33IQkM0QOLd3XsCwT7BixySnErdiyOIugTPs9251fcDPM+H4zjwfB+BbcN/fIBDawf0DeM4Gof0byZRUNtqwLmp9RmtK9cVltZ0XYeiKFDXNSpCe62rqvq79hX/Q93wDzUJyJFqIsU/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='ex' title='ex' src='/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/ca1dc/ex.png' srcset='/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/e7570/ex.png 170w,\n/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/f46e7/ex.png 340w,\n/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/ca1dc/ex.png 680w,\n/hgo641.github.io/blog/static/91a008936a876a87ea3a173f048f83bd/8643c/ex.png 924w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<p>p1 1ms + 10ms waiting |1ms + 10ms|\np2 100ms . . . . . . . . 100ms . . . . . .\n1ms 후 100ms 수행</p>\n<p>U(CPU) = 100% (cpu가 얼마나 활용되고있는가)</p>\n<p>U(I/O) = 10ms 돌고 91ms 기다림\n10/101 = 10%</p>\n<p>단점) I/O 사용이 잘 안됨</p>\n<p>같은 ex, q만 다르다고 가정) q = 1\nU(CPU) = 100%\nU(I/O) = 거의 90% p1이 cpu burst할때 제외하고는 다 I/O (10/11)</p>\n<p>단점) 컨텍스트 스위칭이 자주 일어남. 오버헤드큼</p>\n<p>타임 퀀텀이 적절해야 라운드로빈 효율적\n근데 적절한 타임이 cpu burst와 i/o burst에게 다름\ncpu는 클수록. io는 작을수록</p>\n<p>다음해결방안 : (SJ)io bound process한테는 타임 퀀텀을 작게 (LJ)씨피유는 타임퀀텀을 크게</p>\n<p>프로세스마다 다르게 적용함 adaptive policy</p>\n<h2>Priority Scheduling</h2>\n<p>각 프로세스마다 우선순위 부여 - 숫자형태로</p>\n<p>더 높은 우선순위 먼저 실행\nSJF도 프라이어리티 스케줄링의 일종이라고 볼 수 있음. 얘는 실행시간이 짧은애가 우선</p>\n<p>얘도\n프림티브\n논프림티브 둘 다 만들 수 있음</p>\n<p>문제) Starvation\n어떤 프로세스가 우선순위가 낮음. 우선순위가 더 높은 프로세스가 계속들어온다면 우선 순위가 낮은 프로세스는 실행될 수 없음.</p>\n<p>솔루션) Aging\n프라이어티에 나이 개념 도입\n대기 시간이 길어지면 우선순위롤 조금씩 올려줌</p>\n<h2>Multilevel Queue</h2>\n<p>큐를 분리해서 사용</p>\n<p>foreground - 인터랙티브 : cpu보다 io가 더 느림\nbackground - batch : cpu가 긴.\n각 프로세스는 한 번 큐가 정해지면 그 큐만 사용? 반배정하듯이\n각각의 큐는 서로 다른 policy를 가질 수 있음</p>\n<ul>\n<li>foreground - RR</li>\n<li>background - FCFS</li>\n</ul>\n<blockquote>\n<p>반드시 저런건 아님. 설계하기나름</p>\n</blockquote>\n<p>어떤 큐에 있는 애한테 우선순위를 줄 것인지도 결정 필요\n이를 위한 policy도 추가적으로 필요</p>\n<ul>\n<li>고정된 프라이어티 스케줄링</li>\n<li>\n<p>타임 슬라이스 (포그라운드한테 일정시간, 백그라운드한테 일정시간)</p>\n<p>아직은 adaptive아님 아냐 아주 약간 adaptive...?</p>\n</li>\n</ul>\n<p>실질적으로 사용하는게 Multilevel Feedback Queue</p>","frontmatter":{"title":"OS 스케줄링","date":"March 30, 2022","update":null,"tags":["OS"],"series":"OS"},"fields":{"slug":"/5-2/","readingTime":{"minutes":7.935}}},"seriesList":{"edges":[{"node":{"id":"ac934700-c8a1-56ac-91a7-350a3b21aa36","fields":{"slug":"/1-2/"},"frontmatter":{"title":"OS의 역할과 역사"}}},{"node":{"id":"edf85d35-a010-51bd-95cb-e4ce77cb5311","fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}}},{"node":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}}},{"node":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},{"node":{"id":"3ce6c8ef-171c-515d-8439-79b45f5e3076","fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}}},{"node":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}}},{"node":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},{"node":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}}]},"previous":{"fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}},"next":{"fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},"pageContext":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","series":"OS","previousPostId":"edf85d35-a010-51bd-95cb-e4ce77cb5311","nextPostId":"2f8b7cec-b188-5256-88ee-d2ee43663d54"}},"staticQueryHashes":[]}