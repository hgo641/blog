{"componentChunkName":"component---src-templates-post-jsx","path":"/4-1/","result":{"data":{"site":{"siteMetadata":{"title":"hongo"}},"markdownRemark":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","excerpt":"fork() fork()라는 system call은 new process를 생성한다 (cloning) system call : 사용자가 os커널한테 요청하는 api fork() process 현재 프로세스 중지하고 state를 저장 현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (전부 똑같은건 아니…","html":"<h2>fork()</h2>\n<ul>\n<li>fork()라는 system call은 new process를 생성한다 (cloning)</li>\n</ul>\n<p>system call : 사용자가 os커널한테 요청하는 api</p>\n<h4>fork() process</h4>\n<ol>\n<li>현재 프로세스 중지하고 state를 저장</li>\n<li>현재 프로세스의 code, data, stack, heap + pcb를 복사해서 새로운 프로세스를 생성 (<strong>전부 똑같은건 아니고 PID에 차이를 준다. os는 pid를 가지고 구분. fork()의 return value도 바꿔준다</strong>)</li>\n<li>새로운 프로세스를 레디큐에 삽입</li>\n</ol>\n<h4>fork() return value</h4>\n<ol>\n<li>r &#x3C; 0 : 오류</li>\n<li>r > 0 : 부모 프로세스일 경우 chd의 pid를 반환</li>\n<li>r = 0 : 자식 프로세스일 경우</li>\n</ol>\n<h2>exec()</h2>\n<p>새 프로세스의 메모리 공간을 바꿔치기</p>\n<p>(새로운 프로그램의 경로)</p>\n<p>ex) execlp(\"/bin/ls\", \"ls\", NULL)</p>\n<ul>\n<li>오버헤드 단점 : 복사 비용이 너무 큼</li>\n<li>\n<p>COW ( copy on write)</p>\n<p>전부 복사하지말자!</p>\n</li>\n</ul>\n<p> 실제로는 pointer structure를 만들어서 부모의 code, data 영역을 가리키게 해줌</p>\n<p> (<strong>stack은 복제해야함</strong> : 두 프로세스를 다르게 관리해야하므로)</p>\n<p> 해당 데이터 영역을 수정해야할때 복제, 부모랑 데이터가 달라지는 순간 실제 복사가 일어남</p>\n<p> windows는 아예 새로 만듦...?</p>\n<h2>Process Termination</h2>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/blog/static/76c2b67c9795cfa6d815e1b8337b6987/bc563/create-terminate.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 36.47058823529412%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABDklEQVQoz52RXU/CMBiF9/9/EJfES2OURGMQEAfoxtjYZ7t2G/t47DYULrxQ3+SkTZs+55zU6rqOUdC1Zs0lnCr+Mz3Hom0uJ1pRv2/QR5+qqgjDENd1KcuSwkgrxfKouN1E2IeMOI7ZbrckSTLA+rFqkyop6lGeR2ogqn+sNVJKhBDDvlee58yDnOmzw6u9RwY+2ccOaYyaZgxmOTuXyYPN5G6NK4pfVdMiBRH/XLkuCqSuEKkk8vY4foDqqx1SbpY+T242JBgSmsTzvWC68HkJFG3bcvmDc+VrhyYMSFYLtBRsjoL72ZKVE6GKktIYKwN981Jmj2vsQNKeIQPsC/jt0F/UJ5AZxvpPP3s9n1J1HkGrxDi/AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='create terminate' title='create terminate' src='/blog/static/76c2b67c9795cfa6d815e1b8337b6987/ca1dc/create-terminate.png' srcset='/blog/static/76c2b67c9795cfa6d815e1b8337b6987/e7570/create-terminate.png 170w,\n/blog/static/76c2b67c9795cfa6d815e1b8337b6987/f46e7/create-terminate.png 340w,\n/blog/static/76c2b67c9795cfa6d815e1b8337b6987/ca1dc/create-terminate.png 680w,\n/blog/static/76c2b67c9795cfa6d815e1b8337b6987/bc563/create-terminate.png 736w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h3>exit()</h3>\n<p>프로세스가 정상적으로 종료됐는지는 exit()안에 담아서 보낸다</p>\n<ol>\n<li>\n<p>status data를 parent에게 전달</p>\n<p>parent는 wait()로 받음</p>\n</li>\n<li>해당 프로세스는 자신의 리소스를 전부 deallocated</li>\n</ol>\n<h4>exit return value</h4>\n<ul>\n<li>0이면 정상종료</li>\n<li>0이 아니면 비정상 종료</li>\n</ul>\n<p>(사실 os가 진짜 비정상 종료라고 인식하진않고 관습적인... 표현임. 부모 프로세스한테 그냥 0이 아니라고 알려줄뿐)</p>\n<ul>\n<li>wait() 호출하면 자식의 종료 상태가 wait($status)로 전달</li>\n</ul>\n<p>정상적으로 종료되지않았을 때 exit()외에 abort()라는 시스템 콜을 호출할 수도 있다</p>\n<h3>abort()</h3>\n<p>비정상 종료를 명시적으로 호출</p>\n<p>명시적 : 시스템 자체적으로 비정상 알림</p>\n<p>ex. 메모리를 과도하게 요청함</p>\n<h4>좀비 프로세스</h4>\n<p>부모가 wait을 안해줘서, 안거둬줘서 자식이 죽었는데 pcb에 계속 남아 있음</p>\n<p>다른 데이터는 모두 deallocate하고,</p>\n<p>나에게 남은건 부모에게 보낼 exit status뿐...⭐</p>\n<h4>고아 프로세스</h4>\n<p>부모가 wait을 하기전 먼저 죽음</p>\n<p>1번 프로세스인 init이 좀비랑 고아를 거둬들어서 정상적인 종료를 돕는다</p>\n<ul>\n<li>웹 예시</li>\n<li>여러 개의 탭 : renderer</li>\n<li>왜 멀티 프로세싱?</li>\n<li>하나의 프로세스로 하면 특정 페이지의 로딩이 길어질 때 전체의 pending time에 영향을 줌</li>\n<li>\n<p>프로세스간 통신 필요 :  📌 <strong>Inter-process Communication (IPC)</strong></p>\n<ul>\n<li>정보 공유 ex. shared memory, message passing</li>\n<li>모듈화</li>\n</ul>\n</li>\n</ul>\n<h4>📌 IPC</h4>\n<p><strong>shared memory</strong></p>\n<p>진짜 같은 메모리의 주소를 공유</p>\n<p><strong>message passing</strong></p>\n<p>message queue에 메세지를 보냄... 우체통같은거임</p>\n<h2>📌 CPU 스케줄러</h2>\n<p><strong>하나의 프로세스의 전체 시간은 cpu burst와 I/O burst로 나뉜다</strong></p>\n<ul>\n<li>\n<p>cpu burst(cpu execution) : cpu를 연속적으로 계속 사용하는 상태</p>\n<p>보통 5ms 이하</p>\n</li>\n<li>I/O burst (I/O wait) : I/O를 기다릴 때, I/O를 기다릴 때는 cpu를 사용하지않음</li>\n</ul>\n<h3>📌 CPU 스케줄러는 언제 실행되나?</h3>\n<ol>\n<li>I/O 요청을 하고 기다리게 되는 경우 : (running -> waiting) : <strong>nonpreemptive</strong></li>\n<li>계속 돌 수 있는데 쫓겨나는 경우 : (running -> ready) : <strong>preemptive</strong></li>\n<li>I/O 요청이 다 끝난 경우 : ( waiting -> ready) : <strong>preemptive</strong></li>\n<li>돌던 프로세스가 종료 : (terminates) : <strong>nonpreemptive</strong></li>\n</ol>\n<p>1,4번은 현재 cpu에서 돌고있는애가 자리를 내어줌(좀 더 능동적...?) : <strong>nonpreemptive</strong></p>\n<p>1 : 나 아이오 기다려야돼~</p>\n<p>4 : 나 끝남~</p>\n<p>2,3번은 잘돌고있었는데 영문도 모르고 쫓겨남</p>\n<p>2 : ? 더 돌 수 있는데 시간 끝남</p>\n<p>3 : ? 전에 하던에 아이오끝나서 쫓겨남</p>\n<p>cpu 스케줄러는 policy(shedulling policy)랑 mechanism(dispatcher)을 잘 구별해서 만드는게 중요하다!</p>\n<ol>\n<li>📌 scheduling policy : 선택(한 프로세스) : 여러개가 선택될수도?</li>\n<li>📌 dispatcher : 바꿔주는 행동 그 자체</li>\n</ol>\n<p>바꿔주는 동작 그 자체는 계속 쓰면 되지만</p>\n<p>policy는 시간이 지나면 바뀔수도있음</p>\n<p>하나의 시스템 안에서도 여러가지의 policy를 사용할수도있다</p>","frontmatter":{"title":"4-1","date":"April 20, 2022","update":null,"tags":["OS"],"series":"OS"},"fields":{"slug":"/4-1/","readingTime":{"minutes":5.66}}},"seriesList":{"edges":[{"node":{"id":"ac934700-c8a1-56ac-91a7-350a3b21aa36","fields":{"slug":"/1-2/"},"frontmatter":{"title":"OS의 역할과 역사"}}},{"node":{"id":"edf85d35-a010-51bd-95cb-e4ce77cb5311","fields":{"slug":"/os-structure/"},"frontmatter":{"title":"2-1 OS의 구조"}}},{"node":{"id":"59cf7019-4f7b-5fb7-b96f-3bcf7a49789a","fields":{"slug":"/5-2/"},"frontmatter":{"title":"OS 스케줄링"}}},{"node":{"id":"2f8b7cec-b188-5256-88ee-d2ee43663d54","fields":{"slug":"/interrupts-mechanism/"},"frontmatter":{"title":"2-2 Interrupt 메카니즘"}}},{"node":{"id":"3ce6c8ef-171c-515d-8439-79b45f5e3076","fields":{"slug":"/3-1/"},"frontmatter":{"title":"3-1"}}},{"node":{"id":"16f5a932-6b37-5240-976b-d657b8812a88","fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}}},{"node":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","fields":{"slug":"/4-1/"},"frontmatter":{"title":"4-1"}}},{"node":{"id":"3c3d7c71-bf68-593e-9b21-c03bfff45743","fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}}]},"previous":{"fields":{"slug":"/3-2/"},"frontmatter":{"title":"3-2 프로세스 탐구"}},"next":{"fields":{"slug":"/4-2/"},"frontmatter":{"title":"4-2"}}},"pageContext":{"id":"1a9e00c7-a3b4-5079-9382-4ec7f5e7d178","series":"OS","previousPostId":"16f5a932-6b37-5240-976b-d657b8812a88","nextPostId":"3c3d7c71-bf68-593e-9b21-c03bfff45743"}},"staticQueryHashes":[]}